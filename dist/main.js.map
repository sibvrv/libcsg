{"version":3,"sources":["webpack://libcsg/webpack/universalModuleDefinition","webpack://libcsg/webpack/bootstrap","webpack://libcsg/./core/constants.js","webpack://libcsg/./core/math/Vector3.js","webpack://libcsg/./core/math/Vector2.js","webpack://libcsg/./core/math/Polygon3.js","webpack://libcsg/./core/utils.js","webpack://libcsg/./core/math/Plane.js","webpack://libcsg/./core/math/Vertex3.js","webpack://libcsg/./core/CSGFactories.js","webpack://libcsg/./core/CAGFactories.js","webpack://libcsg/./core/CAG.js","webpack://libcsg/./core/math/Matrix4.js","webpack://libcsg/./core/math/OrthoNormalBasis.js","webpack://libcsg/./core/CSG.js","webpack://libcsg/./core/connectors.js","webpack://libcsg/./core/math/Vertex2.js","webpack://libcsg/./api/optionParsers.js","webpack://libcsg/./core/math/Line3.js","webpack://libcsg/./core/math/Side.js","webpack://libcsg/./core/math/Path2.js","webpack://libcsg/./csg.js","webpack://libcsg/./core/math/Line2.js","webpack://libcsg/./modifiers/boolean/index.ts","webpack://libcsg/./api/ops-extrusions.js","webpack://libcsg/./core/Properties.js","webpack://libcsg/./core/math/Polygon2.js","webpack://libcsg/./core/utils/cagValidation.js","webpack://libcsg/./core/utils/canonicalize.js","webpack://libcsg/./core/FuzzyFactory3d.js","webpack://libcsg/./core/FuzzyFactory.js","webpack://libcsg/./core/utils/retesellate.js","webpack://libcsg/./api/ops-cnc.js","webpack://libcsg/./api/center.js","webpack://libcsg/./api/ops-expandContract.js","webpack://libcsg/./api/primitives2d-api.js","webpack://libcsg/./modifiers/transforms/ops-transformations.js","webpack://libcsg/./main.ts","webpack://libcsg/./api/index.ts","webpack://libcsg/./api/primitives3d-api.js","webpack://libcsg/./core/mutators.js","webpack://libcsg/./core/trees.js","webpack://libcsg/./core/math/lineUtils.js","webpack://libcsg/./modifiers/boolean/union.ts","webpack://libcsg/./modifiers/boolean/difference.ts","webpack://libcsg/./modifiers/boolean/intersection.ts","webpack://libcsg/./core/FuzzyFactory2d.js","webpack://libcsg/./core/math/reTesselateCoplanarPolygons.js","webpack://libcsg/./core/utils/cagMeasurements.js","webpack://libcsg/./api/helpers.js","webpack://libcsg/./api/cagOutlinePaths.js","webpack://libcsg/./core/utils/toArray.js","webpack://libcsg/./api/solidFromSlices.js","webpack://libcsg/./core/utils/fixTJunctions.js","webpack://libcsg/./core/utils/csgMeasurements.js","webpack://libcsg/./core/utils/csgProjections.js","webpack://libcsg/./api/ops-cuts.js","webpack://libcsg/./api/primitives2d.js","webpack://libcsg/./api/primitives3d.js","webpack://libcsg/./api/color.js","webpack://libcsg/./api/maths.js","webpack://libcsg/./api/text.js","webpack://libcsg/./fonts/single-line/hershey/simplex.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","areaEPS","Math","sin","staticTag","_CSGDEBUG","defaultResolution2D","defaultResolution3D","EPS","angleEPS","all","top","bottom","left","right","front","back","getTag","IsFloat","Vector2D","Vector3D","x","y","z","arguments","length","this","_x","parseFloat","_y","_z","ok","Array","v","Error","Create","result","clone","negated","abs","plus","a","minus","times","dividedBy","dot","lerp","lengthSquared","sqrt","unit","cross","distanceTo","distanceToSquared","equals","multiply4x4","matrix4x4","leftMultiply1x3Vector","transform","toString","toFixed","randomNonParallelVector","min","max","fromAngle","radians","fromAngleRadians","fromAngleDegrees","degrees","PI","cos","toVector3D","normal","leftMultiply1x2Vector","angle","angleRadians","angleDegrees","atan2","Vertex","Matrix4x4","Polygon","vertices","shared","plane","defaultShared","Plane","fromVector3Ds","pos","checkIfConvex","verticesConvex","setColor","args","newshared","Shared","fromColor","apply","getSignedVolume","signedVolume","getArea","polygonArea","getTetraFeatures","features","forEach","feature","push","extrude","offsetvector","fromPolygons","newpolygons","polygon1","flipped","polygon2","translate","numvertices","sidefacepoints","nexti","xn","fromPosAndUV","sidefacepolygon","offset","translation","boundingSphere","cachedBoundingSphere","box","boundingBox","middle","radius","cachedBoundingBox","minpoint","maxpoint","point","newvertices","map","reverse","newplane","isMirroring","vertex","projectToOrthoNormalBasis","orthobasis","CAG","fromPointsNoCheck","to2D","area","solidFromSlices","options","fromObject","obj","createFromPoints","points","polygon","vec","planenormal","prevprevpos","prevpos","isConvexPoint","prevpoint","nextpoint","isStrictlyConvexPoint","color","slice","tag","getHash","join","fnNumberSort","b","fnSortByIndex","index","isNaN","Infinity","solve2Linear","u","invdet","insertSorted","array","element","comparefunc","leftbound","rightbound","testindex","floor","splice","interpolateBetween2DPointsForY","point1","point2","f1","f2","isCAG","sides","isCSG","polygons","Line3D","w","anyPlaneFromVector3Ds","v1","v2","fromPoints","fromNormalAndPoint","ismirror","point3","splitLineBetweenPoints","p1","p2","direction","labda","intersectWithLine","line3d","intersectWithPlane","fromPlanes","signedDistanceToPoint","mirrorPoint","point3d","distance","uv","newVertex","interpolate","other","newpos","newUv","Polygon2D","Polygon3D","csg","isCanonicalized","isRetesselated","fromSlices","fromCompactBinary","bin","planes","planeData","numplanes","arrayindex","planeindex","vertexData","vertexindex","numpolygonvertices","polygonvertices","shareds","numpolygons","numPolygons","numVerticesPerPolygon","polygonVertices","polygonPlaneIndexes","polygonSharedIndexes","polygonindex","Side","Vertex2","isSelfIntersecting","contains","union","difference","fromSides","cag","isArray","undefined","fromPointsArray","fromNestedPointsArray","prevvertex","canonicalized","paths","path","tree","parents","isHole","parentKey","side","fromPath2","isClosed","getPoints","fromFakeCSG","_fromFakePolygon","filter","numsides","sideVertexIndices","sideindex","vertexindex0","vertexindex1","Connector","Vertex3D","canonicalize","retesselate","isCAGValid","hasPointInside","getBounds","overCutInsideCorners","extrudeInOrthonormalBasis","extrudeInPlane","rotateExtrude","cagoutlinePaths","center","expand","contract","expandedShellOfCAG","cags","_toCSGWall","reTesselated","subtract","subtractSub","intersect","intersectSub","newsides","axes","expandedShell","resolution","debug","orthonormalbasis","depth","axis1","axis2","check","getOutlinePaths","cutterradius","z0","z1","toPolygon3D","_toVector3DPairs","pairs","p0","vertex0","vertex1","pair","_toPlanePolygons","assign","origin","defaultAxis","defaultNormal","thisConnector","axisVector","normalVector","toConnector","getTransformationTo","bounds","csgshell","csgplane","invert","polys","poly","_toWallPolygons","iteration","toConnector1","toConnector2","toCag","m1","axisvector","m2","vps1","vps2","hasMirroredNormals","vps1List","vps2List","vps1Temp","vps2Temp","xbot0","xtop0","vp1","j","xbot1","xtop1","y0","y1","toPoints","shift","toCompactBinary","vertexmap","Uint32Array","sidevertexindicesindex","vertextag","Float64Array","verticesArrayIndex","OrthoNormalBasis","elements","multiply","this0","this1","this2","this3","this4","this5","this6","this7","this8","this9","this10","this11","this12","this13","this14","this15","m0","m3","m4","m5","m6","m7","m8","m9","m10","m11","m12","m13","m14","m15","rightMultiply1x3Vector","v0","invw","rightMultiply1x2Vector","unity","rotationX","rotationY","rotationZ","rotation","rotationCenter","rotationAxis","rotationPlane","transformation","getProjectionMatrix","getInverseProjectionMatrix","els","mirroring","nx","ny","nz","scaling","Line2D","rightvector","planeorigin","GetCartesian","xaxisid","yaxisid","axisid","Z0Plane","vec3","to3D","vec2","line3Dto2D","a2d","b2d","line2Dto3D","line2d","a3d","b3d","rightpointTransformed","originTransformed","newrighthandvector","Tree","Properties","fixTJunctions","lieFlat","getTransformationToFlatLying","getTransformationAndInverseTransformationToFlatLying","sectionCut","cutByPlane","expandedShellOfCCSG","CSG","properties","csgs","unionSub","mayOverlap","clipTo","allPolygons","concat","_merge","unionForNonIntersecting","islast","addPolygons","flippedpolygons","transform1","_transform","transformedvertices","transformedplanes","planetag","newvertex","unionWithThis","stretchAtPlane","onb","midpiece","piece1","piece2","mybounds","otherbounds","connectTo","myConnector","otherConnector","mirror","normalrotation","matrix","setShared","getFeatures","toTriangles","triPoly","reduce","pv","feat","toPolygons","planemap","sharedmap","numshared","sharedtag","polygonVerticesIndex","sharedindex","planesArrayIndex","firstVertex","normalvector","normalized","Number","us","axesplane","axesbasis","angle1","angle2","usAxesAligned","normalsplane","normalsbasis","axisLine","extend","newpoint","ConnectorList","connectors","connectors_","fromPath2D","path2D","arg1","arg2","_fromPath2DTangents","_fromPath2DExplicit","start","end","axis","pathLen","appendConnector","closed","angleIsh","rotateZ","pt","getAngle","setClosed","conn","followWith","cagish","getCag","connector","verify","currCag","prevConnector","prevCag","notFirst","connI","connI1","parseOption","optionname","defaultvalue","parseOptionAsInt","parseOptionAsFloat","parseOptionAsBool","parseOptionAs3DVector","parseOptionAs2DVector","parseOptionAs3DVectorList","res","mabsx","mabsy","mabsz","line","newdirection","closestPointOnLine","distanceToPoint","closestpoint","Vertex3","vert1Indices","pts2d","newp1","newp2","Path2D","newpoints","skip","arc","startangle","endangle","maketangent","absangledif","numsteps","edgestepsize","numstepsMod","step","otherpath","appendPoint","appendPoints","close","getTurn","twice_area","last","current","rectangularExtrude","width","height","expandToCAG","pathradius","numpoints","startindex","pointindex","innerToCAG","appendBezier","controlpoints","factorials","controlpointsParsed","lastBezierControlPoint","bezierOrder","fact","binomials","binomial","getPointForT","t_k","one_minus_t_n_minus_k","pow","inv_1_minus_t","k","bernstein_coefficient","newpoints_t","subdivideBase","maxangle","maxsinangle","dir1","dir2","sinangle","t0","t1","t0_new","t1_new","point0_new","point1_new","appendArc","endpoint","decimals","xradius","yradius","xaxisrotation","clockwise","largearc","startpoint","round","sweepFlag","phi","cosphi","sinphi","minushalfdistance","startTranslated","biglambda","sqrtbiglambda","multiplier1","centerTranslated","vec1","theta1","deltatheta","ceil","theta","costheta","sintheta","addTransformationMethodsToPrototype","addCenteringToPrototype","circle","ellipse","rectangle","roundedRectangle","sphere","cube","roundedCube","cylinder","roundedCylinder","cylinderElliptic","polyhedron","CAGFactories","optionsParsers","globalApi","xAtY","absDistanceToPoint","pointProjected","pointOnPlane","neworigin","newnormal","newpointOnPlane","neww","intersection","Matrix4","cagToPointsArray","clamp","rightMultiply1x3VectorToArray","polygonFromPoints","extruded","offsetVector","twistangle","twiststeps","c1","c2","linear_extrude","params","baseShape","twist","slices","output","rotate_extrude","defaults","fn","startAngle","overflow","totalAngle","segments","overlapTolerance","shapePoints","pointsWithNegativeX","pointsWithPositiveX","arePointsWithNegAndPosX","curPoint","nextPoint","prevMatrix","curMatrix","pointA","pointAP","pointB","pointBP","overlappingPoints","sideShape","endMatrix","endCap","startMatrix","startCap","alpha","axisV","normalV","connS","connE","connT2","connT1","rectangular_extrude","basePoints","h","transformObj","otherproperties","cloneObj","addFrom","source","propertyname","propertyvalue","transformed","cloned","linesIntersect","inside","errors","pointcount","mappoint","count","ertxt","err","side0","ii","side1","console","log","cag1","cag2","il","FuzzyCSGFactory","FuzzyCAGFactory","canonicalizeCSG","CSGFromCSGFuzzyFactory","canonicalizeCAG","CAGFromCAGFuzzyFactory","sourcecsg","_this","newpolygon","getPolygon","sourcecag","getSide","csgOrCAG","FuzzyFactory","vertexfactory","planefactory","polygonsharedfactory","getPolygonShared","sourceshared","hash","getVertex","sourcevertex","lookupOrCreate","getPlane","sourceplane","sourcepolygon","newverticesDedup","prevvertextag","numdimensions","tolerance","lookuptable","multiplier","creatorCallback","el","valueQuantized","hashparts","q0","numhashes","hashmask","hashmaskShifted","hashpart","reTesselateCoplanarPolygons","polygonsPerPlane","fuzzyfactory","destpolygons","sourcepolygons","retesselayedpolygons","_csg","besttransformation","bestinversetransformation","xvector","yvector","zvector","z0connectorx","z0connectory","isfirst","minheight","maxdotz","inversetransformation","pointonplane","planeconnector","transformedcsg","dotz","zheight","isbetter","_cag","pointmap","from","to","cutouts","pointtag","pointobj","fromcoord","pointcoord","tocoord","midvector","circlesegmentangle","radiuscorrected","circlecenter","deltaangle","toArray","objects","results","dl","shellpoints","newcag","pcenter","end1","end2","fullcircle","extrudevector","extrudedface","vertexpairs","vertextagpair","planenormals","vertexpair","zbase","xbase","ybase","angles","iMax","si","co","sort","prevp1","prevp2","numangles","startfacevertices","endfacevertices","normals","vertexobj","xaxis","bestzaxis","bestzaxisorthogonality","crosslength","yaxis","zaxis","_sphere","shape","square","off","isFinite","size","triangle","Vector3","hull","pts","done","ConvexHullPoint","compare","ConvexHull","indices","getIndices","clear","ccw","p3","compute","_points","al","ang","dist","tmp","stack","M","ch","vector","_objects","scale","rotate","rotateX","rotateY","transformationMatrix","mirrored","minkowski","chain_hull","hulls","hullsAmount","primitives3d","primitives2d","transformations","extrusions","maths","text","Polygon3","geodesicSphere","ci","ti","geodesicSubDivide","f","s0","s1","s2","q","mix3","s3","triangles","_f","g","pgs","ref","colors","pp","roundradius","type","r1","r2","d1","d2","radiusStart","radiusEnd","torus","ri","ro","fni","fno","roti","baseCircle","prot","mirroredX","mirroredY","mirroredZ","deg","rotateEulerAngles","beta","gamma","position","Rz1","Rx","Rz2","T","rotateEulerXYZ","Ry","Rz","cAxes","indexOf","PolygonTreeNode","parent","children","removed","isRootNode","addChild","remove","parentschildren","recursivelyInvalidatePolygon","isRemoved","invertSub","getPolygons","node","queue","splitByPlane","coplanarfrontnodes","coplanarbacknodes","frontnodes","backnodes","nodes","_splitByPlane","bound","sphereradius","spherecenter","splitresult","thisw","hasfront","hasback","vertexIsBack","MINEPS","isback","frontvertices","backvertices","nextvertexindex","nextisback","interpolationFactor","pointa","pointb","intermediatePoint","intersectionvertex","EPS_SQUARED","splitPolygonByPlane","frontnode","backnode","newchild","polygonTree","rootnode","Node","alsoRemovecoplanarFront","polygontreenodes","addPolygonTreeNodes","temp","clipPolygons","numpolygontreenodes","node1","numbacknodes","pop","bestplane","getParentPlaneNormals","maxdepth","p0start","p0end","p1start","p1end","d0","alphas","extrude2d","sourceside","calcInterpolationFactor","polygonvertices2d","polygonuvcoordinates","polygontopvertexindexes","topy2polygonindexes","ycoordinatetopolygonindexes","ycoordinatebins","ycoordinateBinningFactor","poly3d","vertices2d","uvcoordinates","minindex","miny","maxy","maxindex","newy","pos2d","uvcoordinate","ycoordinatebin","ycoordinates","ycoordinate","activepolygons","prevoutpolygonrow","yindex","nextycoordinate","newoutpolygonrow","ycoordinate_as_string","polygonindexeswithcorner","activepolygonindex","activepolygon","newleftvertexindex","leftvertexindex","newrightvertexindex","rightvertexindex","nextleftvertexindex","nextrightvertexindex","topleft","topleftuv","topright","toprightuv","bottomleft","bottomleftuv","bottomright","bottomrightuv","middleycoordinate","startingpolygonindexes","polygonindex_key","topvertexindex","topleftvertexindex","toprightvertexindex","newactivepolygon","el1","el2","x1","x2","activepolygonKey","outpolygon","leftline","rightline","prevoutpolygon","prevcontinuedindexes","matchedindexes","thispolygon","prevpolygon","leftlinecontinues","rightlinecontinues","rightlineisconvex","rightpoints","rightuvcoordinates","leftpoints","leftuvcoordinates","points2d","vertices3d","point2d","vertex3d","input","sideTagToSideMap","startVertexTagToSideTagMap","sidetag","startvertextag","startsidetag","aVertexTag","sidesForcagVertex","connectedVertexPoints","cagside","nextvertextag","nextpossiblesidetags","nextsideindex","bestangle","cagangle","nextpossiblesidetag","angledif","nextsidetag","data","constructor","_addWalls","walls","bFlipped","bottomPoints","topPoints","len","iTopLen","iBotLen","iExtra","bMoreTops","bMoreBottoms","aMin","secondPoint","nBotFacet","nTopFacet","getTriangle","pointC","bpoint","tpoint","iB","iT","fnCallback","prev","numSlices","bLoop","Boolean","numslices","callback","every","unshift","addSide","sidemap","vertextag2sidestart","vertextag2sideend","starttag","endtag","newsidetag","deleteSide","newsideobj","idx","sideobjs","sideobj","nextvertex","reversesidetag","ar","sidestocheck","sidemapisempty","donesomething","sidetagtocheck","donewithside","directionindex","startvertex","endvertex","endvertextag","matchingsides","matchingsideindex","matchingside","matchingsidestartvertex","matchingsideendvertex","matchingsidestartvertextag","startpos","endpos","insertionvertextag","insertionvertextagindex","found","loop","item","newsidetag1","newsidetag2","newcsg","volume","Vector2","plane1","plane2","cut3d","planecenter","maxdistance","corner1","corner2","rswap","e2","large","maxroundradius","rect","prevcylinderpoint","qresolution","slice1","cylinderpoint","prevcospitch","prevsinpitch","slice2","pitch","cospitch","sinpitch","facepoint","info","facecenters","cuberadius","innerradius","e","rEnd","rStart","ray","axisZ","axisX","axisY","out","cylCenter","fptVec","fptVec90","facepointH","facepointH90","defaultnormal","faces","face","cssColors","css2rgb","toLowerCase","hue2rgb","rgb2hsl","hsl2rgb","rgb2hsv","hsv2rgb","html2rgb","parseInt","rgb2html","substring","asin","acos","tan","atan","rands","vn","seed","random","lookup","ix","a0","a1","sign","defaultsVectorParams","xOffset","yOffset","align","font","lineSpacing","letterSpacing","extrudeOffset","vectorParams","translateLine","segment","jl","vectorChar","char","code","charCodeAt","glyph","ratio","extrudeYOffset","polyline","gx","gy","vectorText","vect","diff","lines","maxWidth","lineStart","pushLine","vector_char","vector_text","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAgB,OAAID,IAEpBD,EAAa,OAAIC,IARnB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,IAIjBhC,EAAoBA,EAAoBiC,EAAI,I,gBClFrD,MAyBMC,EAAU,KAXJ,KAWuBC,KAAKC,IANvB,IAgBjB,IAAIC,EAAY,EAGhB1C,EAAOD,QAAU,CACf4C,WAvCgB,EAwChBC,oBAnC0B,GAoC1BC,oBAhC0B,GAiC1BC,IA5BU,KA6BVC,SAxBe,GAyBfR,UACAS,IAlBU,EAmBVC,IAlBU,EAmBVC,OAlBa,EAmBbC,KAlBW,EAmBXC,MAlBY,EAmBZC,MAlBY,EAmBZC,KAlBW,EAmBXZ,YACAa,OAjBa,IAAMb,M,gBCpCrB,MAAM,QAACc,GAAW,EAAQ,GACpBC,EAAW,EAAQ,GAanBC,EAAW,SAAUC,EAAGC,EAAGC,GAC/B,GAAyB,IAArBC,UAAUC,OACZC,KAAKC,GAAKC,WAAWP,GACrBK,KAAKG,GAAKD,WAAWN,GACrBI,KAAKI,GAAKF,WAAWL,QAChB,GAAyB,IAArBC,UAAUC,OACnBC,KAAKC,GAAKC,WAAWP,GACrBK,KAAKG,GAAKD,WAAWN,GACrBI,KAAKI,GAAK,MACL,CACL,IAAIC,GAAK,EACT,GAAyB,IAArBP,UAAUC,OACZ,GAAmB,iBAAR,EACLJ,aAAaD,GACfM,KAAKC,GAAKN,EAAEM,GACZD,KAAKG,GAAKR,EAAEQ,GACZH,KAAKI,GAAKT,EAAES,IACHT,aAAaF,GACtBO,KAAKC,GAAKN,EAAEM,GACZD,KAAKG,GAAKR,EAAEQ,GACZH,KAAKI,GAAK,GACDT,aAAaW,MACjBX,EAAEI,OAAS,GAAOJ,EAAEI,OAAS,EAChCM,GAAK,GAELL,KAAKC,GAAKC,WAAWP,EAAE,IACvBK,KAAKG,GAAKD,WAAWP,EAAE,IACN,IAAbA,EAAEI,OACJC,KAAKI,GAAKF,WAAWP,EAAE,IAEvBK,KAAKI,GAAK,GAGJ,MAAOT,GAAO,MAAOA,GAC/BK,KAAKC,GAAKC,WAAWP,EAAEA,GACvBK,KAAKG,GAAKD,WAAWP,EAAEC,GAErBI,KAAKI,GADH,MAAOT,EACCO,WAAWP,EAAEE,GAEb,GAEF,OAAQF,GAAO,OAAQA,GACjCK,KAAKC,GAAKC,WAAWP,EAAEM,IACvBD,KAAKG,GAAKD,WAAWP,EAAEQ,IAErBH,KAAKI,GADH,OAAQT,EACAO,WAAWP,EAAES,IAEb,GAEPC,GAAK,MACP,CACL,IAAIE,EAAIL,WAAWP,GACnBK,KAAKC,GAAKM,EACVP,KAAKG,GAAKI,EACVP,KAAKI,GAAKG,OAEPF,GAAK,EACZ,IAAIA,EAGF,MAAM,IAAIG,MAAM,mBAFVhB,EAAQQ,KAAKC,KAAUT,EAAQQ,KAAKG,KAAUX,EAAQQ,KAAKI,MAAMC,GAAK,KASlFX,EAASe,OAAS,SAAUd,EAAGC,EAAGC,GAChC,IAAIa,EAASzD,OAAOY,OAAO6B,EAASvB,WAIpC,OAHAuC,EAAOT,GAAKN,EACZe,EAAOP,GAAKP,EACZc,EAAON,GAAKP,EACLa,GAGThB,EAASvB,UAAY,CACnB,QACE,OAAO6B,KAAKC,IAEd,QACE,OAAOD,KAAKG,IAEd,QACE,OAAOH,KAAKI,IAGd,MAAMG,GACJ,MAAM,IAAIC,MAAM,0BAElB,MAAMD,GACJ,MAAM,IAAIC,MAAM,0BAElB,MAAMD,GACJ,MAAM,IAAIC,MAAM,0BAGlBG,MAAO,WACL,OAAOjB,EAASe,OAAOT,KAAKC,GAAID,KAAKG,GAAIH,KAAKI,KAGhDQ,QAAS,WACP,OAAOlB,EAASe,QAAQT,KAAKC,IAAKD,KAAKG,IAAKH,KAAKI,KAGnDS,IAAK,WACH,OAAOnB,EAASe,OAAOjC,KAAKqC,IAAIb,KAAKC,IAAKzB,KAAKqC,IAAIb,KAAKG,IAAK3B,KAAKqC,IAAIb,KAAKI,MAG7EU,KAAM,SAAUC,GACd,OAAOrB,EAASe,OAAOT,KAAKC,GAAKc,EAAEd,GAAID,KAAKG,GAAKY,EAAEZ,GAAIH,KAAKI,GAAKW,EAAEX,KAGrEY,MAAO,SAAUD,GACf,OAAOrB,EAASe,OAAOT,KAAKC,GAAKc,EAAEd,GAAID,KAAKG,GAAKY,EAAEZ,GAAIH,KAAKI,GAAKW,EAAEX,KAGrEa,MAAO,SAAUF,GACf,OAAOrB,EAASe,OAAOT,KAAKC,GAAKc,EAAGf,KAAKG,GAAKY,EAAGf,KAAKI,GAAKW,IAG7DG,UAAW,SAAUH,GACnB,OAAOrB,EAASe,OAAOT,KAAKC,GAAKc,EAAGf,KAAKG,GAAKY,EAAGf,KAAKI,GAAKW,IAG7DI,IAAK,SAAUJ,GACb,OAAOf,KAAKC,GAAKc,EAAEd,GAAKD,KAAKG,GAAKY,EAAEZ,GAAKH,KAAKI,GAAKW,EAAEX,IAGvDgB,KAAM,SAAUL,EAAGtD,GACjB,OAAOuC,KAAKc,KAAKC,EAAEC,MAAMhB,MAAMiB,MAAMxD,KAGvC4D,cAAe,WACb,OAAOrB,KAAKmB,IAAInB,OAGlBD,OAAQ,WACN,OAAOvB,KAAK8C,KAAKtB,KAAKqB,kBAGxBE,KAAM,WACJ,OAAOvB,KAAKkB,UAAUlB,KAAKD,WAG7ByB,MAAO,SAAUT,GACf,OAAOrB,EAASe,OACdT,KAAKG,GAAKY,EAAEX,GAAKJ,KAAKI,GAAKW,EAAEZ,GAAIH,KAAKI,GAAKW,EAAEd,GAAKD,KAAKC,GAAKc,EAAEX,GAAIJ,KAAKC,GAAKc,EAAEZ,GAAKH,KAAKG,GAAKY,EAAEd,KAGnGwB,WAAY,SAAUV,GACpB,OAAOf,KAAKgB,MAAMD,GAAGhB,UAGvB2B,kBAAmB,SAAUX,GAC3B,OAAOf,KAAKgB,MAAMD,GAAGM,iBAGvBM,OAAQ,SAAUZ,GAChB,OAAQf,KAAKC,KAAOc,EAAEd,IAAQD,KAAKG,KAAOY,EAAEZ,IAAQH,KAAKI,KAAOW,EAAEX,IAKpEwB,YAAa,SAAUC,GACrB,OAAOA,EAAUC,sBAAsB9B,OAGzC+B,UAAW,SAAUF,GACnB,OAAOA,EAAUC,sBAAsB9B,OAGzCgC,SAAU,WACR,MAAO,IAAMhC,KAAKC,GAAGgC,QAAQ,GAAK,KAAOjC,KAAKG,GAAG8B,QAAQ,GAAK,KAAOjC,KAAKI,GAAG6B,QAAQ,GAAK,KAI5FC,wBAAyB,WACvB,IAAIrB,EAAMb,KAAKa,MACf,OAAKA,EAAIZ,IAAMY,EAAIV,IAAQU,EAAIZ,IAAMY,EAAIT,GAChCV,EAASe,OAAO,EAAG,EAAG,GACnBI,EAAIV,IAAMU,EAAIZ,IAAQY,EAAIV,IAAMU,EAAIT,GACvCV,EAASe,OAAO,EAAG,EAAG,GAEtBf,EAASe,OAAO,EAAG,EAAG,IAIjC0B,IAAK,SAAU9D,GACb,OAAOqB,EAASe,OACdjC,KAAK2D,IAAInC,KAAKC,GAAI5B,EAAE4B,IAAKzB,KAAK2D,IAAInC,KAAKG,GAAI9B,EAAE8B,IAAK3B,KAAK2D,IAAInC,KAAKI,GAAI/B,EAAE+B,MAG1EgC,IAAK,SAAU/D,GACb,OAAOqB,EAASe,OACdjC,KAAK4D,IAAIpC,KAAKC,GAAI5B,EAAE4B,IAAKzB,KAAK4D,IAAIpC,KAAKG,GAAI9B,EAAE8B,IAAK3B,KAAK4D,IAAIpC,KAAKI,GAAI/B,EAAE+B,OAI5EpE,EAAOD,QAAU2D,G,gBCpNjB,MAAM,QAACF,GAAW,EAAQ,GAWpBC,EAAW,SAAUE,EAAGC,GAC5B,GAAyB,IAArBE,UAAUC,OACZC,KAAKC,GAAKC,WAAWP,GACrBK,KAAKG,GAAKD,WAAWN,OAChB,CACL,IAAIS,GAAK,EACT,GAAyB,IAArBP,UAAUC,OACZ,GAAmB,iBAAR,EACLJ,aAAaF,GACfO,KAAKC,GAAKN,EAAEM,GACZD,KAAKG,GAAKR,EAAEQ,IACHR,aAAaW,OACtBN,KAAKC,GAAKC,WAAWP,EAAE,IACvBK,KAAKG,GAAKD,WAAWP,EAAE,KACb,MAAOA,GAAO,MAAOA,GAC/BK,KAAKC,GAAKC,WAAWP,EAAEA,GACvBK,KAAKG,GAAKD,WAAWP,EAAEC,IAClBS,GAAK,MACP,CACL,IAAIE,EAAIL,WAAWP,GACnBK,KAAKC,GAAKM,EACVP,KAAKG,GAAKI,OAEPF,GAAK,EAIZ,GAHIA,IACIb,EAAQQ,KAAKC,KAAUT,EAAQQ,KAAKG,MAAME,GAAK,KAElDA,EACH,MAAM,IAAIG,MAAM,qBAKtBf,EAAS4C,UAAY,SAAUC,GAC7B,OAAO7C,EAAS8C,iBAAiBD,IAGnC7C,EAAS+C,iBAAmB,SAAUC,GACpC,IAAIH,EAAU9D,KAAKkE,GAAKD,EAAU,IAClC,OAAOhD,EAAS8C,iBAAiBD,IAGnC7C,EAAS8C,iBAAmB,SAAUD,GACpC,OAAO7C,EAASgB,OAAOjC,KAAKmE,IAAIL,GAAU9D,KAAKC,IAAI6D,KAKrD7C,EAASgB,OAAS,SAAUd,EAAGC,GAC7B,IAAIc,EAASzD,OAAOY,OAAO4B,EAAStB,WAGpC,OAFAuC,EAAOT,GAAKN,EACZe,EAAOP,GAAKP,EACLc,GAGTjB,EAAStB,UAAY,CACnB,QACE,OAAO6B,KAAKC,IAEd,QACE,OAAOD,KAAKG,IAGd,MAAMI,GACJ,MAAM,IAAIC,MAAM,0BAElB,MAAMD,GACJ,MAAM,IAAIC,MAAM,0BAIlBoC,WAAY,SAAU/C,GAEpB,OAAO,IADU,EAAQ,GAClB,CAAaG,KAAKC,GAAID,KAAKG,GAAIN,IAGxC8B,OAAQ,SAAUZ,GAChB,OAAQf,KAAKC,KAAOc,EAAEd,IAAQD,KAAKG,KAAOY,EAAEZ,IAG9CQ,MAAO,WACL,OAAOlB,EAASgB,OAAOT,KAAKC,GAAID,KAAKG,KAGvCS,QAAS,WACP,OAAOnB,EAASgB,QAAQT,KAAKC,IAAKD,KAAKG,KAGzCW,KAAM,SAAUC,GACd,OAAOtB,EAASgB,OAAOT,KAAKC,GAAKc,EAAEd,GAAID,KAAKG,GAAKY,EAAEZ,KAGrDa,MAAO,SAAUD,GACf,OAAOtB,EAASgB,OAAOT,KAAKC,GAAKc,EAAEd,GAAID,KAAKG,GAAKY,EAAEZ,KAGrDc,MAAO,SAAUF,GACf,OAAOtB,EAASgB,OAAOT,KAAKC,GAAKc,EAAGf,KAAKG,GAAKY,IAGhDG,UAAW,SAAUH,GACnB,OAAOtB,EAASgB,OAAOT,KAAKC,GAAKc,EAAGf,KAAKG,GAAKY,IAGhDI,IAAK,SAAUJ,GACb,OAAOf,KAAKC,GAAKc,EAAEd,GAAKD,KAAKG,GAAKY,EAAEZ,IAGtCiB,KAAM,SAAUL,EAAGtD,GACjB,OAAOuC,KAAKc,KAAKC,EAAEC,MAAMhB,MAAMiB,MAAMxD,KAGvCsC,OAAQ,WACN,OAAOvB,KAAK8C,KAAKtB,KAAKmB,IAAInB,QAG5ByB,WAAY,SAAUV,GACpB,OAAOf,KAAKgB,MAAMD,GAAGhB,UAGvB2B,kBAAmB,SAAUX,GAC3B,OAAOf,KAAKgB,MAAMD,GAAGM,iBAGvBA,cAAe,WACb,OAAOrB,KAAKmB,IAAInB,OAGlBuB,KAAM,WACJ,OAAOvB,KAAKkB,UAAUlB,KAAKD,WAG7ByB,MAAO,SAAUT,GACf,OAAOf,KAAKC,GAAKc,EAAEZ,GAAKH,KAAKG,GAAKY,EAAEd,IAItC4C,OAAQ,WACN,OAAOpD,EAASgB,OAAOT,KAAKG,IAAKH,KAAKC,KAKxC2B,YAAa,SAAUC,GACrB,OAAOA,EAAUiB,sBAAsB9C,OAGzC+B,UAAW,SAAUF,GACnB,OAAOA,EAAUiB,sBAAsB9C,OAGzC+C,MAAO,WACL,OAAO/C,KAAKgD,gBAGdC,aAAc,WAEZ,OAAO,IADOjD,KAAKgD,eACIxE,KAAKkE,IAG9BM,aAAc,WAEZ,OAAOxE,KAAK0E,MAAMlD,KAAKG,GAAIH,KAAKC,KAGlCkC,IAAK,SAAU9D,GACb,OAAOoB,EAASgB,OACdjC,KAAK2D,IAAInC,KAAKC,GAAI5B,EAAE4B,IAAKzB,KAAK2D,IAAInC,KAAKG,GAAI9B,EAAE8B,MAGjDiC,IAAK,SAAU/D,GACb,OAAOoB,EAASgB,OACdjC,KAAK4D,IAAIpC,KAAKC,GAAI5B,EAAE4B,IAAKzB,KAAK4D,IAAIpC,KAAKG,GAAI9B,EAAE8B,MAGjD6B,SAAU,WACR,MAAO,IAAMhC,KAAKC,GAAGgC,QAAQ,GAAK,KAAOjC,KAAKG,GAAG8B,QAAQ,GAAK,KAGhEpB,IAAK,WACH,OAAOpB,EAASgB,OAAOjC,KAAKqC,IAAIb,KAAKC,IAAKzB,KAAKqC,IAAIb,KAAKG,OAI5DnE,EAAOD,QAAU0D,G,gBCnMjB,MAAMA,EAAW,EAAQ,GACnBC,EAAW,EAAQ,GACnByD,EAAS,EAAQ,GACjBC,EAAY,EAAQ,KACpB,UAACzE,EAAS,IAAEG,EAAG,OAAES,EAAM,QAAEhB,GAAW,EAAQ,GA4BlD,IAAI8E,EAAU,SAAUC,EAAUC,EAAQC,GAMxC,GALAxD,KAAKsD,SAAWA,EACXC,IAAQA,EAASF,EAAQI,eAC9BzD,KAAKuD,OAASA,EAGVzD,UAAUC,QAAU,EACtBC,KAAKwD,MAAQA,MACR,CACL,MAAME,EAAQ,EAAQ,GACtB1D,KAAKwD,MAAQE,EAAMC,cAAcL,EAAS,GAAGM,IAAKN,EAAS,GAAGM,IAAKN,EAAS,GAAGM,KAGjF,GAAIjF,IACGqB,KAAK6D,gBACR,MAAM,IAAIrD,MAAM,gBAKtB6C,EAAQlF,UAAY,CAIlB0F,cAAe,WACb,OAAOR,EAAQS,eAAe9D,KAAKsD,SAAUtD,KAAKwD,MAAMX,SAK1DkB,SAAU,SAAUC,GAClB,IAAIC,EAAYZ,EAAQa,OAAOC,UAAUC,MAAMpE,KAAMF,WAErD,OADAE,KAAKuD,OAASU,EACPjE,MAGTqE,gBAAiB,WACf,IAAIC,EAAe,EACnB,IAAK,IAAI/H,EAAI,EAAGA,EAAIyD,KAAKsD,SAASvD,OAAS,EAAGxD,IAC5C+H,GAAgBtE,KAAKsD,SAAS,GAAGM,IAAIzC,IAAInB,KAAKsD,SAAS/G,EAAI,GAAGqH,IAC3DpC,MAAMxB,KAAKsD,SAAS/G,EAAI,GAAGqH,MAGhC,OADAU,GAAgB,EACTA,GAITC,QAAS,WACP,IAAIC,EAAc,EAClB,IAAK,IAAIjI,EAAI,EAAGA,EAAIyD,KAAKsD,SAASvD,OAAS,EAAGxD,IAC5CiI,GAAexE,KAAKsD,SAAS/G,EAAI,GAAGqH,IAAI5C,MAAMhB,KAAKsD,SAAS,GAAGM,KAC5DpC,MAAMxB,KAAKsD,SAAS/G,EAAI,GAAGqH,IAAI5C,MAAMhB,KAAKsD,SAAS/G,EAAI,GAAGqH,MAAM7D,SAGrE,OADAyE,GAAe,EACRA,GAKTC,iBAAkB,SAAUC,GAC1B,IAAIhE,EAAS,GAQb,OAPAgE,EAASC,SAAQ,SAAUC,GACT,WAAZA,EACFlE,EAAOmE,KAAK7E,KAAKqE,mBACI,SAAZO,GACTlE,EAAOmE,KAAK7E,KAAKuE,aAElBvE,MACIU,GAKToE,QAAS,SAAUC,GACjB,MAAM,aAACC,GAAgB,EAAQ,GAE/B,IAAIC,EAAc,GAEdC,EAAWlF,KACCkF,EAAS1B,MAAMX,OAAO1B,IAAI4D,GAC1B,IACdG,EAAWA,EAASC,WAEtBF,EAAYJ,KAAKK,GACjB,IAAIE,EAAWF,EAASG,UAAUN,GAC9BO,EAActF,KAAKsD,SAASvD,OAC5BJ,EAAI,EACJC,EAAImF,EAAahF,SACrB,IAAK,IAAIxD,EAAI,EAAGA,EAAI+I,EAAa/I,IAAK,CACpC,IAAIgJ,EAAiB,GACjBC,EAASjJ,EAAK+I,EAAc,EAAM/I,EAAI,EAAI,EAC1CkJ,EAAK9F,EAAIuF,EAAS5B,SAAS/G,GAAGqH,IAAInC,WAAWyD,EAAS5B,SAASkC,GAAO5B,KAC1E2B,EAAeV,KAAK1B,EAAOuC,aAAaR,EAAS5B,SAAS/G,GAAGqH,IAAK,IAAInE,EAASE,EAAG,KAClF4F,EAAeV,KAAK1B,EAAOuC,aAAaN,EAAS9B,SAAS/G,GAAGqH,IAAK,IAAInE,EAASE,EAAGC,KAClF2F,EAAeV,KAAK1B,EAAOuC,aAAaN,EAAS9B,SAASkC,GAAO5B,IAAK,IAAInE,EAASgG,EAAI7F,KACvF2F,EAAeV,KAAK1B,EAAOuC,aAAaR,EAAS5B,SAASkC,GAAO5B,IAAK,IAAInE,EAASgG,EAAI,KACvF,IAAIE,EAAkB,IAAItC,EAAQkC,EAAgBvF,KAAKuD,QACvD0B,EAAYJ,KAAKc,GACjBhG,EAAI8F,EAIN,OAFAL,EAAWA,EAASD,UACpBF,EAAYJ,KAAKO,GACVJ,EAAaC,IAGtBI,UAAW,SAAUO,GACnB,OAAO5F,KAAK+B,UAAUqB,EAAUyC,YAAYD,KAI9CE,eAAgB,WACd,IAAK9F,KAAK+F,qBAAsB,CAC9B,IAAIC,EAAMhG,KAAKiG,cACXC,EAASF,EAAI,GAAGlF,KAAKkF,EAAI,IAAI/E,MAAM,IAEnCkF,EADUH,EAAI,GAAGhF,MAAMkF,GACNnG,SACrBC,KAAK+F,qBAAuB,CAACG,EAAQC,GAEvC,OAAOnG,KAAK+F,sBAIdE,YAAa,WACX,IAAKjG,KAAKoG,kBAAmB,CAC3B,IAAIC,EAAUC,EACVhD,EAAWtD,KAAKsD,SAChBgC,EAAchC,EAASvD,OAEzBsG,EADkB,IAAhBf,EACS,IAAI5F,EAAS,EAAG,EAAG,GAEnB4D,EAAS,GAAGM,IAEzB0C,EAAWD,EACX,IAAK,IAAI9J,EAAI,EAAGA,EAAI+I,EAAa/I,IAAK,CACpC,IAAIgK,EAAQjD,EAAS/G,GAAGqH,IACxByC,EAAWA,EAASlE,IAAIoE,GACxBD,EAAWA,EAASlE,IAAImE,GAE1BvG,KAAKoG,kBAAoB,CAACC,EAAUC,GAEtC,OAAOtG,KAAKoG,mBAGdjB,QAAS,WACP,IAAIqB,EAAcxG,KAAKsD,SAASmD,KAAI,SAAUlG,GAC5C,OAAOA,EAAE4E,aAEXqB,EAAYE,UACZ,IAAIC,EAAW3G,KAAKwD,MAAM2B,UAC1B,OAAO,IAAI9B,EAAQmD,EAAaxG,KAAKuD,OAAQoD,IAI/C5E,UAAW,SAAUF,GACnB,IAAI2E,EAAcxG,KAAKsD,SAASmD,KAAI,SAAUlG,GAC5C,OAAOA,EAAEwB,UAAUF,MAEjB8E,EAAW3G,KAAKwD,MAAMzB,UAAUF,GAMpC,OALIA,EAAU+E,eAGZJ,EAAYE,UAEP,IAAIrD,EAAQmD,EAAaxG,KAAKuD,OAAQoD,IAG/C3E,SAAU,WACR,IAAItB,EAAS,kBAAoBV,KAAKwD,MAAMxB,WAAa,KAIzD,OAHAhC,KAAKsD,SAASmD,KAAI,SAAUI,GAC1BnG,GAAU,KAAOmG,EAAO7E,WAAa,QAEhCtB,GAIToG,0BAA2B,SAAUC,GACnC,MAAMC,EAAM,EAAQ,IACd,kBAACC,GAAqB,EAAQ,GACpC,IAIIvG,EAASuG,EAJEjH,KAAKsD,SAASmD,KAAI,SAAUI,GACzC,OAAOE,EAAWG,KAAKL,EAAOjD,SAI5BuD,EAAOzG,EAAOyG,OAQlB,OAPI3I,KAAKqC,IAAIsG,GAAQ5I,EAGnBmC,EAAS,IAAIsG,EACJG,EAAO,IAChBzG,EAASA,EAAOyE,WAEXzE,GAIT0G,gBAAiB,SAAUC,GAEzB,OADwB,EAAQ,GACzBD,CAAgBpH,KAAMqH,KAMjChE,EAAQiE,WAAa,SAAUC,GAC7B,MAAM7D,EAAQ,EAAQ,GACtB,IAAIJ,EAAWiE,EAAIjE,SAASmD,KAAI,SAAUlG,GACxC,OAAO4C,EAAOmE,WAAW/G,MAEvBgD,EAASF,EAAQa,OAAOoD,WAAWC,EAAIhE,QACvCC,EAAQE,EAAM4D,WAAWC,EAAI/D,OACjC,OAAO,IAAIH,EAAQC,EAAUC,EAAQC,IAiBvCH,EAAQmE,iBAAmB,SAAUC,EAAQlE,EAAQC,GAInD,IAMIkE,EANApE,EAAW,GAYf,OAXAmE,EAAOhB,KAAI,SAAUpI,GACnB,IAAIsJ,EAAM,IAAIjI,EAASrB,GACnBwI,EAAS,IAAI1D,EAAOwE,GACxBrE,EAASuB,KAAKgC,MAIda,EADE5H,UAAUC,OAAS,EACX,IAAIsD,EAAQC,EAAUC,GAEtB,IAAIF,EAAQC,EAAUC,EAAQC,GAEnCkE,GAGTrE,EAAQS,eAAiB,SAAUR,EAAUsE,GAC3C,IAAItC,EAAchC,EAASvD,OAC3B,GAAIuF,EAAc,EAAG,CACnB,IAAIuC,EAAcvE,EAASgC,EAAc,GAAG1B,IACxCkE,EAAUxE,EAASgC,EAAc,GAAG1B,IACxC,IAAK,IAAIrH,EAAI,EAAGA,EAAI+I,EAAa/I,IAAK,CACpC,IAAIqH,EAAMN,EAAS/G,GAAGqH,IACtB,IAAKP,EAAQ0E,cAAcF,EAAaC,EAASlE,EAAKgE,GACpD,OAAO,EAETC,EAAcC,EACdA,EAAUlE,GAGd,OAAO,GAMTP,EAAQ0E,cAAgB,SAAUC,EAAWzB,EAAO0B,EAAWpF,GAG7D,OAFmB0D,EAAMvF,MAAMgH,GAAWxG,MAAMyG,EAAUjH,MAAMuF,IAC9BpF,IAAI0B,IACZ,GAG5BQ,EAAQ6E,sBAAwB,SAAUF,EAAWzB,EAAO0B,EAAWpF,GAGrE,OAFmB0D,EAAMvF,MAAMgH,GAAWxG,MAAMyG,EAAUjH,MAAMuF,IAC9BpF,IAAI0B,IACZ/D,GAW5BuE,EAAQa,OAAS,SAAUiE,GACzB,GAAIA,SACmB,IAAjBA,EAAMpI,OACR,MAAM,IAAIS,MAAM,6BAGpBR,KAAKmI,MAAQA,GAGf9E,EAAQa,OAAOoD,WAAa,SAAUC,GACpC,OAAO,IAAIlE,EAAQa,OAAOqD,EAAIY,QAchC9E,EAAQa,OAAOC,UAAY,SAAUH,GACnC,IAAImE,EACJ,GAAyB,IAArBrI,UAAUC,OACZoI,EAAQrI,UAAU,GAAGsI,YAChB,CACLD,EAAQ,GACR,IAAK,IAAI5L,EAAI,EAAGA,EAAIuD,UAAUC,OAAQxD,IACpC4L,EAAMtD,KAAK/E,UAAUvD,IAGzB,GAAqB,IAAjB4L,EAAMpI,OACRoI,EAAMtD,KAAK,QACN,GAAqB,IAAjBsD,EAAMpI,OACf,MAAM,IAAIS,MAAM,gFAElB,OAAO,IAAI6C,EAAQa,OAAOiE,IAG5B9E,EAAQa,OAAO/F,UAAY,CACzBoB,OAAQ,WACN,IAAImB,EAASV,KAAKqI,IAKlB,OAJK3H,IACHA,EAASnB,IACTS,KAAKqI,IAAM3H,GAENA,GAGT4H,QAAS,WACP,OAAKtI,KAAKmI,MACHnI,KAAKmI,MAAMI,KAAK,KADC,SAK5BlF,EAAQI,cAAgB,IAAIJ,EAAQa,OAAO,MAE3ClI,EAAOD,QAAUsH,G,cC9RjBrH,EAAOD,QAAU,CACfyM,aA7FF,SAAsBzH,EAAG0H,GACvB,OAAO1H,EAAI0H,GA6FXC,cA1FF,SAAuB3H,EAAG0H,GACxB,OAAO1H,EAAE4H,MAAQF,EAAEE,OA0FnBnJ,QAvFc,SAAUxB,GACxB,OAAS4K,MAAM5K,IAAQA,IAAM6K,KAAc7K,KAAO6K,KAuFlDC,aApFmB,SAAU/H,EAAG0H,EAAG7L,EAAGC,EAAGkM,EAAGxI,GAC5C,IACIyI,EAAS,GADHjI,EAAIlE,EAAI4L,EAAI7L,GAElB+C,EAAIoJ,EAAIlM,EAAI4L,EAAIlI,EAChBX,GAAKmJ,EAAInM,EAAImE,EAAIR,EAGrB,OAFAZ,GAAKqJ,EACLpJ,GAAKoJ,EACE,CAACrJ,EAAGC,IA8EXqJ,aA3EF,SAAsBC,EAAOC,EAASC,GACpC,IAAIC,EAAY,EACZC,EAAaJ,EAAMnJ,OACvB,KAAOuJ,EAAaD,GAAW,CAC7B,IAAIE,EAAY/K,KAAKgL,OAAOH,EAAYC,GAAc,GAElCF,EAAYD,EADdD,EAAMK,IAEJ,EAElBF,EAAYE,EAAY,EAExBD,EAAaC,EAGjBL,EAAMO,OAAOJ,EAAW,EAAGF,IA8D3BO,+BAxDqC,SAAUC,EAAQC,EAAQhK,GAC/D,IAMInC,EANAoM,EAAKjK,EAAI+J,EAAO/J,EAChBkK,EAAKF,EAAOhK,EAAI+J,EAAO/J,EAgB3B,OAfIkK,EAAK,IACPD,GAAMA,EACNC,GAAMA,GAINrM,EADEoM,GAAM,EACJ,EACKA,GAAMC,EACX,EACKA,EAAK,MACV,GAEAD,EAAKC,EAEEH,EAAOhK,EAAIlC,GAAKmM,EAAOjK,EAAIgK,EAAOhK,IAwC/CoK,MApCF,SAAe9L,GAKb,MAAM,UAAWA,GAGX,WAAYA,EAAO+L,OA6BzBC,MAtBF,SAAehM,GAKb,MAAM,aAAcA,GAGd,WAAYA,EAAOiM,Y,gBCtF3B,MAAMxK,EAAW,EAAQ,GACnByK,EAAS,EAAQ,KACjB,IAACrL,EAAG,OAAES,GAAU,EAAQ,GAIxBmE,EAAQ,SAAUb,EAAQuH,GAC9BpK,KAAK6C,OAASA,EACd7C,KAAKoK,EAAIA,GAIX1G,EAAM4D,WAAa,SAAUC,GAC3B,IAAI1E,EAAS,IAAInD,EAAS6H,EAAI1E,QAC1BuH,EAAIlK,WAAWqH,EAAI6C,GACvB,OAAO,IAAI1G,EAAMb,EAAQuH,IAG3B1G,EAAMC,cAAgB,SAAU5C,EAAG0H,EAAG7L,GACpC,IAAIoB,EAAIyK,EAAEzH,MAAMD,GAAGS,MAAM5E,EAAEoE,MAAMD,IAAIQ,OACrC,OAAO,IAAImC,EAAM1F,EAAGA,EAAEmD,IAAIJ,KAK5B2C,EAAM2G,sBAAwB,SAAUtJ,EAAG0H,EAAG7L,GAC5C,IAAI0N,EAAK7B,EAAEzH,MAAMD,GACbwJ,EAAK3N,EAAEoE,MAAMD,GACbuJ,EAAGvK,SAAWjB,IAChBwL,EAAKC,EAAGrI,2BAENqI,EAAGxK,SAAWjB,IAChByL,EAAKD,EAAGpI,2BAEV,IAAIW,EAASyH,EAAG9I,MAAM+I,GAOtB,OANI1H,EAAO9C,SAAWjB,IAEpByL,EAAKD,EAAGpI,0BACRW,EAASyH,EAAG9I,MAAM+I,IAEpB1H,EAASA,EAAOtB,OACT,IAAImC,EAAMb,EAAQA,EAAO1B,IAAIJ,KAGtC2C,EAAM8G,WAAa,SAAUzJ,EAAG0H,EAAG7L,GAIjC,OAHAmE,EAAI,IAAIrB,EAASqB,GACjB0H,EAAI,IAAI/I,EAAS+I,GACjB7L,EAAI,IAAI8C,EAAS9C,GACV8G,EAAMC,cAAc5C,EAAG0H,EAAG7L,IAGnC8G,EAAM+G,mBAAqB,SAAU5H,EAAQ0D,GAC3C1D,EAAS,IAAInD,EAASmD,GACtB0D,EAAQ,IAAI7G,EAAS6G,GACrB1D,EAASA,EAAOtB,OAChB,IAAI6I,EAAI7D,EAAMpF,IAAI0B,GAClB,OAAO,IAAIa,EAAMb,EAAQuH,IAG3B1G,EAAMvF,UAAY,CAChBgH,QAAS,WACP,OAAO,IAAIzB,EAAM1D,KAAK6C,OAAOjC,WAAYZ,KAAKoK,IAGhD7K,OAAQ,WACN,IAAImB,EAASV,KAAKqI,IAKlB,OAJK3H,IACHA,EAASnB,IACTS,KAAKqI,IAAM3H,GAENA,GAGTiB,OAAQ,SAAU3D,GAChB,OAAOgC,KAAK6C,OAAOlB,OAAO3D,EAAE6E,SAAW7C,KAAKoK,IAAMpM,EAAEoM,GAGtDrI,UAAW,SAAUF,GACnB,IAAI6I,EAAW7I,EAAU+E,cAErBvJ,EAAI2C,KAAK6C,OAAOX,0BAChB6G,EAAI/I,KAAK6C,OAAOrB,MAAMnE,GACtBkD,EAAIP,KAAK6C,OAAOrB,MAAMuH,GAEtBY,EAAS3J,KAAK6C,OAAO5B,MAAMjB,KAAKoK,GAChCR,EAASD,EAAO7I,KAAKiI,GACrB4B,EAAShB,EAAO7I,KAAKP,GAEzBoJ,EAASA,EAAO/H,YAAYC,GAC5B+H,EAASA,EAAOhI,YAAYC,GAC5B8I,EAASA,EAAO/I,YAAYC,GAE5B,IAAI8E,EAAWjD,EAAMC,cAAcgG,EAAQC,EAAQe,GAMnD,OALID,IAGF/D,EAAWA,EAASxB,WAEfwB,GAKTiE,uBAAwB,SAAUC,EAAIC,GACpC,IAAIC,EAAYD,EAAG9J,MAAM6J,GACrBG,GAAShL,KAAKoK,EAAIpK,KAAK6C,OAAO1B,IAAI0J,IAAO7K,KAAK6C,OAAO1B,IAAI4J,GAK7D,OAJInC,MAAMoC,KAAQA,EAAQ,GACtBA,EAAQ,IAAGA,EAAQ,GACnBA,EAAQ,IAAGA,EAAQ,GACVH,EAAG/J,KAAKiK,EAAU9J,MAAM+J,KAKvCC,kBAAmB,SAAUC,GAC3B,OAAOA,EAAOC,mBAAmBnL,OAInCmL,mBAAoB,SAAU3H,GAC5B,OAAO2G,EAAOiB,WAAWpL,KAAMwD,IAGjC6H,sBAAuB,SAAU9E,GAE/B,OADQvG,KAAK6C,OAAO1B,IAAIoF,GAASvG,KAAKoK,GAIxCpI,SAAU,WACR,MAAO,YAAchC,KAAK6C,OAAOb,WAAa,QAAUhC,KAAKoK,EAAI,KAGnEkB,YAAa,SAAUC,GACrB,IAAIC,EAAWxL,KAAKqL,sBAAsBE,GAE1C,OADeA,EAAQvK,MAAMhB,KAAK6C,OAAO5B,MAAiB,EAAXuK,MAKnDxP,EAAOD,QAAU2H,G,gBC3IjB,MAAMhE,EAAW,EAAQ,GACnBD,EAAW,EAAQ,IACnB,OAACF,GAAU,EAAQ,GASnB4D,EAAS,SAAUS,GACvB5D,KAAK4D,IAAMA,EACX5D,KAAKyL,GAAK,IAAIhM,EAAS,EAAG,IAI5B0D,EAAOmE,WAAa,SAAUC,GAC5B,IAAI3D,EAAM,IAAIlE,EAAS6H,EAAI3D,KAC3B,OAAO,IAAIT,EAAOS,IAIpBT,EAAOuC,aAAe,SAAU9B,EAAK6H,GACnC,IAAIC,EAAY,IAAIvI,EAAOS,GAE3B,OADA8H,EAAUD,GAAKA,EACRC,GAGTvI,EAAOhF,UAAY,CAGjBgH,QAAS,WACP,OAAOnF,MAGTT,OAAQ,WACN,IAAImB,EAASV,KAAKqI,IAKlB,OAJK3H,IACHA,EAASnB,IACTS,KAAKqI,IAAM3H,GAENA,GAMTiL,YAAa,SAAUC,EAAOnO,GAC5B,IAAIoO,EAAS7L,KAAK4D,IAAIxC,KAAKwK,EAAMhI,IAAKnG,GAClCqO,EAAQ9L,KAAKyL,GAAGrK,KAAKwK,EAAMH,GAAIhO,GACnC,OAAO0F,EAAOuC,aAAamG,EAAQC,IAIrC/J,UAAW,SAAUF,GACnB,IAAIgK,EAAS7L,KAAK4D,IAAIhC,YAAYC,GAClC,OAAOsB,EAAOuC,aAAamG,EAAQ7L,KAAKyL,KAG1CzJ,SAAU,WACR,OAAOhC,KAAK4D,IAAI5B,aAIpBhG,EAAOD,QAAUoH,G,gBCjEjB,MAAMzD,EAAW,EAAQ,GACnByD,EAAS,EAAQ,GACjBO,EAAQ,EAAQ,GAChBqI,EAAY,EAAQ,IACpBC,EAAY,EAAQ,GAMpBhH,EAAe,SAAUkF,GAE7B,IAAI+B,EAAM,IADE,EAAQ,KAKpB,OAHAA,EAAI/B,SAAWA,EACf+B,EAAIC,iBAAkB,EACtBD,EAAIE,gBAAiB,EACdF,GAmGTjQ,EAAOD,QAAU,CACfiJ,eACAoH,WA7FF,SAAoB/E,GAClB,OAAO0E,EAAUvE,iBAAiB,CAChC,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,KACNJ,gBAAgBC,IAwFnBC,WAjFF,SAAoBC,GAClB,IAAI2C,EAAW3C,EAAI2C,SAASzD,KAAI,SAAUpI,GACxC,OAAO2N,EAAU1E,WAAWjJ,MAE1B4N,EAAMjH,EAAakF,GAGvB,OAFA+B,EAAIC,gBAAkB3E,EAAI2E,gBAC1BD,EAAIE,eAAiB5E,EAAI4E,eAClBF,GA2EPI,kBApEF,SAA2BC,GACzB,GAAqB,QAAjBA,EAAW,MAAa,MAAM,IAAI9L,MAAM,aAC5C,IAIIb,EAAGC,EAAGC,EAAGuK,EAAGvH,EAAQW,EAJpB+I,EAAS,GACTC,EAAYF,EAAIE,UAChBC,EAAYD,EAAUzM,OAAS,EAC/B2M,EAAa,EAEjB,IAAK,IAAIC,EAAa,EAAGA,EAAaF,EAAWE,IAC/ChN,EAAI6M,EAAUE,KACd9M,EAAI4M,EAAUE,KACd7M,EAAI2M,EAAUE,KACdtC,EAAIoC,EAAUE,KACd7J,EAASnD,EAASe,OAAOd,EAAGC,EAAGC,GAC/B2D,EAAQ,IAAIE,EAAMb,EAAQuH,GAC1BmC,EAAO1H,KAAKrB,GAGd,IAAIF,EAAW,GACf,MAAMsJ,EAAaN,EAAIM,WACjBtH,EAAcsH,EAAW7M,OAAS,EACxC,IAAI6D,EACAiD,EACJ6F,EAAa,EACb,IAAK,IAAIG,EAAc,EAAGA,EAAcvH,EAAauH,IACnDlN,EAAIiN,EAAWF,KACf9M,EAAIgN,EAAWF,KACf7M,EAAI+M,EAAWF,KACf9I,EAAMlE,EAASe,OAAOd,EAAGC,EAAGC,GAC5BgH,EAAS,IAAI1D,EAAOS,GACpBN,EAASuB,KAAKgC,GAGhB,IAUIiG,EACAC,EACAxJ,EACAmE,EAbAsF,EAAUV,EAAI/I,OAAOkD,KAAI,SAAUlD,GACrC,OAAOyI,EAAU9H,OAAOoD,WAAW/D,MAGjC2G,EAAW,GACX+C,EAAcX,EAAIY,YAClBC,EAAwBb,EAAIa,sBAC5BC,EAAkBd,EAAIc,gBACtBC,EAAsBf,EAAIe,oBAC1BC,EAAuBhB,EAAIgB,qBAK/BZ,EAAa,EACb,IAAK,IAAIa,EAAe,EAAGA,EAAeN,EAAaM,IAAgB,CACrET,EAAqBK,EAAsBI,GAC3CR,EAAkB,GAClB,IAAK,IAAIxQ,EAAI,EAAGA,EAAIuQ,EAAoBvQ,IACtCwQ,EAAgBlI,KAAKvB,EAAS8J,EAAgBV,OAEhDlJ,EAAQ+I,EAAOc,EAAoBE,IACnChK,EAASyJ,EAAQM,EAAqBC,IACtC7F,EAAU,IAAIsE,EAAUe,EAAiBxJ,EAAQC,GACjD0G,EAASrF,KAAK6C,GAEhB,IAAIuE,EAAMjH,EAAakF,GAGvB,OAFA+B,EAAIC,iBAAkB,EACtBD,EAAIE,gBAAiB,EACdF,K,gBChHT,MAAMuB,EAAO,EAAQ,IACf/N,EAAW,EAAQ,GACnBgO,EAAU,EAAQ,KAClB,QAAClP,GAAW,EAAQ,IACpB,mBAACmP,EAAkB,SAAEC,GAAY,EAAQ,KACzC,MAACC,EAAK,WAAEC,GAAc,EAAQ,IAM9BC,EAAY,SAAU9D,GAE1B,IAAI+D,EAAM,IADE,EAAQ,IAGpB,OADAA,EAAI/D,MAAQA,EACL+D,GAwBHvD,EAAa,SAAU/C,GAC3B,IAAKA,EACH,MAAM,IAAIjH,MAAM,oCAElB,IAAKF,MAAM0N,QAAQvG,GACjB,MAAM,IAAIjH,MAAM,qCAElB,QAAoByN,IAAhBxG,EAAO,GAAG9H,GAA2C,iBAAjB8H,EAAO,GAAG,GAChD,OAAOyG,EAAgBzG,GAEzB,GAA4B,iBAAjBA,EAAO,GAAG,GACnB,OAAO0G,EAAsB1G,GAE/B,MAAM,IAAIjH,MAAM,mCAIZ0N,EAAkB,SAAUzG,GAChC,GAAIA,EAAO1H,OAAS,EAClB,MAAM,IAAIS,MAAM,qCAElB,IAAIwJ,EAAQ,GACRoE,EAAa,IAAIX,EAAQ,IAAIhO,EAASgI,EAAOA,EAAO1H,OAAS,KACjE0H,EAAOhB,KAAI,SAAUF,GACnB,IAAIM,EAAS,IAAI4G,EAAQ,IAAIhO,EAAS8G,IACtCyD,EAAMnF,KAAK,IAAI2I,EAAKY,EAAYvH,IAChCuH,EAAavH,KAEf,IAAInG,EAASoN,EAAU9D,GACvB,GAAI0D,EAAmBhN,GACrB,MAAM,IAAIF,MAAM,iCAElB,IAAI2G,EAAOzG,EAAOyG,OAClB,GAAI3I,KAAKqC,IAAIsG,GAAQ5I,EACnB,MAAM,IAAIiC,MAAM,uBAKlB,OAHI2G,EAAO,IACTzG,EAASA,EAAOyE,WAEXzE,EAAO2N,iBAGVF,EAAwB,SAAU1G,GACtC,GAAsB,IAAlBA,EAAO1H,OACT,OAAOyK,EAAW/C,EAAO,IAG3B,IAAI6G,EAAQ,GACZ7G,EAAO9C,QAAQ4J,IACbD,EAAMzJ,KAAKqJ,EAAgBK,MAG7B,IAAIC,EAAO,GAEXF,EAAM3J,QAAQ,CAACkG,EAAItO,KAEjB+R,EAAM3J,QAAQ,CAACmG,EAAIlL,KACbiL,IAAOC,IAET0D,EAAKjS,KAAOiS,EAAKjS,GAAK,CAACkS,QAAS,GAAIC,QAAQ,IAC5CF,EAAK5O,KAAO4O,EAAK5O,GAAK,CAAC6O,QAAS,GAAIC,QAAQ,IAExCf,EAAS7C,EAAID,KAEf2D,EAAKjS,GAAGkS,QAAQ5J,KAAKjF,GACrB4O,EAAKjS,GAAGmS,UAAYF,EAAKjS,GAAGkS,QAAQ1O,OAAS,GAC7CyO,EAAK5O,GAAG8O,UAAYF,EAAK5O,GAAG6O,QAAQ1O,OAAS,SAMrD,IAAIwO,EAAO,KACX,IAAKzQ,OAAO0Q,EACVD,EAAOC,EAAK1Q,KACRyQ,EAAKG,gBACAF,EAAK1Q,KACZyQ,EAAKE,QAAQ9J,QAAQgK,IACnBL,EAAMK,GAAad,EAAWS,EAAMK,GAAYL,EAAMxQ,SAK5D,IAAIiQ,EAAMD,EAAU,IACpB,IAAKhQ,OAAO0Q,EACVT,EAAMH,EAAMG,EAAKO,EAAMxQ,MAEzB,OAAOiQ,GA+ET/R,EAAOD,QAAU,CACf+R,YACAxG,WA1EiB,SAAUC,GAC3B,IAAIyC,EAAQzC,EAAIyC,MAAMvD,KAAI,SAAUnI,GAClC,OAAOkP,EAAKlG,WAAWhJ,MAErByP,EAAMD,EAAU9D,GAEpB,OADA+D,EAAI7B,gBAAkB3E,EAAI2E,gBACnB6B,GAqEPvD,aACAvD,kBA3DwB,SAAUQ,GAClC,IAAIuC,EAAQ,GACRhC,EAAY,IAAIvI,EAASgI,EAAOA,EAAO1H,OAAS,IAChDqO,EAAa,IAAIX,EAAQzF,GAQ7B,OAPAP,EAAOhB,KAAI,SAAUpI,GACnB,IAAIkI,EAAQ,IAAI9G,EAASpB,GACrBwI,EAAS,IAAI4G,EAAQlH,GACrBqI,EAAO,IAAIpB,EAAKY,EAAYvH,GAChCmD,EAAMnF,KAAK+J,GACXR,EAAavH,KAERiH,EAAU9D,IAiDjB6E,UAzCgB,SAAUN,GAC1B,IAAKA,EAAKO,WAAY,MAAM,IAAItO,MAAM,8BACtC,OAAOgK,EAAW+D,EAAKQ,cAwCvBC,YA/LkB,SAAU/C,GAC5B,IAAIjC,EAAQiC,EAAI/B,SAASzD,KAAI,SAAUpI,GACrC,OAAOmP,EAAKyB,iBAAiB5Q,MAE5B6Q,QAAO,SAAU5Q,GAChB,OAAa,OAANA,KAEX,OAAOwP,EAAU9D,IAyLjBqC,kBAlCwB,SAAUC,GAClC,GAAqB,QAAjBA,EAAW,MAAa,MAAM,IAAI9L,MAAM,aAC5C,IAAI8C,EAAW,GACXsJ,EAAaN,EAAIM,WACjBtH,EAAcsH,EAAW7M,OAAS,EAClC2M,EAAa,EACjB,IAAK,IAAIG,EAAc,EAAGA,EAAcvH,EAAauH,IAAe,CAClE,IAAIlN,EAAIiN,EAAWF,KACf9M,EAAIgN,EAAWF,KACf9I,EAAM,IAAInE,EAASE,EAAGC,GACtBiH,EAAS,IAAI4G,EAAQ7J,GACzBN,EAASuB,KAAKgC,GAEhB,IAAImD,EAAQ,GACRmF,EAAW7C,EAAI8C,kBAAkBrP,OAAS,EAC9C2M,EAAa,EACb,IAAK,IAAI2C,EAAY,EAAGA,EAAYF,EAAUE,IAAa,CACzD,IAAIC,EAAehD,EAAI8C,kBAAkB1C,KACrC6C,EAAejD,EAAI8C,kBAAkB1C,KACrCkC,EAAO,IAAIpB,EAAKlK,EAASgM,GAAehM,EAASiM,IACrDvF,EAAMnF,KAAK+J,GAEb,IAAIb,EAAMD,EAAU9D,GAEpB,OADA+D,EAAI7B,iBAAkB,EACf6B,K,gBC1MT,MAAM,UAACyB,GAAa,EAAQ,IACtBC,EAAW,EAAQ,GACnBhQ,EAAW,EAAQ,GACnBC,EAAW,EAAQ,GACnB2D,EAAU,EAAQ,IAElB,aAAC2B,GAAgB,EAAQ,IACzB,UAAC8I,EAAS,YAAEkB,GAAe,EAAQ,GAEnCU,EAAe,EAAQ,IACvBC,EAAc,EAAQ,KACtB,WAACC,EAAU,mBAAElC,EAAkB,eAAEmC,GAAkB,EAAQ,KAC3D,KAAC1I,EAAI,UAAE2I,GAAa,EAAQ,KAG5B,qBAACC,GAAwB,EAAQ,KACjC,0BAACC,EAAyB,eAAEC,EAAc,QAAEnL,EAAO,cAAEoL,GAAiB,EAAQ,IAC9EC,EAAkB,EAAQ,IAC1BC,EAAS,EAAQ,KACjB,OAACC,EAAM,SAAEC,EAAQ,mBAAEC,GAAsB,EAAQ,IAQvD,IAAIvJ,EAAM,WACRhH,KAAKgK,MAAQ,GACbhK,KAAKkM,iBAAkB,GAGzBlF,EAAI7I,UAAY,CACdyP,MAAO,SAAUG,GACf,IAAIyC,EAEFA,EADEzC,aAAezN,MACVyN,EAEA,CAACA,GAEV,IAAI1Q,EAAI2C,KAAKyQ,YAAY,EAAG,GAK5B,OAJApT,EAAIA,EAAEuQ,MACJ4C,EAAK/J,KAAI,SAAUsH,GACjB,OAAOA,EAAI0C,YAAY,EAAG,GAAGC,mBAC3B,GAAO,GACN1B,EAAY3R,GAAGgR,iBAGxBsC,SAAU,SAAU5C,GAClB,IAAIyC,EAEFA,EADEzC,aAAezN,MACVyN,EAEA,CAACA,GAEV,IAAI1Q,EAAI2C,KAAKyQ,YAAY,EAAG,GAQ5B,OAPAD,EAAK/J,KAAI,SAAUsH,GACjB1Q,EAAIA,EAAEuT,YAAY7C,EAAI0C,YAAY,EAAG,IAAI,GAAO,MAElDpT,EAAIA,EAAEqT,eACNrT,EAAIA,EAAEgR,gBACNhR,EAAI2R,EAAY3R,GAChBA,EAAIA,EAAEgR,gBACChR,GAGTwT,UAAW,SAAU9C,GACnB,IAAIyC,EAEFA,EADEzC,aAAezN,MACVyN,EAEA,CAACA,GAEV,IAAI1Q,EAAI2C,KAAKyQ,YAAY,EAAG,GAQ5B,OAPAD,EAAK/J,KAAI,SAAUsH,GACjB1Q,EAAIA,EAAEyT,aAAa/C,EAAI0C,YAAY,EAAG,IAAI,GAAO,MAEnDpT,EAAIA,EAAEqT,eACNrT,EAAIA,EAAEgR,gBACNhR,EAAI2R,EAAY3R,GAChBA,EAAIA,EAAEgR,gBACChR,GAGT0E,UAAW,SAAUF,GACnB,IAAI6I,EAAW7I,EAAU+E,cACrBmK,EAAW/Q,KAAKgK,MAAMvD,KAAI,SAAUmI,GACtC,OAAOA,EAAK7M,UAAUF,MAEpBnB,EAASoN,EAAUiD,GAIvB,OAHIrG,IACFhK,EAASA,EAAOyE,WAEXzE,GAGTyE,QAAS,WACP,IAAI4L,EAAW/Q,KAAKgK,MAAMvD,KAAI,SAAUmI,GACtC,OAAOA,EAAKzJ,aAGd,OADA4L,EAASrK,UACFoH,EAAUiD,IAInBX,OAAQ,SAAUY,GAChB,OAAOZ,EAAO,CAACY,KAAMA,GAAO,CAAChR,QAI/BiR,cAAe,SAAU9K,EAAQ+K,GAC/B,OAAOX,EAAmBvQ,KAAMmG,EAAQ+K,IAI1Cb,OAAQ,SAAUlK,EAAQ+K,GACxB,OAAOb,EAAOrQ,KAAMmG,EAAQ+K,IAG9BZ,SAAU,SAAUnK,EAAQ+K,GAC1B,OAAOZ,EAAStQ,KAAMmG,EAAQ+K,IAIhC/J,KAAM,WACJ,OAAOA,EAAKnH,OAId8P,UAAW,WACT,OAAOA,EAAU9P,OAGnB0N,mBAAoB,SAAUyD,GAC5B,OAAOzD,EAAmB1N,KAAMmR,IAGlCnB,0BAA2B,SAAUoB,EAAkBC,EAAOhK,GAC5D,OAAO2I,EAA0BhQ,KAAMoR,EAAkBC,EAAOhK,IAIlE4I,eAAgB,SAAUqB,EAAOC,EAAOF,EAAOhK,GAC7C,OAAO4I,EAAejQ,KAAMsR,EAAOC,EAAOF,EAAOhK,IAInDvC,QAAS,SAAUuC,GACjB,OAAOvC,EAAQ9E,KAAMqH,IAIvB6I,cAAe,SAAU7I,GACvB,OAAO6I,EAAclQ,KAAMqH,IAI7BmK,MAAO,WACL,OAAO5B,EAAW5P,OAIpBqO,cAAe,WACb,OAAOqB,EAAa1P,OAItB0Q,aAAc,WACZ,OAAOf,EAAY3P,OAIrByR,gBAAiB,WACf,OAAOtB,EAAgBnQ,OAIzB+P,qBAAsB,SAAU2B,GAC9B,OAAO3B,EAAqB/P,KAAM0R,IAIpC7B,eAAgB,SAAUtJ,GACxB,OAAOsJ,EAAe7P,KAAMuG,IAI9BvE,SAAU,WACR,IAAItB,EAAS,QAAUV,KAAKgK,MAAMjK,OAAS,aAI3C,OAHAC,KAAKgK,MAAMvD,KAAI,SAAUmI,GACvBlO,GAAU,KAAOkO,EAAK5M,WAAa,QAE9BtB,GAGT+P,WAAY,SAAUkB,EAAIC,GACxB,IAAI1H,EAAWlK,KAAKgK,MAAMvD,KAAI,SAAUmI,GACtC,OAAOA,EAAKiD,YAAYF,EAAIC,MAE9B,OAAO5M,EAAakF,IAGtB4H,iBAAkB,SAAUnV,GAE1B,IAAIoV,EAAQ/R,KAAKgK,MAAMvD,KAAI,SAAUmI,GACnC,IAAIoD,EAAKpD,EAAKqD,QAAQrO,IAClBiH,EAAK+D,EAAKsD,QAAQtO,IACtB,MAAO,CAAClE,EAASe,OAAOuR,EAAGrS,EAAGqS,EAAGpS,EAAG,GAClCF,EAASe,OAAOoK,EAAGlL,EAAGkL,EAAGjL,EAAG,OAShC,YAPiB,IAANjD,IACToV,EAAQA,EAAMtL,KAAI,SAAU0L,GAC1B,OAAOA,EAAK1L,KAAI,SAAUlG,GACxB,OAAOA,EAAEwB,UAAUpF,UAIlBoV,GASTK,iBAAkB,SAAU/K,GAI1BA,EAAUpK,OAAOoV,OAAO,GAHP,CACflN,SAAS,GAE2BkC,GACtC,IAAI,QAAClC,GAAWkC,EAEZiL,EAAS,CAAC,EAAG,EAAG,GAChBC,EAAc,CAAC,EAAG,EAAG,GACrBC,EAAgB,CAAC,EAAG,EAAG,GACvBC,EAAgB,IAAIjD,EAAU8C,EAAQC,EAAaC,GAEnD3M,EAAcwB,EAAQxB,aAAeyM,EACrCI,EAAarL,EAAQqL,YAAcH,EACnCI,EAAetL,EAAQsL,cAAgBH,EAEvCI,EAAcvL,EAAQuL,aACxB,IAAIpD,EAAU3J,EAAa6M,EAAYC,GAErChW,EAAI8V,EAAcI,oBAAoBD,GAAa,EAAO,GAE1DE,EAAS9S,KAAK8P,YAClBgD,EAAO,GAAKA,EAAO,GAAG9R,MAAM,IAAIvB,EAAS,EAAG,IAC5CqT,EAAO,GAAKA,EAAO,GAAGhS,KAAK,IAAIrB,EAAS,EAAG,IAC3C,IAAIsT,EAAW/S,KAAKyQ,YAAY,EAAG,GAC/BuC,EAAWhO,EAAa,CAAC,IAAI3B,EAAQ,CACvC,IAAIoM,EAAS,IAAI/P,EAASoT,EAAO,GAAGnT,EAAGmT,EAAO,GAAGlT,EAAG,IACpD,IAAI6P,EAAS,IAAI/P,EAASoT,EAAO,GAAGnT,EAAGmT,EAAO,GAAGlT,EAAG,IACpD,IAAI6P,EAAS,IAAI/P,EAASoT,EAAO,GAAGnT,EAAGmT,EAAO,GAAGlT,EAAG,IACpD,IAAI6P,EAAS,IAAI/P,EAASoT,EAAO,GAAGnT,EAAGmT,EAAO,GAAGlT,EAAG,QAElDuF,IACF6N,EAAWA,EAASC,UAGtBD,EAAWA,EAASlC,aAAaiC,GAEjC,IAAIG,EAAQF,EAAS9I,SAASgF,QAAO,SAAUxH,GAC7C,OAAOlJ,KAAKqC,IAAI6G,EAAQlE,MAAMX,OAAOhD,GAAK,OAW5C,OAPAqT,EAAMvO,SAAQ,SAAUwO,GACtBA,EAAK7P,SAASqB,SAAQ,SAAUkC,GAC9BA,EAAO4E,GAAK,IAAIhM,EAASoH,EAAOjD,IAAIjE,EAAGkH,EAAOjD,IAAIhE,SAK/CsT,EAAMzM,KAAI,SAAU0M,GACzB,OAAOA,EAAKpR,UAAUpF,OAS1ByW,gBAAiB,SAAU/L,EAASgM,EAAY,GAM9C,IAGIZ,EAAgB,IAAIjD,EAHX,CAAC,EAAG,EAAG,GACF,CAAC,EAAG,EAAG,GACL,CAAC,EAAG,EAAG,IAGvB8D,EAAejM,EAAQiM,aAEvBC,EAAelM,EAAQkM,aAC3B,KAAMD,aAAwB9D,GAAa+D,aAAwB/D,GACjE,MAAM,IAAIhP,MAAM,oEAElB,GAAI6G,EAAQ0G,KACN1G,EAAQ0G,IAAI/D,MAAMjK,SAAWC,KAAKgK,MAAMjK,OAC1C,MAAM,IAAIS,MAAM,kDAIpB,IAAIgT,EAAQnM,EAAQ0G,KAAO/N,KACvByT,EAAKhB,EAAcI,oBAAoBS,EAAcA,EAAaI,WAAW7T,EAAI,EAAG,GACpF8T,EAAKlB,EAAcI,oBAAoBU,EAAcA,EAAaG,WAAW7T,EAAI,EAAG,GACpF+T,EAAO5T,KAAK8R,iBAAiB2B,GAC7BI,EAAOL,EAAM1B,iBAAiB6B,GAC9BG,EAAqBR,EAAaI,WAAW7T,EAAI,EAGjDkU,EAAW,GACXC,EAAW,GACXC,EAAW,CAACL,EAAK,IACjBM,EAAW,CAACL,EAAK,IACjBtX,EAAI,EACR,IAAKA,EAAI,EAAGA,EAAIqX,EAAK7T,SAAUxD,EACvBqX,EAAKrX,GAAG,GAAGoF,OAAOiS,EAAKrX,EAAI,GAAG,KAAOqX,EAAKrX,GAAG,GAAGoF,OAAOiS,EAAKrX,EAAI,GAAG,MACvEwX,EAASlP,KAAKoP,GACdA,EAAW,GACXD,EAASnP,KAAKqP,GACdA,EAAW,IAEbD,EAASpP,KAAK+O,EAAKrX,IACnB2X,EAASrP,KAAKgP,EAAKtX,IAErBwX,EAASlP,KAAKoP,GACdD,EAASnP,KAAKqP,GAGd,IAAIhK,EAAW,GA4Bf,OA3BA6J,EAASpP,SAAQ,SAAUiP,EAAMrX,GAC/B,IAAI4X,EAAQ,EACRC,EAAQ,EACZP,EAAOG,EAASzX,GAChBqX,EAAKjP,SAAQ,SAAU0P,EAAKC,GAC1B,IAAIC,EAAQJ,EAAQE,EAAI,GAAG5S,WAAW4S,EAAI,IACtCG,EAAQJ,EAAQP,EAAKS,GAAG,GAAG7S,WAAWoS,EAAKS,GAAG,IAC9CG,EAAKJ,EAAI,GAAG5S,WAAWoS,EAAKS,GAAG,IAC/BI,EAAKL,EAAI,GAAG5S,WAAWoS,EAAKS,GAAG,IAC/BpP,EAAW,IAAI7B,EACjB,CAACoM,EAAS/J,aAAamO,EAAKS,GAAG,GAAI,IAAI7U,EAAS+U,EAAOE,GAAM,EAAIrB,KAC/D5D,EAAS/J,aAAamO,EAAKS,GAAG,GAAI,IAAI7U,EAAS2U,EAAOK,GAAM,EAAIpB,KAChE5D,EAAS/J,aAAa2O,EAAI,GAAI,IAAI5U,EAAS0U,EAAOM,EAAKpB,MACvDjO,EAAW,IAAI/B,EACjB,CAACoM,EAAS/J,aAAamO,EAAKS,GAAG,GAAI,IAAI7U,EAAS+U,EAAOE,GAAM,EAAIrB,KAC/D5D,EAAS/J,aAAa2O,EAAI,GAAI,IAAI5U,EAAS0U,EAAOM,EAAKpB,IACvD5D,EAAS/J,aAAa2O,EAAI,GAAI,IAAI5U,EAAS8U,EAAOG,EAAKrB,MACvDS,IACF5O,EAAS1B,MAAQ0B,EAAS1B,MAAM2B,UAChCC,EAAS5B,MAAQ4B,EAAS5B,MAAM2B,WAElC+E,EAASrF,KAAKK,GACdgF,EAASrF,KAAKO,GACd+O,EAAQI,EACRH,EAAQI,QAGLtK,GAOTyK,SAAU,WACR,IAAIlN,EAASzH,KAAKgK,MAAMvD,KAAI,SAAUmI,GAGpC,OAFSA,EAAKqD,QAEJrO,OAOZ,OAHI6D,EAAO1H,OAAS,GAClB0H,EAAO5C,KAAK4C,EAAOmN,SAEdnN,GAOToN,gBAAiB,WACf,IAAI9G,EAAM/N,KAAKqO,gBACXc,EAAWpB,EAAI/D,MAAMjK,OACrB+U,EAAY,GACZxR,EAAW,GACXgC,EAAc,EACd8J,EAAoB,IAAI2F,YAAY,EAAI5F,GACxC6F,EAAyB,EAC7BjH,EAAI/D,MAAMvD,KAAI,SAAUmI,GACtB,CAACA,EAAKqD,QAASrD,EAAKsD,SAASzL,KAAI,SAAUlG,GACzC,IACIsM,EADAoI,EAAY1U,EAAEhB,SAEZ0V,KAAaH,EAKjBjI,EAAciI,EAAUG,IAJxBpI,EAAcvH,IACdwP,EAAUG,GAAapI,EACvBvJ,EAASuB,KAAKtE,IAIhB6O,EAAkB4F,KAA4BnI,QAGlD,IAAID,EAAa,IAAIsI,aAA2B,EAAd5P,GAC9B6P,EAAqB,EAWzB,OAVA7R,EAASmD,KAAI,SAAUlG,GACrB,IAAIqD,EAAMrD,EAAEqD,IACZgJ,EAAWuI,KAAwBvR,EAAI3D,GACvC2M,EAAWuI,KAAwBvR,EAAIzD,MAE5B,CACX,MAAS,MACTiP,kBAAmBA,EACnBxC,WAAYA,KAMlB5Q,EAAOD,QAAUiL,G,gBC1ajB,MAAMtH,EAAW,EAAQ,GACnBD,EAAW,EAAQ,GACnB2V,EAAmB,EAAQ,IAC3B1R,EAAQ,EAAQ,GAIhBN,EAAY,SAAUiS,GACtBvV,UAAUC,QAAU,EACtBC,KAAKqV,SAAWA,EAGhBrV,KAAKqV,SAAW,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAIlEjS,EAAUjF,UAAY,CACpB2C,KAAM,SAAUnE,GAEd,IADA,IAAIU,EAAI,GACCd,EAAI,EAAGA,EAAI,GAAIA,IACtBc,EAAEd,GAAKyD,KAAKqV,SAAS9Y,GAAKI,EAAE0Y,SAAS9Y,GAEvC,OAAO,IAAI6G,EAAU/F,IAGvB2D,MAAO,SAAUrE,GAEf,IADA,IAAIU,EAAI,GACCd,EAAI,EAAGA,EAAI,GAAIA,IACtBc,EAAEd,GAAKyD,KAAKqV,SAAS9Y,GAAKI,EAAE0Y,SAAS9Y,GAEvC,OAAO,IAAI6G,EAAU/F,IAIvBiY,SAAU,SAAU3Y,GAElB,IAAI4Y,EAAQvV,KAAKqV,SAAS,GACtBG,EAAQxV,KAAKqV,SAAS,GACtBI,EAAQzV,KAAKqV,SAAS,GACtBK,EAAQ1V,KAAKqV,SAAS,GACtBM,EAAQ3V,KAAKqV,SAAS,GACtBO,EAAQ5V,KAAKqV,SAAS,GACtBQ,EAAQ7V,KAAKqV,SAAS,GACtBS,EAAQ9V,KAAKqV,SAAS,GACtBU,EAAQ/V,KAAKqV,SAAS,GACtBW,EAAQhW,KAAKqV,SAAS,GACtBY,EAASjW,KAAKqV,SAAS,IACvBa,EAASlW,KAAKqV,SAAS,IACvBc,EAASnW,KAAKqV,SAAS,IACvBe,EAASpW,KAAKqV,SAAS,IACvBgB,EAASrW,KAAKqV,SAAS,IACvBiB,EAAStW,KAAKqV,SAAS,IACvBkB,EAAK5Z,EAAE0Y,SAAS,GAChB5B,EAAK9W,EAAE0Y,SAAS,GAChB1B,EAAKhX,EAAE0Y,SAAS,GAChBmB,EAAK7Z,EAAE0Y,SAAS,GAChBoB,EAAK9Z,EAAE0Y,SAAS,GAChBqB,EAAK/Z,EAAE0Y,SAAS,GAChBsB,EAAKha,EAAE0Y,SAAS,GAChBuB,EAAKja,EAAE0Y,SAAS,GAChBwB,EAAKla,EAAE0Y,SAAS,GAChByB,EAAKna,EAAE0Y,SAAS,GAChB0B,EAAMpa,EAAE0Y,SAAS,IACjB2B,EAAMra,EAAE0Y,SAAS,IACjB4B,EAAMta,EAAE0Y,SAAS,IACjB6B,EAAMva,EAAE0Y,SAAS,IACjB8B,EAAMxa,EAAE0Y,SAAS,IACjB+B,EAAMza,EAAE0Y,SAAS,IAEjB3U,EAAS,GAiBb,OAhBAA,EAAO,GAAK6U,EAAQgB,EAAKf,EAAQiB,EAAKhB,EAAQoB,EAAKnB,EAAQuB,EAC3DvW,EAAO,GAAK6U,EAAQ9B,EAAK+B,EAAQkB,EAAKjB,EAAQqB,EAAKpB,EAAQwB,EAC3DxW,EAAO,GAAK6U,EAAQ5B,EAAK6B,EAAQmB,EAAKlB,EAAQsB,EAAMrB,EAAQyB,EAC5DzW,EAAO,GAAK6U,EAAQiB,EAAKhB,EAAQoB,EAAKnB,EAAQuB,EAAMtB,EAAQ0B,EAC5D1W,EAAO,GAAKiV,EAAQY,EAAKX,EAAQa,EAAKZ,EAAQgB,EAAKf,EAAQmB,EAC3DvW,EAAO,GAAKiV,EAAQlC,EAAKmC,EAAQc,EAAKb,EAAQiB,EAAKhB,EAAQoB,EAC3DxW,EAAO,GAAKiV,EAAQhC,EAAKiC,EAAQe,EAAKd,EAAQkB,EAAMjB,EAAQqB,EAC5DzW,EAAO,GAAKiV,EAAQa,EAAKZ,EAAQgB,EAAKf,EAAQmB,EAAMlB,EAAQsB,EAC5D1W,EAAO,GAAKqV,EAAQQ,EAAKP,EAAQS,EAAKR,EAASY,EAAKX,EAASe,EAC7DvW,EAAO,GAAKqV,EAAQtC,EAAKuC,EAAQU,EAAKT,EAASa,EAAKZ,EAASgB,EAC7DxW,EAAO,IAAMqV,EAAQpC,EAAKqC,EAAQW,EAAKV,EAASc,EAAMb,EAASiB,EAC/DzW,EAAO,IAAMqV,EAAQS,EAAKR,EAAQY,EAAKX,EAASe,EAAMd,EAASkB,EAC/D1W,EAAO,IAAMyV,EAASI,EAAKH,EAASK,EAAKJ,EAASQ,EAAKP,EAASW,EAChEvW,EAAO,IAAMyV,EAAS1C,EAAK2C,EAASM,EAAKL,EAASS,EAAKR,EAASY,EAChExW,EAAO,IAAMyV,EAASxC,EAAKyC,EAASO,EAAKN,EAASU,EAAMT,EAASa,EACjEzW,EAAO,IAAMyV,EAASK,EAAKJ,EAASQ,EAAKP,EAASW,EAAMV,EAASc,EAC1D,IAAIhU,EAAU1C,IAGvBC,MAAO,WACL,IAAI0U,EAAWrV,KAAKqV,SAAS5O,KAAI,SAAUpI,GACzC,OAAOA,KAET,OAAO,IAAI+E,EAAUiS,IAMvBgC,uBAAwB,SAAU9W,GAChC,IAAI+W,EAAK/W,EAAEN,GACPqK,EAAK/J,EAAEJ,GACPoK,EAAKhK,EAAEH,GAEPT,EAAI2X,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAAK9K,EAAKvK,KAAKqV,SAAS,GADlE,EAC4ErV,KAAKqV,SAAS,GAC/FzV,EAAI0X,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAAK9K,EAAKvK,KAAKqV,SAAS,GAFlE,EAE4ErV,KAAKqV,SAAS,GAC/FxV,EAAIyX,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAAK9K,EAAKvK,KAAKqV,SAAS,IAHlE,EAG6ErV,KAAKqV,SAAS,IAChGjL,EAAIkN,EAAKtX,KAAKqV,SAAS,IAAM/K,EAAKtK,KAAKqV,SAAS,IAAM9K,EAAKvK,KAAKqV,SAAS,IAJpE,EAI+ErV,KAAKqV,SAAS,IAEtG,GAAU,IAANjL,EAAS,CACX,IAAImN,EAAO,EAAMnN,EACjBzK,GAAK4X,EACL3X,GAAK2X,EACL1X,GAAK0X,EAEP,OAAO,IAAI7X,EAASC,EAAGC,EAAGC,IAM5BiC,sBAAuB,SAAUvB,GAC/B,IAAI+W,EAAK/W,EAAEN,GACPqK,EAAK/J,EAAEJ,GACPoK,EAAKhK,EAAEH,GAEPT,EAAI2X,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAAK9K,EAAKvK,KAAKqV,SAAS,GADlE,EAC4ErV,KAAKqV,SAAS,IAC/FzV,EAAI0X,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAAK9K,EAAKvK,KAAKqV,SAAS,GAFlE,EAE4ErV,KAAKqV,SAAS,IAC/FxV,EAAIyX,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAAK9K,EAAKvK,KAAKqV,SAAS,IAHlE,EAG6ErV,KAAKqV,SAAS,IAChGjL,EAAIkN,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAAK9K,EAAKvK,KAAKqV,SAAS,IAJlE,EAI6ErV,KAAKqV,SAAS,IAEpG,GAAU,IAANjL,EAAS,CACX,IAAImN,EAAO,EAAMnN,EACjBzK,GAAK4X,EACL3X,GAAK2X,EACL1X,GAAK0X,EAEP,OAAO,IAAI7X,EAASC,EAAGC,EAAGC,IAM5B2X,uBAAwB,SAAUjX,GAChC,IAAI+W,EAAK/W,EAAEZ,EACP2K,EAAK/J,EAAEX,EAGPD,EAAI2X,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAF1C,EAEoDrV,KAAKqV,SAAS,GADlE,EAC4ErV,KAAKqV,SAAS,GAC/FzV,EAAI0X,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAH1C,EAGoDrV,KAAKqV,SAAS,GAFlE,EAE4ErV,KAAKqV,SAAS,GAE/FjL,GADSpK,KAAKqV,SAAS,GAAUrV,KAAKqV,SAAS,GAAUrV,KAAKqV,SAAS,IAAWrV,KAAKqV,SAAS,IAC5FiC,EAAKtX,KAAKqV,SAAS,IAAM/K,EAAKtK,KAAKqV,SAAS,IAL3C,EAKsDrV,KAAKqV,SAAS,IAJpE,EAI+ErV,KAAKqV,SAAS,KAEtG,GAAU,IAANjL,EAAS,CACX,IAAImN,EAAO,EAAMnN,EACjBzK,GAAK4X,EACL3X,GAAK2X,EACAA,EAEP,OAAO,IAAI9X,EAASE,EAAGC,IAMzBkD,sBAAuB,SAAUvC,GAC/B,IAAI+W,EAAK/W,EAAEZ,EACP2K,EAAK/J,EAAEX,EAGPD,EAAI2X,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAF1C,EAEoDrV,KAAKqV,SAAS,GADlE,EAC4ErV,KAAKqV,SAAS,IAC/FzV,EAAI0X,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAH1C,EAGoDrV,KAAKqV,SAAS,GAFlE,EAE4ErV,KAAKqV,SAAS,IAE/FjL,GADSpK,KAAKqV,SAAS,GAAUrV,KAAKqV,SAAS,GAAUrV,KAAKqV,SAAS,IAAWrV,KAAKqV,SAAS,IAC5FiC,EAAKtX,KAAKqV,SAAS,GAAK/K,EAAKtK,KAAKqV,SAAS,GAL1C,EAKoDrV,KAAKqV,SAAS,IAJlE,EAI6ErV,KAAKqV,SAAS,KAEpG,GAAU,IAANjL,EAAS,CACX,IAAImN,EAAO,EAAMnN,EACjBzK,GAAK4X,EACL3X,GAAK2X,EACAA,EAEP,OAAO,IAAI9X,EAASE,EAAGC,IAIzBgH,YAAa,WACX,IAAImC,EAAI,IAAIrJ,EAASM,KAAKqV,SAAS,GAAIrV,KAAKqV,SAAS,GAAIrV,KAAKqV,SAAS,IACnE9U,EAAI,IAAIb,EAASM,KAAKqV,SAAS,GAAIrV,KAAKqV,SAAS,GAAIrV,KAAKqV,SAAS,IACnEjL,EAAI,IAAI1K,EAASM,KAAKqV,SAAS,GAAIrV,KAAKqV,SAAS,GAAIrV,KAAKqV,SAAS,KAMvE,OAFkBtM,EAAEvH,MAAMjB,GAAGY,IAAIiJ,GACH,IAMlChH,EAAUqU,MAAQ,WAChB,OAAO,IAAIrU,GAIbA,EAAUsU,UAAY,SAAUjV,GAC9B,IAAIH,EAAUG,EAAUjE,KAAKkE,IAAM,EAAM,KACrCC,EAAMnE,KAAKmE,IAAIL,GACf7D,EAAMD,KAAKC,IAAI6D,GAInB,OAAO,IAAIc,EAHD,CACR,EAAG,EAAG,EAAG,EAAG,EAAGT,EAAKlE,EAAK,EAAG,GAAIA,EAAKkE,EAAK,EAAG,EAAG,EAAG,EAAG,KAM1DS,EAAUuU,UAAY,SAAUlV,GAC9B,IAAIH,EAAUG,EAAUjE,KAAKkE,IAAM,EAAM,KACrCC,EAAMnE,KAAKmE,IAAIL,GACf7D,EAAMD,KAAKC,IAAI6D,GAInB,OAAO,IAAIc,EAHD,CACRT,EAAK,GAAIlE,EAAK,EAAG,EAAG,EAAG,EAAG,EAAGA,EAAK,EAAGkE,EAAK,EAAG,EAAG,EAAG,EAAG,KAM1DS,EAAUwU,UAAY,SAAUnV,GAC9B,IAAIH,EAAUG,EAAUjE,KAAKkE,IAAM,EAAM,KACrCC,EAAMnE,KAAKmE,IAAIL,GACf7D,EAAMD,KAAKC,IAAI6D,GAInB,OAAO,IAAIc,EAHD,CACRT,EAAKlE,EAAK,EAAG,GAAIA,EAAKkE,EAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAM1DS,EAAUyU,SAAW,SAAUC,EAAgBC,EAActV,GAC3DqV,EAAiB,IAAIpY,EAASoY,GAC9BC,EAAe,IAAIrY,EAASqY,GAC5B,IAAIC,EAAgBtU,EAAM+G,mBAAmBsN,EAAcD,GACvD/Q,EAAa,IAAIqO,EAAiB4C,GAClCC,EAAiB7U,EAAUyC,YAAYiS,EAAelX,WAK1D,OADAqX,GADAA,GADAA,GADAA,EAAiBA,EAAe3C,SAASvO,EAAWmR,wBACpB5C,SAASlS,EAAUwU,UAAUnV,KAC7B6S,SAASvO,EAAWoR,+BACpB7C,SAASlS,EAAUyC,YAAYiS,KAKjE1U,EAAUyC,YAAc,SAAUtF,GAEhC,IAAIoH,EAAM,IAAIjI,EAASa,GACnB6X,EAAM,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAGzQ,EAAIhI,EAAGgI,EAAI/H,EAAG+H,EAAI9H,EAAG,GACpE,OAAO,IAAIuD,EAAUgV,IAIvBhV,EAAUiV,UAAY,SAAU7U,GAC9B,IAAI8U,EAAK9U,EAAMX,OAAOlD,EAClB4Y,EAAK/U,EAAMX,OAAOjD,EAClB4Y,EAAKhV,EAAMX,OAAOhD,EAClBuK,EAAI5G,EAAM4G,EAOd,OAAO,IAAIhH,EAND,CACP,EAAM,EAAMkV,EAAKA,GAAO,EAAMC,EAAKD,GAAO,EAAME,EAAKF,EAAK,GACzD,EAAMA,EAAKC,EAAM,EAAM,EAAMA,EAAKA,GAAO,EAAMC,EAAKD,EAAK,GACzD,EAAMD,EAAKE,GAAO,EAAMD,EAAKC,EAAM,EAAM,EAAMA,EAAKA,EAAK,EAC1D,EAAMF,EAAKlO,EAAK,EAAMmO,EAAKnO,EAAK,EAAMoO,EAAKpO,EAAI,KAMpDhH,EAAUqV,QAAU,SAAUlY,GAE5B,IAAIoH,EAAM,IAAIjI,EAASa,GACnB6X,EAAM,CACRzQ,EAAIhI,EAAG,EAAG,EAAG,EAAG,EAAGgI,EAAI/H,EAAG,EAAG,EAAG,EAAG,EAAG+H,EAAI9H,EAAG,EAAG,EAAG,EAAG,EAAG,GAE3D,OAAO,IAAIuD,EAAUgV,IAGvBpc,EAAOD,QAAUqH,G,gBC3RjB,MAAM3D,EAAW,EAAQ,GACnBC,EAAW,EAAQ,GACnBgZ,EAAS,EAAQ,IACjBvO,EAAS,EAAQ,IACjBzG,EAAQ,EAAQ,GAQhB0R,EAAmB,SAAU5R,EAAOmV,GAGtCA,EAFE7Y,UAAUC,OAAS,EAEPyD,EAAMX,OAAOX,0BAEb,IAAIxC,EAASiZ,GAE7B3Y,KAAKO,EAAIiD,EAAMX,OAAOrB,MAAMmX,GAAapX,OACzCvB,KAAK+I,EAAI/I,KAAKO,EAAEiB,MAAMgC,EAAMX,QAC5B7C,KAAKwD,MAAQA,EACbxD,KAAK4Y,YAAcpV,EAAMX,OAAO5B,MAAMuC,EAAM4G,IAU9CgL,EAAiByD,aAAe,SAAUC,EAASC,GACjD,IACInR,EAAa+Q,EADbK,EAASF,EAAU,IAAMC,EAE7B,GAAe,QAAXC,EACFpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,SAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,UAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,EAAE,EAAG,EAAG,QACjB,GAAe,SAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,GAAI,EAAG,QACjB,GAAe,SAAXK,EACTpR,EAAc,CAAC,EAAG,GAAI,GACtB+Q,EAAc,EAAE,EAAG,EAAG,QACjB,GAAe,UAAXK,EACTpR,EAAc,CAAC,EAAG,GAAI,GACtB+Q,EAAc,CAAC,GAAI,EAAG,QACjB,GAAe,SAAXK,EACTpR,EAAc,CAAC,EAAG,GAAI,GACtB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,QAAXK,EACTpR,EAAc,CAAC,EAAG,GAAI,GACtB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,QAAXK,EACTpR,EAAc,CAAC,GAAI,EAAG,GACtB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,SAAXK,EACTpR,EAAc,CAAC,GAAI,EAAG,GACtB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,UAAXK,EACTpR,EAAc,CAAC,GAAI,EAAG,GACtB+Q,EAAc,EAAE,EAAG,EAAG,QACjB,GAAe,SAAXK,EACTpR,EAAc,CAAC,GAAI,EAAG,GACtB+Q,EAAc,CAAC,EAAG,GAAI,QACjB,GAAe,SAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,EAAE,EAAG,EAAG,QACjB,GAAe,UAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,EAAG,GAAI,QACjB,GAAe,SAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,QAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,QAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,SAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,EAAG,EAAG,QAChB,GAAe,UAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,GAAI,EAAG,QACjB,GAAe,SAAXK,EACTpR,EAAc,CAAC,EAAG,EAAG,GACrB+Q,EAAc,CAAC,EAAG,GAAI,QACjB,GAAe,SAAXK,EACTpR,EAAc,EAAE,EAAG,EAAG,GACtB+Q,EAAc,CAAC,GAAI,EAAG,QACjB,GAAe,UAAXK,EACTpR,EAAc,EAAE,EAAG,EAAG,GACtB+Q,EAAc,CAAC,EAAG,GAAI,QACjB,GAAe,SAAXK,EACTpR,EAAc,EAAE,EAAG,EAAG,GACtB+Q,EAAc,CAAC,EAAG,EAAG,OAChB,IAAe,QAAXK,EAIT,MAAM,IAAIxY,MAAM,6JAHhBoH,EAAc,EAAE,EAAG,EAAG,GACtB+Q,EAAc,CAAC,EAAG,EAAG,GAIvB,OAAO,IAAIvD,EAAiB,IAAI1R,EAAM,IAAIhE,EAASkI,GAAc,GAAI,IAAIlI,EAASiZ,KAgCpFvD,EAAiB6D,QAAU,WACzB,IAAIzV,EAAQ,IAAIE,EAAM,IAAIhE,EAAS,CAAC,EAAG,EAAG,IAAK,GAC/C,OAAO,IAAI0V,EAAiB5R,EAAO,IAAI9D,EAAS,CAAC,EAAG,EAAG,MAGzD0V,EAAiBjX,UAAY,CAC3B+Z,oBAAqB,WAEnB,OAAO,IADW,EAAQ,IACnB,CAAc,CACnBlY,KAAK+I,EAAEpJ,EAAGK,KAAKO,EAAEZ,EAAGK,KAAKwD,MAAMX,OAAOlD,EAAG,EACzCK,KAAK+I,EAAEnJ,EAAGI,KAAKO,EAAEX,EAAGI,KAAKwD,MAAMX,OAAOjD,EAAG,EACzCI,KAAK+I,EAAElJ,EAAGG,KAAKO,EAAEV,EAAGG,KAAKwD,MAAMX,OAAOhD,EAAG,EACzC,EAAG,GAAIG,KAAKwD,MAAM4G,EAAG,KAIzB+N,2BAA4B,WAC1B,MAAM/U,EAAY,EAAQ,IAC1B,IAAI/E,EAAI2B,KAAKwD,MAAMX,OAAO5B,MAAMjB,KAAKwD,MAAM4G,GAC3C,OAAO,IAAIhH,EAAU,CACnBpD,KAAK+I,EAAEpJ,EAAGK,KAAK+I,EAAEnJ,EAAGI,KAAK+I,EAAElJ,EAAG,EAC9BG,KAAKO,EAAEZ,EAAGK,KAAKO,EAAEX,EAAGI,KAAKO,EAAEV,EAAG,EAC9BG,KAAKwD,MAAMX,OAAOlD,EAAGK,KAAKwD,MAAMX,OAAOjD,EAAGI,KAAKwD,MAAMX,OAAOhD,EAAG,EAC/DxB,EAAEsB,EAAGtB,EAAEuB,EAAGvB,EAAEwB,EAAG,KAInBqH,KAAM,SAAUgS,GACd,OAAO,IAAIzZ,EAASyZ,EAAK/X,IAAInB,KAAK+I,GAAImQ,EAAK/X,IAAInB,KAAKO,KAGtD4Y,KAAM,SAAUC,GACd,OAAOpZ,KAAK4Y,YAAY9X,KAAKd,KAAK+I,EAAE9H,MAAMmY,EAAKzZ,IAAImB,KAAKd,KAAKO,EAAEU,MAAMmY,EAAKxZ,KAG5EyZ,WAAY,SAAUnO,GACpB,IAAInK,EAAImK,EAAO3E,MACXkC,EAAIyC,EAAOH,UAAUjK,KAAKC,GAC1BuY,EAAMtZ,KAAKkH,KAAKnG,GAChBwY,EAAMvZ,KAAKkH,KAAKuB,GACpB,OAAOiQ,EAAOlO,WAAW8O,EAAKC,IAGhCC,WAAY,SAAUC,GACpB,IAAI1Y,EAAI0Y,EAAOnH,SACX7J,EAAIgR,EAAO1O,YAAYjK,KAAKC,GAC5B2Y,EAAM1Z,KAAKmZ,KAAKpY,GAChB4Y,EAAM3Z,KAAKmZ,KAAK1Q,GACpB,OAAO0B,EAAOK,WAAWkP,EAAKC,IAGhC5X,UAAW,SAAUF,GAEnB,IAAI8E,EAAW3G,KAAKwD,MAAMzB,UAAUF,GAChC+X,EAAwB5Z,KAAK+I,EAAEhH,UAAUF,GACzCgY,EAAoB,IAAIna,EAAS,EAAG,EAAG,GAAGqC,UAAUF,GACpDiY,EAAqBF,EAAsB5Y,MAAM6Y,GAErD,OADe,IAAIzE,EAAiBzO,EAAUmT,KAKlD9d,EAAOD,QAAUqZ,G,gBC5MjB,MAAM2E,EAAO,EAAQ,IACf1W,EAAU,EAAQ,GAClBK,EAAQ,EAAQ,GAChB0R,EAAmB,EAAQ,IAI3B4E,GAFM,EAAQ,GAED,EAAQ,MACrB,aAAChV,GAAgB,EAAQ,GAEzBiV,EAAgB,EAAQ,IACxBvK,EAAe,EAAQ,IACvBC,EAAc,EAAQ,KACtB,OAACmD,GAAU,EAAQ,KACnB,0BAAChM,GAA6B,EAAQ,KAEtC,QAACoT,EAAO,6BAAEC,EAA4B,qDAAEC,GAAwD,EAAQ,KACxG,WAACC,EAAU,WAAEC,GAAc,EAAQ,IACnClK,EAAS,EAAQ,KACjB,OAACC,EAAM,SAAEC,EAAQ,oBAAEiK,GAAuB,EAAQ,IAOxD,IAAIC,EAAM,WACRxa,KAAKkK,SAAW,GAChBlK,KAAKya,WAAa,IAAIT,EACtBha,KAAKkM,iBAAkB,EACvBlM,KAAKmM,gBAAiB,GAGxBqO,EAAIrc,UAAY,CAkBdyP,MAAO,SAAU3B,GACf,IAAIyO,EAQAne,EAEJ,IATI0P,aAAe3L,OACjBoa,EAAOzO,EAAI7D,MAAM,GACjBsS,EAAK7V,KAAK7E,OAEV0a,EAAO,CAAC1a,KAAMiM,GAKX1P,EAAI,EAAGA,EAAIme,EAAK3a,OAAQxD,GAAK,EAChCme,EAAK7V,KAAK6V,EAAKne,EAAI,GAAGoe,SAASD,EAAKne,KAEtC,OAAOme,EAAKne,EAAI,GAAGmU,eAAerC,iBAGpCsM,SAAU,SAAU1O,EAAK0D,EAAaD,GACpC,GAAK1P,KAAK4a,WAAW3O,GAEd,CACL,IAAIlL,EAAI,IAAIgZ,EAAK/Z,KAAKkK,UAClBzB,EAAI,IAAIsR,EAAK9N,EAAI/B,UACrBnJ,EAAE8Z,OAAOpS,GAAG,GAGZA,EAAEoS,OAAO9Z,GACT0H,EAAEwK,SACFxK,EAAEoS,OAAO9Z,GACT0H,EAAEwK,SAEF,IAAIhO,EAAclE,EAAE+Z,cAAcC,OAAOtS,EAAEqS,eACvCpa,EAASsE,EAAaC,GAI1B,OAHAvE,EAAO+Z,WAAaza,KAAKya,WAAWO,OAAO/O,EAAIwO,YAC3C9K,IAAajP,EAASA,EAAOgQ,gBAC7BhB,IAAchP,EAASA,EAAO2N,iBAC3B3N,EAjBP,OAAOV,KAAKib,wBAAwBhP,IAuBxCgP,wBAAyB,SAAUhP,GACjC,IAAIhH,EAAcjF,KAAKkK,SAAS6Q,OAAO9O,EAAI/B,UACvCxJ,EAASsE,EAAaC,GAI1B,OAHAvE,EAAO+Z,WAAaza,KAAKya,WAAWO,OAAO/O,EAAIwO,YAC/C/Z,EAAOwL,gBAAkBlM,KAAKkM,iBAAmBD,EAAIC,gBACrDxL,EAAOyL,eAAiBnM,KAAKmM,gBAAkBF,EAAIE,eAC5CzL,GAoBTiQ,SAAU,SAAU1E,GAClB,IAAIyO,EAEFA,EADEzO,aAAe3L,MACV2L,EAEA,CAACA,GAEV,IAAIvL,EAASV,KACb,IAAK,IAAIzD,EAAI,EAAGA,EAAIme,EAAK3a,OAAQxD,IAAK,CACpC,IAAI2e,EAAU3e,IAAOme,EAAK3a,OAAS,EACnCW,EAASA,EAAOkQ,YAAY8J,EAAKne,GAAI2e,EAAQA,GAE/C,OAAOxa,GAGTkQ,YAAa,SAAU3E,EAAK0D,EAAaD,GACvC,IAAI3O,EAAI,IAAIgZ,EAAK/Z,KAAKkK,UAClBzB,EAAI,IAAIsR,EAAK9N,EAAI/B,UACrBnJ,EAAEkS,SACFlS,EAAE8Z,OAAOpS,GACTA,EAAEoS,OAAO9Z,GAAG,GACZA,EAAEoa,YAAY1S,EAAEqS,eAChB/Z,EAAEkS,SACF,IAAIvS,EAASsE,EAAajE,EAAE+Z,eAI5B,OAHApa,EAAO+Z,WAAaza,KAAKya,WAAWO,OAAO/O,EAAIwO,YAC3C9K,IAAajP,EAASA,EAAOgQ,gBAC7BhB,IAAchP,EAASA,EAAO2N,iBAC3B3N,GAoBTmQ,UAAW,SAAU5E,GACnB,IAAIyO,EAEFA,EADEzO,aAAe3L,MACV2L,EAEA,CAACA,GAEV,IAAIvL,EAASV,KACb,IAAK,IAAIzD,EAAI,EAAGA,EAAIme,EAAK3a,OAAQxD,IAAK,CACpC,IAAI2e,EAAU3e,IAAOme,EAAK3a,OAAS,EACnCW,EAASA,EAAOoQ,aAAa4J,EAAKne,GAAI2e,EAAQA,GAEhD,OAAOxa,GAGToQ,aAAc,SAAU7E,EAAK0D,EAAaD,GACxC,IAAI3O,EAAI,IAAIgZ,EAAK/Z,KAAKkK,UAClBzB,EAAI,IAAIsR,EAAK9N,EAAI/B,UACrBnJ,EAAEkS,SACFxK,EAAEoS,OAAO9Z,GACT0H,EAAEwK,SACFlS,EAAE8Z,OAAOpS,GACTA,EAAEoS,OAAO9Z,GACTA,EAAEoa,YAAY1S,EAAEqS,eAChB/Z,EAAEkS,SACF,IAAIvS,EAASsE,EAAajE,EAAE+Z,eAI5B,OAHApa,EAAO+Z,WAAaza,KAAKya,WAAWO,OAAO/O,EAAIwO,YAC3C9K,IAAajP,EAASA,EAAOgQ,gBAC7BhB,IAAchP,EAASA,EAAO2N,iBAC3B3N,GAUTuS,OAAQ,WACN,IAAImI,EAAkBpb,KAAKkK,SAASzD,KAAI,SAAUpI,GAChD,OAAOA,EAAE8G,aAEX,OAAOH,EAAaoW,IAKtBC,WAAY,SAAUxZ,GACpB,IAAIoD,EAAcjF,KAAKkK,SAASzD,KAAI,SAAUpI,GAC5C,OAAOA,EAAE0D,UAAUF,MAEjBnB,EAASsE,EAAaC,GAG1B,OAFAvE,EAAO+Z,WAAaza,KAAKya,WAAWa,WAAWzZ,GAC/CnB,EAAOyL,eAAiBnM,KAAKmM,eACtBzL,GAcTqB,UAAW,SAAUF,GACnB,IAAI6I,EAAW7I,EAAU+E,cACrB2U,EAAsB,GACtBC,EAAoB,GACpBvW,EAAcjF,KAAKkK,SAASzD,KAAI,SAAUpI,GAC5C,IAAIsI,EACAnD,EAAQnF,EAAEmF,MACViY,EAAWjY,EAAMjE,SACjBkc,KAAYD,EACd7U,EAAW6U,EAAkBC,IAE7B9U,EAAWnD,EAAMzB,UAAUF,GAC3B2Z,EAAkBC,GAAY9U,GAEhC,IAAIH,EAAcnI,EAAEiF,SAASmD,KAAI,SAAUlG,GACzC,IAAImb,EACAzG,EAAY1U,EAAEhB,SAOlB,OANI0V,KAAasG,EACfG,EAAYH,EAAoBtG,IAEhCyG,EAAYnb,EAAEwB,UAAUF,GACxB0Z,EAAoBtG,GAAayG,GAE5BA,KAGT,OADIhR,GAAUlE,EAAYE,UACnB,IAAIrD,EAAQmD,EAAanI,EAAEkF,OAAQoD,MAExCjG,EAASsE,EAAaC,GAI1B,OAHAvE,EAAO+Z,WAAaza,KAAKya,WAAWa,WAAWzZ,GAC/CnB,EAAOyL,eAAiBnM,KAAKmM,eAC7BzL,EAAOwL,gBAAkBlM,KAAKkM,gBACvBxL,GAIT0P,OAAQ,SAAUY,GAChB,OAAOZ,EAAO,CAACY,KAAMA,GAAO,CAAChR,QAI/BqQ,OAAQ,SAAUlK,EAAQ+K,GACxB,OAAOb,EAAOrQ,KAAMmG,EAAQ+K,IAI9BZ,SAAU,SAAUnK,EAAQ+K,GAC1B,OAAOZ,EAAStQ,KAAMmG,EAAQ+K,IAIhCD,cAAe,SAAU9K,EAAQ+K,EAAYyK,GAC3C,OAAOpB,EAAoBva,KAAMmG,EAAQ+K,EAAYyK,IAKvDC,eAAgB,SAAU/Y,EAAQ0D,EAAOxG,GACvC,IAAIyD,EAAQE,EAAM+G,mBAAmB5H,EAAQ0D,GACzCsV,EAAM,IAAIzG,EAAiB5R,GAE3BsY,EADY9b,KAAKqa,WAAWwB,GACP7L,0BAA0B6L,EAAK9b,GACpDgc,EAAS/b,KAAKsa,WAAW9W,GACzBwY,EAAShc,KAAKsa,WAAW9W,EAAM2B,WAEnC,OADa4W,EAAOnO,MAAM,CAACkO,EAAUE,EAAO3W,UAAU7B,EAAMX,OAAO5B,MAAMlB,OAK3EsO,cAAe,WACb,OAAOqB,EAAa1P,OAItB0Q,aAAc,WACZ,OAAOf,EAAY3P,OAIrBia,cAAe,WACb,OAAOA,EAAcjV,EAAchF,OAIrC8P,UAAW,WACT,OAAOgD,EAAO9S,OAQhB4a,WAAY,SAAU3O,GACpB,GAA8B,IAAzBjM,KAAKkK,SAASnK,QAA0C,IAAxBkM,EAAI/B,SAASnK,OAChD,OAAO,EACF,CACL,IAAIkc,EAAWnJ,EAAO9S,MAClBkc,EAAcpJ,EAAO7G,GACzB,QAAIgQ,EAAS,GAAGtc,EAAIuc,EAAY,GAAGvc,OAC/Bsc,EAAS,GAAGtc,EAAIuc,EAAY,GAAGvc,OAC/Bsc,EAAS,GAAGrc,EAAIsc,EAAY,GAAGtc,OAC/Bqc,EAAS,GAAGrc,EAAIsc,EAAY,GAAGtc,OAC/Bqc,EAAS,GAAGpc,EAAIqc,EAAY,GAAGrc,MAC/Boc,EAAS,GAAGpc,EAAIqc,EAAY,GAAGrc,SAMvCya,WAAY,SAAU9W,GACpB,OAAO8W,EAAWta,KAAMwD,IAa1B2Y,UAAW,SAAUC,EAAaC,EAAgBC,EAAQC,GACxD,IAAIC,EAASJ,EAAYvJ,oBAAoBwJ,EAAgBC,EAAQC,GACrE,OAAOvc,KAAK+B,UAAUya,IAQxBC,UAAW,SAAUlZ,GACnB,IAAI2G,EAAWlK,KAAKkK,SAASzD,KAAI,SAAUpI,GACzC,OAAO,IAAIgF,EAAQhF,EAAEiF,SAAUC,EAAQlF,EAAEmF,UAEvC9C,EAASsE,EAAakF,GAI1B,OAHAxJ,EAAO+Z,WAAaza,KAAKya,WACzB/Z,EAAOyL,eAAiBnM,KAAKmM,eAC7BzL,EAAOwL,gBAAkBlM,KAAKkM,gBACvBxL,GAOTqD,SAAU,SAAUC,GAClB,IAAIC,EAAYZ,EAAQa,OAAOC,UAAUC,MAAMpE,KAAMF,WACrD,OAAOE,KAAKyc,UAAUxY,IAIxBmW,qDAAsD,WACpD,OAAOA,EAAqDpa,OAI9Dma,6BAA8B,WAC5B,OAAOA,EAA6Bna,OAItCka,QAAS,WACP,OAAOA,EAAQla,OAMjB8G,0BAA2B,SAAUC,GAEnC,OAAOD,EAA0B9G,KAAM+G,IAIzCsT,WAAY,SAAUtT,GACpB,OAAOsT,EAAWra,KAAM+G,IAY1B2V,YAAa,SAAUhY,GACfA,aAAoBpE,QACxBoE,EAAW,CAACA,IAEd,IAAIhE,EAASV,KAAK2c,cAAclW,KAAI,SAAUmW,GAC5C,OAAOA,EAAQnY,iBAAiBC,MAE/BmY,QAAO,SAAUC,EAAIvc,GACpB,OAAOA,EAAEkG,KAAI,SAAUsW,EAAMxgB,GAC3B,OAAOwgB,GAAe,IAAPD,EAAW,EAAIA,EAAGvgB,SAElC,GACL,OAA0B,IAAlBmE,EAAOX,OAAgBW,EAAO,GAAKA,GAG7Csc,WAAY,WACV,OAAOhd,KAAKkK,UAGdlI,SAAU,WACR,IAAItB,EAAS,eAIb,OAHAV,KAAKkK,SAASzD,KAAI,SAAUpI,GAC1BqC,GAAUrC,EAAE2D,cAEPtB,GAQTmU,gBAAiB,WACf,IAAI5I,EAAMjM,KAAKqO,gBACXpB,EAAchB,EAAI/B,SAASnK,OAC3B+M,EAAqB,EAErBxH,EAAc,EACdwP,EAAY,GACZxR,EAAW,GAEXmJ,EAAY,EACZwQ,EAAW,GACX1Q,EAAS,GAETS,EAAU,GACVkQ,EAAY,GACZC,EAAY,EAWhBlR,EAAI/B,SAASzD,KAAI,SAAUiB,GAGzBA,EAAQpE,SAASmD,KAAI,SAAUI,KAC3BiG,EACF,IAAImI,EAAYpO,EAAOtH,SACjB0V,KAAaH,IACjBA,EAAUG,GAAa3P,IACvBhC,EAASuB,KAAKgC,OAIlB,IAAI4U,EAAW/T,EAAQlE,MAAMjE,SACvBkc,KAAYwB,IAChBA,EAASxB,GAAYhP,IACrBF,EAAO1H,KAAK6C,EAAQlE,QAEtB,IAAI4Z,EAAY1V,EAAQnE,OAAOhE,SACzB6d,KAAaF,IACjBA,EAAUE,GAAaD,IACvBnQ,EAAQnI,KAAK6C,EAAQnE,YAIzB,IAAI4J,EAAwB,IAAI4H,YAAY9H,GACxCK,EAAuB,IAAIyH,YAAY9H,GACvCG,EAAkB,IAAI2H,YAAYjI,GAClCO,EAAsB,IAAI0H,YAAY9H,GACtCL,EAAa,IAAIsI,aAA2B,EAAd5P,GAC9BkH,EAAY,IAAI0I,aAAyB,EAAZzI,GAC7B4Q,EAAuB,EAI3B,IAAK,IAAI9P,EAAe,EAAGA,EAAeN,IAAeM,EAAc,CACrE,IAAI7F,EAAUuE,EAAI/B,SAASqD,GAC3BJ,EAAsBI,GAAgB7F,EAAQpE,SAASvD,OACvD2H,EAAQpE,SAASmD,KAAI,SAAUI,GAC7B,IAAIoO,EAAYpO,EAAOtH,SACnBsN,EAAciI,EAAUG,GAC5B7H,EAAgBiQ,KAA0BxQ,KAE5C,IAAI4O,EAAW/T,EAAQlE,MAAMjE,SACzBoN,EAAasQ,EAASxB,GAC1BpO,EAAoBE,GAAgBZ,EACpC,IAAIyQ,EAAY1V,EAAQnE,OAAOhE,SAC3B+d,EAAcJ,EAAUE,GAC5B9P,EAAqBC,GAAgB+P,EAEvC,IAAInI,EAAqB,EACzB7R,EAASmD,KAAI,SAAUI,GACrB,MAAMjD,EAAMiD,EAAOjD,IACnBgJ,EAAWuI,KAAwBvR,EAAI3D,GACvC2M,EAAWuI,KAAwBvR,EAAIzD,GACvCyM,EAAWuI,KAAwBvR,EAAIxD,MAEzC,IAAImd,EAAmB,EAoBvB,OAnBAhR,EAAO9F,KAAI,SAAUjD,GACnB,MAAMX,EAASW,EAAMX,OACrB2J,EAAU+Q,KAAsB1a,EAAO5C,GACvCuM,EAAU+Q,KAAsB1a,EAAO1C,GACvCqM,EAAU+Q,KAAsB1a,EAAOzC,GACvCoM,EAAU+Q,KAAsB/Z,EAAM4G,KAG3B,CACX,MAAS,MACT8C,YAAaD,EACbE,sBAAuBA,EACvBE,oBAAqBA,EACrBC,qBAAsBA,EACtBF,gBAAiBA,EACjBR,WAAYA,EACZJ,UAAWA,EACXjJ,OAAQyJ,IAQZ2P,YAAa,WACX,IAAIzS,EAAW,GAcf,OAbAlK,KAAKkK,SAASvF,SAAQ,SAAUwO,GAC9B,IAAIqK,EAAcrK,EAAK7P,SAAS,GAChC,IAAK,IAAI/G,EAAI4W,EAAK7P,SAASvD,OAAS,EAAGxD,GAAK,EAAGA,IAC7C2N,EAASrF,KAAK,IAAIxB,EAChB,CACEma,EACArK,EAAK7P,SAAS/G,EAAI,GAClB4W,EAAK7P,SAAS/G,EAAI,IAEpB4W,EAAK5P,OACL4P,EAAK3P,WAGJ0G,IAIXlO,EAAOD,QAAUye,G,gBCzkBjB,MAAM9a,EAAW,EAAQ,GACnByK,EAAS,EAAQ,IACjB/G,EAAY,EAAQ,IACpBgS,EAAmB,EAAQ,IAC3B1R,EAAQ,EAAQ,GAUhB8L,EAAY,SAAUjJ,EAAOmN,EAAY+J,GAC7Czd,KAAKuG,MAAQ,IAAI7G,EAAS6G,GAC1BvG,KAAK0T,WAAa,IAAIhU,EAASgU,GAAYnS,OAC3CvB,KAAKyd,aAAe,IAAI/d,EAAS+d,GAAclc,QAGjDiO,EAAUrR,UAAY,CACpBuf,WAAY,WACV,IAAIhK,EAAa1T,KAAK0T,WAAWnS,OAE7BvD,EAAIgC,KAAKyd,aAAajc,MAAMkS,GAAYnS,OACxCkc,EAAe/J,EAAWlS,MAAMxD,GACpC,OAAO,IAAIwR,EAAUxP,KAAKuG,MAAOmN,EAAY+J,IAG/C1b,UAAW,SAAUF,GACnB,IAAI0E,EAAQvG,KAAKuG,MAAM3E,YAAYC,GAC/B6R,EAAa1T,KAAKuG,MAAMzF,KAAKd,KAAK0T,YAAY9R,YAAYC,GAAWb,MAAMuF,GAC3EkX,EAAezd,KAAKuG,MAAMzF,KAAKd,KAAKyd,cAAc7b,YAAYC,GAAWb,MAAMuF,GACnF,OAAO,IAAIiJ,EAAUjJ,EAAOmN,EAAY+J,IAS1C5K,oBAAqB,SAAUjH,EAAO0Q,EAAQC,GAC5CD,IAASA,EACTC,EAAiBA,EAAiBoB,OAAOpB,GAAkB,EAC3D,IAAIqB,EAAK5d,KAAK0d,aACd9R,EAAQA,EAAM8R,aAEd,IAAIzF,EAAiB7U,EAAUyC,YAAY7F,KAAKuG,MAAM3F,WAElDid,EAAYna,EAAM2G,sBACpB,IAAI3K,EAAS,EAAG,EAAG,GAAIke,EAAGlK,WAAY9H,EAAM8H,YAC1CoK,EAAY,IAAI1I,EAAiByI,GACjCE,EAASD,EAAU5W,KAAK0W,EAAGlK,YAAY3Q,QACvCib,EAASF,EAAU5W,KAAK0E,EAAM8H,YAAY3Q,QAC1C8U,EAAW,KAASmG,EAASD,GAAUvf,KAAKkE,GAC5C4Z,IAAQzE,GAAY,KACxBI,EAAiBA,EAAe3C,SAASwI,EAAU5F,uBACnDD,EAAiBA,EAAe3C,SAASlS,EAAUwU,UAAUC,IAC7DI,EAAiBA,EAAe3C,SAASwI,EAAU3F,8BACnD,IAAI8F,EAAgBL,EAAG7b,UAAUkW,GAG7BiG,EAAexa,EAAM+G,mBAAmBmB,EAAM8H,WAAY,IAAIhU,EAAS,EAAG,EAAG,IAC7Eye,EAAe,IAAI/I,EAAiB8I,GAWxC,OAVAH,EAASI,EAAajX,KAAK+W,EAAcR,cAAc1a,QACvDib,EAASG,EAAajX,KAAK0E,EAAM6R,cAAc1a,QAC/C8U,EAAW,KAASmG,EAASD,GAAUvf,KAAKkE,GAC5CmV,GAAY0E,EACZtE,EAAiBA,EAAe3C,SAAS6I,EAAajG,uBACtDD,EAAiBA,EAAe3C,SAASlS,EAAUwU,UAAUC,IAC7DI,EAAiBA,EAAe3C,SAAS6I,EAAahG,8BAEtDF,EAAiBA,EAAe3C,SAASlS,EAAUyC,YAAY+F,EAAMrF,QAE9D0R,GAGTmG,SAAU,WACR,OAAO,IAAIjU,EAAOnK,KAAKuG,MAAOvG,KAAK0T,aAIrC2K,OAAQ,SAAU7S,GAChB,IAAI8S,EAAWte,KAAKuG,MAAMzF,KAAKd,KAAK0T,WAAWnS,OAAON,MAAMuK,IAC5D,OAAO,IAAIgE,EAAU8O,EAAUte,KAAK0T,WAAY1T,KAAKyd,gBAIzD,MAAMc,EAAgB,SAAUC,GAC9Bxe,KAAKye,YAAcD,EAAaA,EAAWpW,QAAU,IAGvDmW,EAAc/L,cAAgB,CAAC,EAAG,EAAG,GAErC+L,EAAcG,WAAa,SAAUC,EAAQC,EAAMC,GACjD,GAAyB,IAArB/e,UAAUC,OACZ,OAAOwe,EAAcO,oBAAoBH,EAAQC,EAAMC,GAClD,GAAyB,IAArB/e,UAAUC,OACnB,OAAOwe,EAAcQ,oBAAoBJ,EAAQC,GAEjD,MAAM,IAAIpe,MAAM,+FASpB+d,EAAcO,oBAAsB,SAAUH,EAAQK,EAAOC,GAE3D,IAAIC,EACAC,EAAUR,EAAOlX,OAAO1H,OACxBW,EAAS,IAAI6d,EAAc,CAAC,IAAI/O,EAAUmP,EAAOlX,OAAO,GAC1DuX,EAAOT,EAAc/L,iBAUvB,OARAmM,EAAOlX,OAAOW,MAAM,EAAG+W,EAAU,GAAGxa,SAAQ,SAAUmG,EAAIvO,GACxD2iB,EAAOP,EAAOlX,OAAOlL,EAAI,GAAGyE,MAAM2d,EAAOlX,OAAOlL,IAAIqG,WAAW,GAC/DlC,EAAO0e,gBAAgB,IAAI5P,EAAU1E,EAAGlI,WAAW,GAAIsc,EACrDX,EAAc/L,kBACfxS,MACHU,EAAO0e,gBAAgB,IAAI5P,EAAUmP,EAAOlX,OAAO0X,EAAU,GAAIF,EAC/DV,EAAc/L,gBAChB9R,EAAO2e,OAASV,EAAOU,OAChB3e,GAMT6d,EAAcQ,oBAAsB,SAAUJ,EAAQW,GAQpD,IAAI5e,EAAS,IAAI6d,EACfI,EAAOlX,OAAOhB,KAAI,SAAUqE,EAAIvO,GAC9B,OAAO,IAAIiT,EAAU1E,EAAGlI,WAAW,GACjClD,EAASe,OAAO,EAAG,EAAG,GAAG8e,QAV/B,SAAkBD,EAAUE,EAAIjjB,GAI9B,MAHwB,mBAAb+iB,IACTA,EAAWA,EAASE,EAAIjjB,IAEnB+iB,EAM8BG,CAASH,EAAUxU,EAAIvO,IACxDgiB,EAAc/L,iBACfxS,OAGL,OADAU,EAAO2e,OAASV,EAAOU,OAChB3e,GAGT6d,EAAcpgB,UAAY,CACxBuhB,UAAW,SAAUL,GACnBrf,KAAKqf,SAAWA,GAElBD,gBAAiB,SAAUO,GACzB3f,KAAKye,YAAY5Z,KAAK8a,IASxBC,WAAY,SAAUC,GACpB,MAAMrF,EAAM,EAAQ,IAIpB,SAASsF,EAAOD,EAAQE,GAItB,MAHsB,mBAAXF,IACTA,EAASA,EAAOE,EAAUxZ,MAAOwZ,EAAUrM,WAAYqM,EAAUtC,eAE5DoC,EANT7f,KAAKggB,SASL,IACIC,EADA/V,EAAW,GAEXgW,EAAgBlgB,KAAKye,YAAYze,KAAKye,YAAY1e,OAAS,GAC3DogB,EAAUL,EAAOD,EAAQK,GAqB7B,OAnBAlgB,KAAKye,YAAY9Z,SAAQ,SAAUob,EAAWK,GAC5CH,EAAUH,EAAOD,EAAQE,GACrBK,GAAYpgB,KAAKqf,OACnBnV,EAASrF,KAAKT,MAAM8F,EAAUiW,EAAQ/M,gBAAgB,CACpDE,aAAc4M,EAAe3M,aAAcwM,EAAWhS,IAAKkS,KAI7D/V,EAASrF,KAAKT,MAAM8F,EAClB+V,EAAQ7N,iBAAiB,CAACQ,YAAamN,EAAW5a,SAAS,KAE3Dib,IAAapgB,KAAKye,YAAY1e,OAAS,GAAMC,KAAKqf,QAEpDnV,EAASrF,KAAKT,MAAM8F,EAClB+V,EAAQ7N,iBAAiB,CAACQ,YAAamN,KAE3CI,EAAUF,EACVC,EAAgBH,IACf/f,MACIwa,EAAIxV,aAAakF,GAAUwG,eAAerC,iBAMnD2R,OAAQ,WACN,IAAIK,EACAC,EACJ,IAAK,IAAI/jB,EAAI,EAAGA,EAAIyD,KAAKye,YAAY1e,OAAS,EAAGxD,IAAK,CAGpD,GAFA8jB,EAAQrgB,KAAKye,YAAYliB,GACzB+jB,EAAStgB,KAAKye,YAAYliB,EAAI,GAC1B+jB,EAAO/Z,MAAMvF,MAAMqf,EAAM9Z,OAAOpF,IAAIkf,EAAM3M,aAAe,EAC3D,MAAM,IAAIlT,MAAM,uHAElB,GAAI6f,EAAM3M,WAAWvS,IAAImf,EAAO5M,aAAe,EAC7C,MAAM,IAAIlT,MAAM,4FAMxBxE,EAAOD,QAAU,CAACyT,YAAW+O,kB,gBC9N7B,MAAM9e,EAAW,EAAQ,IACnB,OAACF,GAAU,EAAQ,GAEnB4D,EAAS,SAAUS,GACvB5D,KAAK4D,IAAMA,GAGbT,EAAOmE,WAAa,SAAUC,GAC5B,OAAO,IAAIpE,EAAO,IAAI1D,EAAS8H,EAAI3D,IAAI3D,GAAIsH,EAAI3D,IAAIzD,MAGrDgD,EAAOhF,UAAY,CACjB6D,SAAU,WACR,MAAO,IAAMhC,KAAK4D,IAAIjE,EAAEsC,QAAQ,GAAK,IAAMjC,KAAK4D,IAAIhE,EAAEqC,QAAQ,GAAK,KAErE1C,OAAQ,WACN,IAAImB,EAASV,KAAKqI,IAKlB,OAJK3H,IACHA,EAASnB,IACTS,KAAKqI,IAAM3H,GAENA,IAIX1E,EAAOD,QAAUoH,G,gBCzBjB,MAAMzD,EAAW,EAAQ,GACnBD,EAAW,EAAQ,GAInB8gB,EAAc,SAAUlZ,EAASmZ,EAAYC,GACjD,IAAI/f,EAAS+f,EAIb,OAHIpZ,GAAWmZ,KAAcnZ,IAC3B3G,EAAS2G,EAAQmZ,IAEZ9f,GAyDT1E,EAAOD,QAAU,CACfwkB,cACAG,iBAtBuB,SAAUrZ,EAASmZ,EAAYC,GACtD,IAAI/f,EAAS6f,EAAYlZ,EAASmZ,EAAYC,GAE9C,GADA/f,EAASid,OAAOnf,KAAKgL,MAAM9I,IACvBkI,MAAMlI,GACR,MAAM,IAAIF,MAAM,aAAeggB,EAAa,uBAE9C,OAAO9f,GAiBPigB,mBAlCyB,SAAUtZ,EAASmZ,EAAYC,GACxD,IAAI/f,EAAS6f,EAAYlZ,EAASmZ,EAAYC,GAI9C,GAHwB,iBAAb,IACT/f,EAASid,OAAOjd,IAEdkI,MAAMlI,IAA+B,iBAAb,EAC1B,MAAM,IAAIF,MAAM,aAAeggB,EAAa,uBAE9C,OAAO9f,GA2BPkgB,kBAfwB,SAAUvZ,EAASmZ,EAAYC,GACvD,IAAI/f,EAAS6f,EAAYlZ,EAASmZ,EAAYC,GAO9C,MANwB,iBAAb,IACM,SAAX/f,EAAmBA,GAAS,GACZ,UAAXA,GACW,IAAXA,KADoBA,GAAS,IAGxCA,IAAWA,GASXmgB,sBAzD4B,SAAUxZ,EAASmZ,EAAYC,GAC3D,IAAI/f,EAAS6f,EAAYlZ,EAASmZ,EAAYC,GAE9C,OADA/f,EAAS,IAAIhB,EAASgB,IAwDtBogB,sBA3C4B,SAAUzZ,EAASmZ,EAAYC,GAC3D,IAAI/f,EAAS6f,EAAYlZ,EAASmZ,EAAYC,GAE9C,OADA/f,EAAS,IAAIjB,EAASiB,IA0CtBqgB,0BArDgC,SAAU1Z,EAASmZ,EAAYC,GAE/D,OADaF,EAAYlZ,EAASmZ,EAAYC,GAChCha,KAAI,SAAUua,GAC1B,OAAO,IAAIthB,EAASshB,S,gBCxBxB,MAAMthB,EAAW,EAAQ,IACnB,IAACZ,GAAO,EAAQ,IAChB,aAACgK,GAAgB,EAAQ,GAMzBqB,EAAS,SAAU5D,EAAOwE,GAC9BxE,EAAQ,IAAI7G,EAAS6G,GACrBwE,EAAY,IAAIrL,EAASqL,GACzB/K,KAAKuG,MAAQA,EACbvG,KAAK+K,UAAYA,EAAUxJ,QAG7B4I,EAAOK,WAAa,SAAUK,EAAIC,GAChCD,EAAK,IAAInL,EAASmL,GAElB,IAAIE,GADJD,EAAK,IAAIpL,EAASoL,IACC9J,MAAM6J,GACzB,OAAO,IAAIV,EAAOU,EAAIE,IAGxBZ,EAAOiB,WAAa,SAAUP,EAAIC,GAChC,IAAIC,EAAYF,EAAGhI,OAAOrB,MAAMsJ,EAAGjI,QAC/BrG,EAAIuO,EAAUhL,SAClB,GAAIvD,EAAIsC,EACN,MAAM,IAAI0B,MAAM,mBAElBuK,EAAYA,EAAU9J,MAAM,EAAMzE,GAElC,IAGI8V,EAHA2O,EAAQziB,KAAKqC,IAAIkK,EAAUpL,GAC3BuhB,EAAQ1iB,KAAKqC,IAAIkK,EAAUnL,GAC3BuhB,EAAQ3iB,KAAKqC,IAAIkK,EAAUlL,GAE/B,GAAKohB,GAASC,GAAWD,GAASE,EAAQ,CAGxC,IAAI9jB,EAAIyL,EAAa+B,EAAGhI,OAAOjD,EAAGiL,EAAGhI,OAAOhD,EAAGiL,EAAGjI,OAAOjD,EAAGkL,EAAGjI,OAAOhD,EAAGgL,EAAGT,EAAGU,EAAGV,GAClFkI,EAAS,IAAI5S,EAAS,EAAGrC,EAAE,GAAIA,EAAE,SAC5B,GAAK6jB,GAASD,GAAWC,GAASC,EAAQ,CAE/C,IAAI9jB,EAAIyL,EAAa+B,EAAGhI,OAAOlD,EAAGkL,EAAGhI,OAAOhD,EAAGiL,EAAGjI,OAAOlD,EAAGmL,EAAGjI,OAAOhD,EAAGgL,EAAGT,EAAGU,EAAGV,GAClFkI,EAAS,IAAI5S,EAASrC,EAAE,GAAI,EAAGA,EAAE,QAC5B,CAEL,IAAIA,EAAIyL,EAAa+B,EAAGhI,OAAOlD,EAAGkL,EAAGhI,OAAOjD,EAAGkL,EAAGjI,OAAOlD,EAAGmL,EAAGjI,OAAOjD,EAAGiL,EAAGT,EAAGU,EAAGV,GAClFkI,EAAS,IAAI5S,EAASrC,EAAE,GAAIA,EAAE,GAAI,GAEpC,OAAO,IAAI8M,EAAOmI,EAAQvH,IAG5BZ,EAAOhM,UAAY,CACjBgN,mBAAoB,SAAU3H,GAG5B,IAAIwH,GAASxH,EAAM4G,EAAI5G,EAAMX,OAAO1B,IAAInB,KAAKuG,QAAU/C,EAAMX,OAAO1B,IAAInB,KAAK+K,WAE7E,OADY/K,KAAKuG,MAAMzF,KAAKd,KAAK+K,UAAU9J,MAAM+J,KAInDrK,MAAO,SAAUygB,GACf,OAAO,IAAIjX,EAAOnK,KAAKuG,MAAM5F,QAASX,KAAK+K,UAAUpK,UAGvD+F,QAAS,WACP,OAAO,IAAIyD,EAAOnK,KAAKuG,MAAM5F,QAASX,KAAK+K,UAAUnK,YAGvDmB,UAAW,SAAUF,GACnB,IAAIyc,EAAWte,KAAKuG,MAAM3E,YAAYC,GAGlCwf,EAFqBrhB,KAAKuG,MAAMzF,KAAKd,KAAK+K,WACCnJ,YAAYC,GAClBb,MAAMsd,GAC/C,OAAO,IAAInU,EAAOmU,EAAU+C,IAG9BC,mBAAoB,SAAU/a,GAE5B,IAAI9I,GADJ8I,EAAQ,IAAI7G,EAAS6G,IACPvF,MAAMhB,KAAKuG,OAAOpF,IAAInB,KAAK+K,WAAa/K,KAAK+K,UAAU5J,IAAInB,KAAK+K,WAE9E,OADmB/K,KAAKuG,MAAMzF,KAAKd,KAAK+K,UAAU9J,MAAMxD,KAI1D8jB,gBAAiB,SAAUhb,GACzBA,EAAQ,IAAI7G,EAAS6G,GACrB,IAAIib,EAAexhB,KAAKshB,mBAAmB/a,GAG3C,OAFqBA,EAAMvF,MAAMwgB,GACHzhB,UAIhC4B,OAAQ,SAAUuJ,GAChB,IAAKlL,KAAK+K,UAAUpJ,OAAOuJ,EAAOH,WAAY,OAAO,EAErD,QADe/K,KAAKuhB,gBAAgBrW,EAAO3E,OAC5BzH,KAKnB9C,EAAOD,QAAUoO,G,gBCnGjB,MAAM1K,EAAW,EAAQ,GACnB0D,EAAS,EAAQ,IACjBse,EAAU,EAAQ,GAClBpe,EAAU,EAAQ,IAClB,OAAC9D,GAAU,EAAQ,GAEnBiO,EAAO,SAAUyE,EAASC,GAC9B,KAAMD,aAAmB9O,GAAS,MAAM,IAAI3C,MAAM,oBAClD,KAAM0R,aAAmB/O,GAAS,MAAM,IAAI3C,MAAM,oBAClDR,KAAKiS,QAAUA,EACfjS,KAAKkS,QAAUA,GAGjB1E,EAAKlG,WAAa,SAAUC,GAC1B,IAAI0K,EAAU9O,EAAOmE,WAAWC,EAAI0K,SAChCC,EAAU/O,EAAOmE,WAAWC,EAAI2K,SACpC,OAAO,IAAI1E,EAAKyE,EAASC,IAG3B1E,EAAKyB,iBAAmB,SAAUvH,GAGhC,GAAIA,EAAQpE,SAASvD,OAAS,EAC5B,OAAO,KAET,IAAI2hB,EAAe,GACfC,EAAQja,EAAQpE,SAAS4L,QAAO,SAAU3O,EAAGhE,GAC/C,OAAIgE,EAAEqD,IAAI/D,EAAI,IACZ6hB,EAAa7c,KAAKtI,IACX,MAIRkK,KAAI,SAAUlG,GACb,OAAO,IAAId,EAASc,EAAEqD,IAAIjE,EAAGY,EAAEqD,IAAIhE,MAEvC,GAAqB,IAAjB+hB,EAAM5hB,OACR,MAAM,IAAIS,MAAM,+DAElB,IAAI3D,EAAI6kB,EAAa,GAAKA,EAAa,GACvC,GAAU,IAAN7kB,GAAiB,IAANA,EAKb,MAAM,IAAI2D,MAAM,8DAGlB,OAPY,IAAN3D,GACF8kB,EAAMjb,UAKG,IAAI8G,EAAK,IAAIrK,EAAOwe,EAAM,IAAK,IAAIxe,EAAOwe,EAAM,MAI/DnU,EAAKrP,UAAY,CACf6D,SAAU,WACR,OAAOhC,KAAKiS,QAAU,OAASjS,KAAKkS,SAGtCL,YAAa,SAAUF,EAAIC,GAEzB,MAAMtO,EAAW,CACf,IAAIme,EAAQzhB,KAAKiS,QAAQrO,IAAIhB,WAAW+O,IACxC,IAAI8P,EAAQzhB,KAAKkS,QAAQtO,IAAIhB,WAAW+O,IACxC,IAAI8P,EAAQzhB,KAAKkS,QAAQtO,IAAIhB,WAAWgP,IACxC,IAAI6P,EAAQzhB,KAAKiS,QAAQrO,IAAIhB,WAAWgP,KAE1C,OAAO,IAAIvO,EAAQC,IAGrBvB,UAAW,SAAUF,GACnB,IAAI+f,EAAQ5hB,KAAKiS,QAAQrO,IAAI7B,UAAUF,GACnCggB,EAAQ7hB,KAAKkS,QAAQtO,IAAI7B,UAAUF,GACvC,OAAO,IAAI2L,EAAK,IAAIrK,EAAOye,GAAQ,IAAIze,EAAO0e,KAGhD1c,QAAS,WACP,OAAO,IAAIqI,EAAKxN,KAAKkS,QAASlS,KAAKiS,UAGrClH,UAAW,WACT,OAAO/K,KAAKkS,QAAQtO,IAAI5C,MAAMhB,KAAKiS,QAAQrO,MAG7CrE,OAAQ,WACN,IAAImB,EAASV,KAAKqI,IAKlB,OAJK3H,IACHA,EAASnB,IACTS,KAAKqI,IAAM3H,GAENA,GAGTW,cAAe,WACb,IAAI1B,EAAIK,KAAKkS,QAAQtO,IAAIjE,EAAIK,KAAKiS,QAAQrO,IAAIjE,EAC1CC,EAAII,KAAKkS,QAAQtO,IAAIhE,EAAII,KAAKiS,QAAQrO,IAAIhE,EAC9C,OAAOD,EAAIA,EAAIC,EAAIA,GAGrBG,OAAQ,WACN,OAAOvB,KAAK8C,KAAKtB,KAAKqB,mBAI1BrF,EAAOD,QAAUyR,G,gBCrGjB,MAAM/N,EAAW,EAAQ,IACnB,IAACX,EAAG,SAAEC,GAAY,EAAQ,IAC1B,sBAAC+hB,EAAqB,mBAAEH,EAAkB,iBAAED,EAAgB,kBAAEE,GAAqB,EAAQ,KAC3F,oBAAChiB,GAAuB,EAAQ,GAChCuE,EAAS,EAAQ,IACjBqK,EAAO,EAAQ,IAcfsU,EAAS,SAAUra,EAAQ4X,GAE/B5X,EAASA,GAAU,GAGnB,IAAIO,EAAY,MAJhBqX,IAAWA,IAKI5X,EAAO1H,OAAS,IAC7BiI,EAAY,IAAIvI,EAASgI,EAAOA,EAAO1H,OAAS,KAElD,IAAIgiB,EAAY,GAChBta,EAAOhB,KAAI,SAAUF,GACnBA,EAAQ,IAAI9G,EAAS8G,GACrB,IAAIyb,GAAO,EACX,GAAkB,OAAdha,EAAoB,CAEtBga,EADezb,EAAM9E,WAAWuG,GACdlJ,EAEfkjB,GAAMD,EAAUld,KAAK0B,GAC1ByB,EAAYzB,KAEdvG,KAAKyH,OAASsa,EACd/hB,KAAKqf,OAASA,GAuBhByC,EAAOG,IAAM,SAAU5a,GACrB,IAAI+I,EAAS0Q,EAAsBzZ,EAAS,SAAU,GAClDlB,EAASwa,EAAmBtZ,EAAS,SAAU,GAC/C6a,EAAavB,EAAmBtZ,EAAS,aAAc,GACvD8a,EAAWxB,EAAmBtZ,EAAS,WAAY,KACnD6J,EAAawP,EAAiBrZ,EAAS,aAAczI,GACrDwjB,EAAcxB,EAAkBvZ,EAAS,eAAe,GAE5D,KAAO8a,EAAWD,GAAc,KAC9BC,GAAY,IAEd,KAAOA,EAAWD,IAAe,KAC/BC,GAAY,IAEd,IACI5b,EADAkB,EAAS,GAET4a,EAAc7jB,KAAKqC,IAAIshB,EAAWD,GACtC,GAAIG,EAActjB,EAChBwH,EAAQ9G,EAAS4C,UAAU6f,EAAa,IAAQ1jB,KAAKkE,IAAIzB,MAAMkF,GAC/DsB,EAAO5C,KAAK0B,EAAMzF,KAAKsP,QAClB,CACL,IAAIkS,EAAW9jB,KAAKgL,MAAM0H,EAAamR,EAAc,KAAO,EACxDE,EAA0B,GAAXD,EAAiBD,EAChCE,EAAe,MAAMA,EAAe,KACxC,IAAIC,EAAcJ,EAAeE,EAAW,EAAKA,EACjD,IAAK,IAAI/lB,EAAI,EAAGA,GAAKimB,EAAajmB,IAAK,CACrC,IAAIkmB,EAAOlmB,EACP6lB,IACFK,GAAQlmB,EAAI,IAAM+lB,EAAW,EAAIC,GAAgBD,EAAWC,EACxDE,EAAO,IAAGA,EAAO,GACjBA,EAAOH,IAAUG,EAAOH,IAE9B,IAAIvf,EAAQmf,EAAaO,GAAQN,EAAWD,GAAcI,EAC1D/b,EAAQ9G,EAAS4C,UAAUU,EAAQ,IAAQvE,KAAKkE,IAAIzB,MAAMkF,GAC1DsB,EAAO5C,KAAK0B,EAAMzF,KAAKsP,KAG3B,OAAO,IAAI0R,EAAOra,GAAQ,IAG5Bqa,EAAO3jB,UAAY,CACjB4c,OAAQ,SAAU2H,GAChB,GAAI1iB,KAAKqf,QAAUqD,EAAUrD,OAC3B,MAAM,IAAI7e,MAAM,4BAElB,IAAIuhB,EAAY/hB,KAAKyH,OAAOsT,OAAO2H,EAAUjb,QAC7C,OAAO,IAAIqa,EAAOC,IAQpBhT,UAAW,WACT,OAAO/O,KAAKyH,QAQdkb,YAAa,SAAUpc,GACrB,GAAIvG,KAAKqf,OACP,MAAM,IAAI7e,MAAM,2BAElB+F,EAAQ,IAAI9G,EAAS8G,GACrB,IAAIwb,EAAY/hB,KAAKyH,OAAOsT,OAAO,CAACxU,IACpC,OAAO,IAAIub,EAAOC,IAQpBa,aAAc,SAAUnb,GACtB,GAAIzH,KAAKqf,OACP,MAAM,IAAI7e,MAAM,2BAElB,IAAIuhB,EAAY/hB,KAAKyH,OAIrB,OAHAA,EAAO9C,SAAQ,SAAU4B,GACvBwb,EAAUld,KAAK,IAAIpF,EAAS8G,OAEvB,IAAIub,EAAOC,IAGpBc,MAAO,WACL,OAAO,IAAIf,EAAO9hB,KAAKyH,QAAQ,IAOjCqH,SAAU,WACR,OAAO9O,KAAKqf,QAQdyD,QAAS,WACP,MAAMrb,EAASzH,KAAKyH,OACpB,IAAIsb,EAAa,EACbC,EAAOvb,EAAO1H,OAAS,EAC3B,IAAK,IAAIkjB,EAAU,EAAGA,EAAUxb,EAAO1H,OAAQijB,EAAOC,IACpDF,GAActb,EAAOub,GAAMrjB,EAAI8H,EAAOwb,GAASrjB,EAAI6H,EAAOub,GAAMpjB,EAAI6H,EAAOwb,GAAStjB,EAEtF,OAAIojB,EAAa,EACR,YACEA,EAAa,EACf,oBAEA,YASXG,mBAAoB,SAAUC,EAAOC,EAAQlS,GAK3C,OAJUlR,KAAKqjB,YAAYF,EAAQ,EAAGjS,GACrBpM,QAAQ,CACvBc,OAAQ,CAAC,EAAG,EAAGwd,MAOnBC,YAAa,SAAUC,EAAYpS,GACjC,MAAMlK,EAAM,EAAQ,GACpB,IAIIoH,EAJApE,EAAQ,GACRuZ,EAAYvjB,KAAKyH,OAAO1H,OACxByjB,EAAa,EACbxjB,KAAKqf,QAAWkE,EAAY,IAAIC,GAAc,GAElD,IAAK,IAAIjnB,EAAIinB,EAAYjnB,EAAIgnB,EAAWhnB,IAAK,CAC3C,IAAIknB,EAAalnB,EACbknB,EAAa,IAAGA,EAAaF,EAAY,GAC7C,IAAIhd,EAAQvG,KAAKyH,OAAOgc,GACpB5c,EAAS,IAAI1D,EAAOoD,GACxB,GAAIhK,EAAIinB,EAAY,CAClB,IAAI5U,EAAO,IAAIpB,EAAKY,EAAYvH,GAChCmD,EAAMnF,KAAK+J,GAEbR,EAAavH,EAIf,OAFeG,EAAI8G,UAAU9D,GACLiH,cAAcqS,EAAYpS,IAIpDwS,WAAY,WACV,MAAM1c,EAAM,EAAQ,GACpB,IAAKhH,KAAKqf,OAAQ,MAAM,IAAI7e,MAAM,8BAClC,OAAOwG,EAAIwD,WAAWxK,KAAKyH,SAG7B1F,UAAW,SAAUF,GACnB,IAAIkgB,EAAY/hB,KAAKyH,OAAOhB,KAAI,SAAUF,GACxC,OAAOA,EAAM3E,YAAYC,MAE3B,OAAO,IAAIigB,EAAOC,EAAW/hB,KAAKqf,SAsBpCsE,aAAc,SAAUC,EAAevc,GAIrC,GAHIvH,UAAUC,OAAS,IACrBsH,EAAU,IAERrH,KAAKqf,OACP,MAAM,IAAI7e,MAAM,2BAElB,KAAMojB,aAAyBtjB,OAC7B,MAAM,IAAIE,MAAM,wDAElB,GAAIojB,EAAc7jB,OAAS,EACzB,MAAM,IAAIS,MAAM,+CAElB,GAAIR,KAAKyH,OAAO1H,OAAS,EACvB,MAAM,IAAIS,MAAM,iIAElB,IAAI0Q,EAAawP,EAAiBrZ,EAAS,aAAczI,GACrDsS,EAAa,IAAGA,EAAa,GACjC,IAAI2S,EAAa,GACbC,EAAsB,GAC1BA,EAAoBjf,KAAK7E,KAAKyH,OAAOzH,KAAKyH,OAAO1H,OAAS,IAC1D,IAAK,IAAIxD,EAAI,EAAGA,EAAIqnB,EAAc7jB,SAAUxD,EAAG,CAC7C,IAAI8B,EAAIulB,EAAcrnB,GACtB,GAAU,OAAN8B,EAAY,CAEd,GAAU,IAAN9B,EACF,MAAM,IAAIiE,MAAM,oEAElB,GAAIojB,EAAc7jB,OAAS,EACzB,MAAM,IAAIS,MAAM,qFAElB,IAAIujB,EACJ,GAAI,2BAA4B/jB,KAC9B+jB,EAAyB/jB,KAAK+jB,2BACzB,CACL,GAAI/jB,KAAKyH,OAAO1H,OAAS,EACvB,MAAM,IAAIS,MAAM,yIAElBujB,EAAyB/jB,KAAKyH,OAAOzH,KAAKyH,OAAO1H,OAAS,GAG5D1B,EAAI2B,KAAKyH,OAAOzH,KAAKyH,OAAO1H,OAAS,GAAGkB,MAAM,GAAGD,MAAM+iB,QAEvD1lB,EAAI,IAAIoB,EAASpB,GAEnBylB,EAAoBjf,KAAKxG,GAE3B,IAAI2lB,EAAcF,EAAoB/jB,OAAS,EAC3CkkB,EAAO,EACX,IAAK,IAAI1nB,EAAI,EAAGA,GAAKynB,IAAeznB,EAC9BA,EAAI,IAAG0nB,GAAQ1nB,GACnBsnB,EAAWhf,KAAKof,GAElB,IAAIC,EAAY,GAChB,IAAK,IAAI3nB,EAAI,EAAGA,GAAKynB,IAAeznB,EAAG,CACrC,IAAI4nB,EAAWN,EAAWG,IAAgBH,EAAWtnB,GAAKsnB,EAAWG,EAAcznB,IACnF2nB,EAAUrf,KAAKsf,GAEjB,IAAIC,EAAe,SAAU3mB,GAC3B,IAAI4mB,EAAM,EACNC,EAAwB9lB,KAAK+lB,IAAI,EAAI9mB,EAAGumB,GACxCQ,EAAuB,IAAN/mB,EAAY,GAAK,EAAIA,GAAM,EAC5C8I,EAAQ,IAAI9G,EAAS,EAAG,GAC5B,IAAK,IAAIglB,EAAI,EAAGA,GAAKT,IAAeS,EAAG,CACjCA,IAAMT,IAAaM,EAAwB,GAC/C,IAAII,EAAwBR,EAAUO,GAAKJ,EAAMC,EACjD/d,EAAQA,EAAMzF,KAAKgjB,EAAoBW,GAAGxjB,MAAMyjB,IAChDL,GAAO5mB,EACP6mB,GAAyBE,EAE3B,OAAOje,GAELwb,EAAY,GACZ4C,EAAc,GACdrC,EAAW0B,EAAc,EAC7B,IAAK,IAAIznB,EAAI,EAAGA,EAAI+lB,IAAY/lB,EAAG,CACjC,IAAIkB,EAAIlB,GAAK+lB,EAAW,GACpB/b,EAAQ6d,EAAa3mB,GACzBskB,EAAUld,KAAK0B,GACfoe,EAAY9f,KAAKpH,GAGnB,IAAImnB,EAAgB,EAChBC,EAAqB,EAAVrmB,KAAKkE,GAASwO,EACzB4T,EAActmB,KAAKC,IAAIomB,GAC3B,KAAOD,EAAgB7C,EAAUhiB,OAAS,GAAG,CAC3C,IAAIglB,EAAOhD,EAAU6C,GAAe5jB,MAAM+gB,EAAU6C,EAAgB,IAAIrjB,OACpEyjB,EAAOjD,EAAU6C,EAAgB,GAAG5jB,MAAM+gB,EAAU6C,IAAgBrjB,OACpE0jB,EAAWF,EAAKvjB,MAAMwjB,GAC1B,GAAIxmB,KAAKqC,IAAIokB,GAAYH,EAAa,CAEpC,IAAII,EAAKP,EAAYC,EAAgB,GACjCO,EAAKR,EAAYC,EAAgB,GACjCQ,EAASF,EAAiB,GAAXC,EAAKD,GAAU,EAC9BG,EAASH,EAAiB,GAAXC,EAAKD,GAAU,EAC9BI,EAAalB,EAAagB,GAC1BG,EAAanB,EAAaiB,GAE9BtD,EAAUtY,OAAOmb,EAAe,EAAGU,EAAYC,GAC/CZ,EAAYlb,OAAOmb,EAAe,EAAGQ,EAAQC,GAE7CT,IACIA,EAAgB,IAAGA,EAAgB,SAErCA,EAIN7C,EAAY/hB,KAAKyH,OAAOsT,OAAOgH,EAAU3Z,MAAM,IAC/C,IAAI1H,EAAS,IAAIohB,EAAOC,GAExB,OADArhB,EAAOqjB,uBAAyBD,EAAoBA,EAAoB/jB,OAAS,GAC1EW,GAwBT8kB,UAAW,SAAUC,EAAUpe,GAC7B,IAAIqe,EAAW,IAIf,GAHI5lB,UAAUC,OAAS,IACrBsH,EAAU,IAERrH,KAAKqf,OACP,MAAM,IAAI7e,MAAM,2BAElB,GAAIR,KAAKyH,OAAO1H,OAAS,EACvB,MAAM,IAAIS,MAAM,qHAElB,IAEImlB,EAASC,EAFT1U,EAAawP,EAAiBrZ,EAAS,aAAczI,GAGzD,GAFIsS,EAAa,IAAGA,EAAa,GAE5B,YAAa7J,GAAa,YAAaA,EAAU,CACpD,GAAI,WAAYA,EACd,MAAM,IAAI7G,MAAM,8EAElBmlB,EAAUhF,EAAmBtZ,EAAS,UAAW,GACjDue,EAAUjF,EAAmBtZ,EAAS,UAAW,QAEjDse,EAAUhF,EAAmBtZ,EAAS,SAAU,GAChDue,EAAUD,EAEZ,IAAIE,EAAgBlF,EAAmBtZ,EAAS,gBAAiB,GAC7Dye,EAAYlF,EAAkBvZ,EAAS,aAAa,GACpD0e,EAAWnF,EAAkBvZ,EAAS,SAAS,GAC/C2e,EAAahmB,KAAKyH,OAAOzH,KAAKyH,OAAO1H,OAAS,GAClD0lB,EAAW,IAAIhmB,EAASgmB,GAExBE,EAAUnnB,KAAKynB,MAAMN,EAAUD,GAAYA,EAC3CE,EAAUpnB,KAAKynB,MAAML,EAAUF,GAAYA,EAC3CD,EAAW,IAAIhmB,EAASjB,KAAKynB,MAAMR,EAAS9lB,EAAI+lB,GAAYA,EAAUlnB,KAAKynB,MAAMR,EAAS7lB,EAAI8lB,GAAYA,GAE1G,IAAIQ,GAAaJ,EACb/D,EAAY,GAChB,GAAiB,IAAZ4D,GAA+B,IAAZC,EAGtB7D,EAAUld,KAAK4gB,OACV,CACLE,EAAUnnB,KAAKqC,IAAI8kB,GACnBC,EAAUpnB,KAAKqC,IAAI+kB,GAGnB,IAAIO,EAAMN,EAAgBrnB,KAAKkE,GAAK,IAChC0jB,EAAS5nB,KAAKmE,IAAIwjB,GAClBE,EAAS7nB,KAAKC,IAAI0nB,GAClBG,EAAoBN,EAAWhlB,MAAMykB,GAAUxkB,MAAM,IAGrDtB,EAAInB,KAAKynB,OAAOG,EAASE,EAAkB3mB,EAAI0mB,EAASC,EAAkB1mB,GAAK8lB,GAAYA,EAC3F9lB,EAAIpB,KAAKynB,QAAQI,EAASC,EAAkB3mB,EAAIymB,EAASE,EAAkB1mB,GAAK8lB,GAAYA,EAC5Fa,EAAkB,IAAI9mB,EAASE,EAAGC,GAElC4mB,EAAaD,EAAgB5mB,EAAI4mB,EAAgB5mB,GAAMgmB,EAAUA,GAAYY,EAAgB3mB,EAAI2mB,EAAgB3mB,GAAMgmB,EAAUA,GACrI,GAAIY,EAAY,EAAK,CAEnB,IAAIC,EAAgBjoB,KAAK8C,KAAKklB,GAC9Bb,GAAWc,EACXb,GAAWa,EAEXd,EAAUnnB,KAAKynB,MAAMN,EAAUD,GAAYA,EAC3CE,EAAUpnB,KAAKynB,MAAML,EAAUF,GAAYA,EAG7C,IAAIgB,EAAcloB,KAAK8C,MAAMqkB,EAAUA,EAAUC,EAAUA,EAAUD,EAAUA,EAAUY,EAAgB3mB,EAAI2mB,EAAgB3mB,EAAIgmB,EAAUA,EAAUW,EAAgB5mB,EAAI4mB,EAAgB5mB,IAAMgmB,EAAUA,EAAUY,EAAgB3mB,EAAI2mB,EAAgB3mB,EAAIgmB,EAAUA,EAAUW,EAAgB5mB,EAAI4mB,EAAgB5mB,IAC/SumB,IAAcH,IAAUW,GAAeA,GAC3C,IAAIC,EAAmB,IAAIlnB,EAASkmB,EAAUY,EAAgB3mB,EAAIgmB,GAAUA,EAAUW,EAAgB5mB,EAAIgmB,GAAS1kB,MAAMylB,GAErHtW,EAAS,IAAI3Q,EAAS2mB,EAASO,EAAiBhnB,EAAI0mB,EAASM,EAAiB/mB,EAAGymB,EAASM,EAAiBhnB,EAAIymB,EAASO,EAAiB/mB,GAAGkB,KAAMklB,EAAWllB,KAAK2kB,GAAWxkB,MAAM,KAEnL2lB,EAAO,IAAInnB,GAAU8mB,EAAgB5mB,EAAIgnB,EAAiBhnB,GAAKgmB,GAAUY,EAAgB3mB,EAAI+mB,EAAiB/mB,GAAKgmB,GACnHxM,EAAO,IAAI3Z,IAAW8mB,EAAgB5mB,EAAIgnB,EAAiBhnB,GAAKgmB,IAAWY,EAAgB3mB,EAAI+mB,EAAiB/mB,GAAKgmB,GACrHiB,EAASD,EAAK5jB,eAEd8jB,EADS1N,EAAKpW,eACQ6jB,EAC1BC,GAA2B,EAAItoB,KAAKkE,IAC9BwjB,GAAeY,EAAa,EAChCA,GAAc,EAAItoB,KAAKkE,GACd,GAAgBokB,EAAa,IACtCA,GAAc,EAAItoB,KAAKkE,IAIzB,IAAI4f,EAAW9jB,KAAKuoB,KAAKvoB,KAAKqC,IAAIimB,IAAe,EAAItoB,KAAKkE,IAAMwO,GAAc,EAC1EoR,EAAW,IAAGA,EAAW,GAC7B,IAAK,IAAIG,EAAO,EAAGA,GAAQH,EAAUG,IAAQ,CAC3C,IAAIuE,EAAQH,EAASpE,EAAOH,EAAWwE,EACnCG,EAAWzoB,KAAKmE,IAAIqkB,GACpBE,EAAW1oB,KAAKC,IAAIuoB,GAEpBzgB,EAAQ,IAAI9G,EAAS2mB,EAAST,EAAUsB,EAAWZ,EAAST,EAAUsB,EAAUb,EAASV,EAAUsB,EAAWb,EAASR,EAAUsB,GAAUpmB,KAAKsP,GACpJ2R,EAAUld,KAAK0B,IAGnBwb,EAAY/hB,KAAKyH,OAAOsT,OAAOgH,GAC/B,IAAIrhB,EAAS,IAAIohB,EAAOC,GACxB,OAAOrhB,IAIX1E,EAAOD,QAAU+lB,G,gBCzZjB,MAAM,oCAACqF,EAAmC,wBAAEC,GAA2B,EAAQ,IAC/E,IAAI5M,EAAM,EAAQ,IACdxT,EAAM,EAAQ,GAGlB,MAAM,UACJrI,EAAS,oBACTC,EAAmB,oBACnBC,EAAmB,IACnBC,EAAG,SACHC,EAAQ,QACRR,EAAO,IACPS,EAAG,IACHC,EAAG,OACHC,EAAM,KACNC,EAAI,MACJC,EAAK,MACLC,EAAK,KACLC,EAAI,UACJZ,EAAS,OACTa,GACE,EAAQ,GAEZib,EAAI7b,UAAYA,EAChB6b,EAAI5b,oBAAsBA,EAC1B4b,EAAI3b,oBAAsBA,EAC1B2b,EAAI1b,IAAMA,EACV0b,EAAIzb,SAAWA,EACfyb,EAAIjc,QAAUA,EACdic,EAAIxb,IAAMA,EACVwb,EAAIvb,IAAMA,EACVub,EAAItb,OAASA,EACbsb,EAAIrb,KAAOA,EACXqb,EAAIpb,MAAQA,EACZob,EAAInb,MAAQA,EACZmb,EAAIlb,KAAOA,EACXkb,EAAI9b,UAAYA,EAChB8b,EAAIjb,OAASA,EAGbib,EAAI/a,SAAW,EAAQ,GACvB+a,EAAI9a,SAAW,EAAQ,GACvB8a,EAAIrX,OAAS,EAAQ,GACrB6D,EAAI7D,OAAS,EAAQ,IACrBqX,EAAI9W,MAAQ,EAAQ,GACpB8W,EAAInX,QAAU,EAAQ,GACtBmX,EAAIzO,UAAY,EAAQ,IACxByO,EAAI9B,OAAS,EAAQ,IACrB8B,EAAIrQ,OAAS,EAAQ,IACrBqQ,EAAIsH,OAAS,EAAQ,IACrBtH,EAAIpF,iBAAmB,EAAQ,IAC/BoF,EAAIpX,UAAY,EAAQ,IAExB4D,EAAIwG,KAAO,EAAQ,IAEnBgN,EAAIhL,UAAY,EAAQ,IAAqBA,UAC7CgL,EAAI+D,cAAgB,EAAQ,IAAqBA,cACjD/D,EAAIR,WAAa,EAAQ,IAEzB,MAAM,OAACqN,EAAM,QAAEC,EAAO,UAAEC,EAAS,iBAAEC,GAAoB,EAAQ,KACzD,OAACC,EAAM,KAAEC,EAAI,YAAEC,EAAW,SAAEC,EAAQ,gBAAEC,EAAe,iBAAEC,EAAgB,WAAEC,GAAc,EAAQ,IAErGvN,EAAIiN,OAASA,EACbjN,EAAIkN,KAAOA,EACXlN,EAAImN,YAAcA,EAClBnN,EAAIoN,SAAWA,EACfpN,EAAIqN,gBAAkBA,EACtBrN,EAAIsN,iBAAmBA,EACvBtN,EAAIuN,WAAaA,EAEjB/gB,EAAIqgB,OAASA,EACbrgB,EAAIsgB,QAAUA,EACdtgB,EAAIugB,UAAYA,EAChBvgB,EAAIwgB,iBAAmBA,EAGvB,MAAM,aAACxiB,EAAY,kBAAEqH,EAAiB,WAAE/E,EAAU,WAAE8E,GAAc,EAAQ,GAC1EoO,EAAInO,kBAAoBA,EACxBmO,EAAIlT,WAAaA,EACjBkT,EAAIpO,WAAaA,EACjBoO,EAAIxV,aAAeA,EAEnB,MAAMgjB,EAAe,EAAQ,GAC7BhhB,EAAI8G,UAAYka,EAAala,UAC7B9G,EAAIM,WAAa0gB,EAAa1gB,WAC9BN,EAAIwD,WAAawd,EAAaxd,WAC9BxD,EAAIC,kBAAoB+gB,EAAa/gB,kBACrCD,EAAI6H,UAAYmZ,EAAanZ,UAC7B7H,EAAIgI,YAAcgZ,EAAahZ,YAC/BhI,EAAIqF,kBAAoB2b,EAAa3b,kBAIrC,MAAM4b,EAAiB,EAAQ,IAG/Bd,EAAoC3M,EAAIrc,WACxCgpB,EAAoC3M,EAAI/a,SAAStB,WACjDgpB,EAAoC3M,EAAI9a,SAASvB,WACjDgpB,EAAoC3M,EAAIrX,OAAOhF,WAC/CgpB,EAAoC3M,EAAI9W,MAAMvF,WAC9CgpB,EAAoC3M,EAAInX,QAAQlF,WAChDgpB,EAAoC3M,EAAI9B,OAAOva,WAC/CgpB,EAAoC3M,EAAIrQ,OAAOhM,WAC/CgpB,EAAoC3M,EAAIsH,OAAO3jB,WAC/CgpB,EAAoC3M,EAAIpF,iBAAiBjX,WACzDgpB,EAAoC3M,EAAIhL,UAAUrR,WAElDgpB,EAAoCngB,EAAI7I,WACxCgpB,EAAoCngB,EAAIwG,KAAKrP,WAC7CgpB,EAAoCngB,EAAI7D,OAAOhF,WAE/Cqc,EAAIsG,sBAAwBmH,EAAepH,sBAC3CrG,EAAIqG,sBAAwBoH,EAAepH,sBAC3CrG,EAAIuG,0BAA4BkH,EAAelH,0BAC/CvG,EAAIoG,kBAAoBqH,EAAerH,kBACvCpG,EAAImG,mBAAqBsH,EAAetH,mBACxCnG,EAAIkG,iBAAmBuH,EAAevH,iBAEtClG,EAAIzO,UAAU5N,UAAY6I,EAAI7I,UAG9B,MAAM,MAAC4L,EAAK,MAAEE,GAAS,EAAQ,GAEzBie,EAAYjrB,OAAOoV,OAAO,GAAI,CAACmI,MAAKxT,OAAMihB,EAAgB,CAACle,QAAOE,UAExEjO,EAAOD,QAAUmsB,G,gBChNjB,MAAMzoB,EAAW,EAAQ,IACnB,aAACqJ,GAAgB,EAAQ,GAUzB4P,EAAS,SAAU7V,EAAQuH,GAC/BvH,EAAS,IAAIpD,EAASoD,GACtBuH,EAAIlK,WAAWkK,GACf,IAAI5N,EAAIqG,EAAO9C,SAEfqK,GAAK5N,EACLqG,EAASA,EAAO5B,MAAM,EAAMzE,GAC5BwD,KAAK6C,OAASA,EACd7C,KAAKoK,EAAIA,GAGXsO,EAAOlO,WAAa,SAAUK,EAAIC,GAChCD,EAAK,IAAIpL,EAASoL,GAElB,IACIhI,GAFJiI,EAAK,IAAIrL,EAASqL,IACC9J,MAAM6J,GACFhI,SAASjC,UAAUW,OACtC6I,EAAIS,EAAG1J,IAAI0B,GACf,OAAO,IAAI6V,EAAO7V,EAAQuH,IAG5BsO,EAAOva,UAAY,CAEjBuI,QAAS,WACP,OAAO,IAAIgS,EAAO1Y,KAAK6C,OAAOjC,WAAYZ,KAAKoK,IAGjDzI,OAAQ,SAAUnF,GAChB,OAAQA,EAAEqG,OAAOlB,OAAO3B,KAAK6C,SAAYrG,EAAE4N,IAAMpK,KAAKoK,GAGxDkI,OAAQ,WACN,OAAOtS,KAAK6C,OAAO5B,MAAMjB,KAAKoK,IAGhCW,UAAW,WACT,OAAO/K,KAAK6C,OAAOA,UAGrBslB,KAAM,SAAUvoB,GAId,OADSI,KAAKoK,EAAIpK,KAAK6C,OAAO1C,GAAKP,GAAKI,KAAK6C,OAAOlD,GAItDyoB,mBAAoB,SAAU7hB,GAE5B,IAAI8hB,GADJ9hB,EAAQ,IAAI9G,EAAS8G,IACMpF,IAAInB,KAAK6C,QAEpC,OADerE,KAAKqC,IAAIwnB,EAAiBroB,KAAKoK,IAYhDa,kBAAmB,SAAUwO,GAC3B,IAAIlT,EAAQuC,EAAa9I,KAAK6C,OAAOlD,EAAGK,KAAK6C,OAAOjD,EAAG6Z,EAAO5W,OAAOlD,EAAG8Z,EAAO5W,OAAOjD,EAAGI,KAAKoK,EAAGqP,EAAOrP,GAExG,OADA7D,EAAQ,IAAI9G,EAAS8G,GACdA,GAGTxE,UAAW,SAAUF,GACnB,IAAIyQ,EAAS,IAAI7S,EAAS,EAAG,GACzB6oB,EAAetoB,KAAK6C,OAAO5B,MAAMjB,KAAKoK,GACtCme,EAAYjW,EAAO1Q,YAAYC,GAE/B2mB,EADsBxoB,KAAK6C,OAAOjB,YAAYC,GACdb,MAAMunB,GACtCE,EAAkBH,EAAa1mB,YAAYC,GAC3C6mB,EAAOF,EAAUrnB,IAAIsnB,GACzB,OAAO,IAAI/P,EAAO8P,EAAWE,KAIjC1sB,EAAOD,QAAU2c,G,8ECpFjB,YAAQ,EAAA9K,MAAA,EAAAA,MACR,YAAQ,EAAAC,WAAA,EAAAA,WACR,YAAQ,EAAA8a,aAAA,EAAAA,c,gBCPR,MAAM,IAAC7pB,EAAG,oBAAED,GAAuB,EAAQ,GACrCuW,EAAmB,EAAQ,KAC3B,sBAACyL,EAAqB,kBAAED,EAAiB,mBAAED,EAAkB,iBAAED,GAAoB,EAAQ,IAC3FhhB,EAAW,EAAQ,GAEnBkpB,GADW,EAAQ,GACT,EAAQ,KAClB9G,EAAS,EAAQ,KACjB,UAACtS,GAAa,EAAQ,KACtB,aAACxK,GAAgB,EAAQ,IACzB,iBAAC6jB,EAAgB,MAAEC,EAAK,8BAAEC,EAA6B,kBAAEC,GAAqB,EAAQ,KACtF,WAACxe,GAAc,EAAQ,GAavBwF,EAA4B,SAAUjC,EAAKqD,EAAkBC,EAAOhK,GAExE,KAAM+J,aAA4BgE,GAChC,MAAM,IAAI5U,MAAM,oEAElB,IAAIyoB,EAAWlb,EAAIjJ,QAAQ,CACzBc,OAAQ,CAAC,EAAG,EAAGyL,KAEbuP,EAAkBvZ,EAAS,eAAe,KAC5C4hB,EAAWA,EAAS5jB,UAAU,CAAC,EAAG,GAAIgM,EAAQ,KAEhD,IAAImL,EAASpL,EAAiB+G,6BAE9B,OADA8Q,EAAWA,EAASlnB,UAAUya,GACvByM,GA+TTjtB,EAAOD,QAAU,CACfiU,4BACAC,eAnTqB,SAAUlC,EAAKuD,EAAOC,EAAOF,EAAOhK,GACzD,OAAO2I,EAA0BjC,EAAKqH,EAAiByD,aAAavH,EAAOC,GAAQF,EAAOhK,IAmT1FvC,QAtSc,SAAUiJ,EAAK1G,GAC7B,MAAMmT,EAAM,EAAQ,IACpB,GAAyB,IAArBzM,EAAI/D,MAAMjK,OAEZ,OAAO,IAAIya,EAEb,IAAI0O,EAAerI,EAAsBxZ,EAAS,SAAU,CAAC,EAAG,EAAG,IAC/D8hB,EAAaxI,EAAmBtZ,EAAS,aAAc,GACvD+hB,EAAa1I,EAAiBrZ,EAAS,aAAcxI,GACzD,GAAuB,IAAnBqqB,EAAarpB,EACf,MAAM,IAAIW,MAAM,0CAEC,IAAf2oB,GAAoBC,EAAa,KACnCA,EAAa,GAEf,IAAIzW,EAAejT,EAASe,OAAO,EAAG,EAAG,GAErCyJ,EAAW,GAEfA,EAAWA,EAAS6Q,OAAOhN,EAAIqE,iBAAiB,CAC5CvM,YAAa,CAAC,EAAG,EAAG,GACpB8M,aAAcA,EACdxN,UAAW+jB,EAAarpB,EAAI,MAGhCqK,EAAWA,EAAS6Q,OAAOhN,EAAIqE,iBAAiB,CAC9CvM,YAAaqjB,EACbvW,aAAcA,EAAa4M,QAAQ4J,GACnChkB,QAAS+jB,EAAarpB,EAAI,KAG5B,IAAK,IAAItD,EAAI,EAAGA,EAAI6sB,EAAY7sB,IAAK,CACnC,IAAI8sB,EAAK,IAAI7Z,EAAU0Z,EAAajoB,MAAM1E,EAAI6sB,GAAa,CAAC,EAAG,EAAGF,EAAarpB,GAC7E8S,EAAa4M,QAAQhjB,EAAI4sB,EAAaC,IACpCE,EAAK,IAAI9Z,EAAU0Z,EAAajoB,OAAO1E,EAAI,GAAK6sB,GAAa,CAAC,EAAG,EAAGF,EAAarpB,GACnF8S,EAAa4M,SAAShjB,EAAI,GAAK4sB,EAAaC,IAC9Clf,EAAWA,EAAS6Q,OAAOhN,EAAIqF,gBAAgB,CAACE,aAAc+V,EAAI9V,aAAc+V,GAAK/sB,IAGvF,OAAOyI,EAAakF,IAgQpBqf,eAlMF,SAAwBC,EAAQC,GAC9B,MAOM,OAACrG,EAAM,MAAEsG,EAAK,OAAEC,EAAM,OAAEvZ,GAAUnT,OAAOoV,OAAO,GAPrC,CACf+Q,OAAQ,EACRuG,OAAQ,GACRD,MAAO,EACPtZ,QAAQ,GAG0DoZ,GAGpE,IAAII,EAASH,EAAU3kB,QAAQ,CAACc,OAAQ,CAAC,EAAG,EAAGwd,GAAS+F,WAAYO,EAAON,WAAYO,IACvF,IAAe,IAAXvZ,EAAiB,CACnB,MAAM3H,EAAImhB,EAAO9Z,YACXlK,EAAU6C,EAAE,GAAG3H,KAAK2H,EAAE,IAAKxH,OAAO,IACxC2oB,EAASA,EAAOvkB,UAAUO,GAE5B,OAAOgkB,GAkLPC,eAlKF,SAAwBL,EAAQC,GAE9B,MAAMK,EAAW,CACfC,GAAI,GACJC,WAAY,EACZjnB,MAAO,IACPknB,SAAU,OAEZT,EAASvsB,OAAOoV,OAAO,GAAIyX,EAAUN,GACrC,IAAI,GAACO,EAAE,WAAEC,EAAU,MAAEjnB,EAAK,SAAEknB,GAAYT,EACxC,GAAiB,QAAbS,EACF,MAAM,IAAIzpB,MAAM,qDAGdV,UAAUC,OAAS,IACrB0pB,EAAYD,GAGd,MAAMrkB,EAAUpC,EAAQ,EAElBmnB,EAAa/kB,EAAU2jB,EAAOkB,EAAajnB,EAAQ,EAAG,KAAO+lB,EAAOkB,EAAajnB,GAAS,IAAK,GAG/FonB,EAAW3rB,KAAK4D,IACpB5D,KAAKgL,MAAMhL,KAAKqC,IAAIqpB,GAAc,IAClC,EACAH,GAGIK,EAAmB,KAEzB,IAAIC,EAAcxB,EAAiBY,GAcnC,MAAMa,EAAsBD,EAAYnb,OAAOvP,GAAKA,EAAE,GAAK,GACrD4qB,EAAsBF,EAAYnb,OAAOvP,GAAKA,EAAE,IAAM,GACtD6qB,EAA0BF,EAAoBvqB,OAAS,GAAKwqB,EAAoBxqB,OAAS,EAE3FyqB,GAAwC,QAAbP,IACzBK,EAAoBvqB,OAASwqB,EAAoBxqB,OACnDsqB,EAAcA,EAAY5jB,KAAI,SAAUF,GACtC,MAAO,CAAC/H,KAAK2D,IAAIoE,EAAM,GAAI,GAAIA,EAAM,OAE9BgkB,EAAoBxqB,QAAUuqB,EAAoBvqB,SAC3DsqB,EAAcA,EAAY5jB,KAAI,SAAUF,GACtC,MAAO,CAAC/H,KAAK4D,IAAImE,EAAM,GAAI,GAAIA,EAAM,SAQ3C,IAAI2D,EAAW,GAGf,IAAK,IAAI3N,EAAI,EAAGA,EAAI4tB,EAAW,EAAG5tB,IAAK,CAErC,IAAK,IAAI+X,EAAI,EAAGA,EAAI+V,EAAYtqB,OAAS,EAAGuU,IAAK,CAE/C,MAAMmW,EAAWJ,EAAY/V,GACvBoW,EAAYL,EAAY/V,EAAI,GAGlC,IAAIqW,EAAa/B,EAAQhR,WAAWrb,EAAI,GAAK4tB,EAAWpnB,EAAQinB,GAC5DY,EAAYhC,EAAQhR,UAAUrb,EAAI4tB,EAAWpnB,EAAQinB,GAEzD,MAAMa,EAAS9B,EAA8B4B,EAAY,CAACF,EAAS,GAAI,EAAGA,EAAS,KAC7EK,EAAU/B,EAA8B6B,EAAW,CAACH,EAAS,GAAI,EAAGA,EAAS,KAC7EM,EAAShC,EAA8B4B,EAAY,CAACD,EAAU,GAAI,EAAGA,EAAU,KAC/EM,EAAUjC,EAA8B6B,EAAW,CAACF,EAAU,GAAI,EAAGA,EAAU,KAGrF,IAAIO,GAAoB,EACpBzsB,KAAKqC,IAAIgqB,EAAO,GAAKC,EAAQ,IAAMV,GAAoB5rB,KAAKqC,IAAIkqB,EAAO,GAAKC,EAAQ,IAAMZ,IAE5Fa,GAAoB,GASlB9lB,GAEF+E,EAASrF,KAAKmkB,EAAkB,CAAC6B,EAAQE,EAAQC,KAC5CC,GACH/gB,EAASrF,KAAKmkB,EAAkB,CAACgC,EAASF,EAASD,OAIhDI,GACH/gB,EAASrF,KAAKmkB,EAAkB,CAAC6B,EAAQC,EAASE,KAEpD9gB,EAASrF,KAAKmkB,EAAkB,CAACgC,EAASD,EAAQF,MAItD,GAAIrsB,KAAKqC,IAAIkC,GAAS,IAAK,CAEzB,MAAMmoB,EAAY1gB,EAAW6f,GACvBc,EAAYvC,EAAQlR,UAAU,IAAIpC,SACtCsT,EAAQhR,WAAWoS,IAEfoB,EAASF,EAAU9Y,iBAAiB,CAACjN,QAASA,IACjDsB,IAAI9G,GAAKA,EAAEoC,UAAUopB,IAElBE,EAAczC,EAAQlR,UAAU,IAAIpC,SACxCsT,EAAQhR,WAAW7U,EAAQinB,IAEvBsB,EAAWJ,EAAU9Y,iBAAiB,CAACjN,SAAUA,IACpDsB,IAAI9G,GAAKA,EAAEoC,UAAUspB,IACxBnhB,EAAWA,EAAS6Q,OAAOqQ,GAAQrQ,OAAOuQ,IAG9C,OAAOtmB,EAAakF,GAAUwG,eAAerC,iBAmC7C6B,cAvPoB,SAAUnC,EAAK1G,QACnB4G,IAAZ5G,IACFA,EAAU,IAEZ,IAAIkkB,EAAQ5K,EAAmBtZ,EAAS,QAAS,KAC7C6J,EAAawP,EAAiBrZ,EAAS,aAAcxI,GAEzD0sB,EAAQA,EAAQ,IAAMA,EAAQ,IAAMA,EACpC,IAAIjZ,EAAS,CAAC,EAAG,EAAG,GAChBkZ,EAAQ9rB,EAASe,OAAO,EAAG,EAAG,GAC9BgrB,EAAU,CAAC,EAAG,EAAG,GACjBvhB,EAAW,GAEXwhB,EAAQ,IAAIlc,EAAU8C,EAAQkZ,EAAOC,GACzC,GAAIF,EAAQ,GAAKA,EAAQ,IAAK,CAG5B,IAAII,EAAQ,IAAInc,EAAU8C,EAAQkZ,EAAMjM,SAASgM,GAAQE,GACzDvhB,EAAWA,EAAS6Q,OAClBhN,EAAIqE,iBAAiB,CAACQ,YAAa8Y,EAAOvmB,SAAS,KACrD+E,EAAWA,EAAS6Q,OAClBhN,EAAIqE,iBAAiB,CAACQ,YAAa+Y,KAEvC,IACIC,EADAC,EAASH,EAETjJ,EAAO8I,EAAQra,EAEnB,IAAK,IAAInQ,EAAI0hB,EAAM1hB,GAAKwqB,EAAQzsB,EAAKiC,GAAK0hB,EACxCmJ,EAAS,IAAIpc,EAAU8C,EAAQkZ,EAAMjM,SAASxe,GAAI0qB,GAClDvhB,EAAWA,EAAS6Q,OAAOhN,EAAIqF,gBAC7B,CAACE,aAAcuY,EAAQtY,aAAcqY,GAJzB,IAKdC,EAASD,EAEX,OAAO5mB,EAAakF,GAAUwG,gBAuN9Bob,oBAnBF,SAA6BC,EAAYvC,GACvC,MAOM,EAACpf,EAAC,EAAE4hB,EAAC,GAAEjC,EAAE,OAAE1K,EAAM,MAAE4G,GAAShpB,OAAOoV,OAAO,GAP/B,CACfjI,EAAG,EACH4hB,EAAG,EACHjC,GAAI,EACJ1K,QAAQ,EACR4G,OAAO,GAEqDuD,GAC9D,OAAO,IAAI1H,EAAOiK,EAAY1M,GAAQ6D,mBAAmB9Y,EAAG4hB,EAAGjC,EAAI9D,M,cCzVrE,MAAMjM,EAAa,aAGnBA,EAAW7b,UAAY,CACrBmd,WAAY,SAAUzZ,GACpB,IAAInB,EAAS,IAAIsZ,EAEjB,OADAA,EAAWiS,aAAajsB,KAAMU,EAAQmB,GAC/BnB,GAETsa,OAAQ,SAAUkR,GAChB,IAAIxrB,EAAS,IAAIsZ,EAGjB,OAFAA,EAAWmS,SAASnsB,KAAMU,GAC1BsZ,EAAWoS,QAAQ1rB,EAAQwrB,GACpBxrB,IAIXsZ,EAAWiS,aAAe,SAAUI,EAAQ3rB,EAAQmB,GAClD,IAAK,IAAIyqB,KAAgBD,EAAQ,CAC/B,GAAqB,eAAjBC,EAA+B,SACnC,GAAqB,WAAjBA,EAA2B,SAC/B,IAAIC,EAAgBF,EAAOC,GACvBE,EAAcD,EACa,iBAApB,IACJ,cAAeA,GAAwD,mBAA7BA,EAAuB,UACpEC,EAAcD,EAAcxqB,UAAUF,GAC7B0qB,aAAyBjsB,OAClCksB,EAAc,GACdxS,EAAWiS,aAAaM,EAAeC,EAAa3qB,IAC3C0qB,aAAyBvS,IAClCwS,EAAc,IAAIxS,EAClBA,EAAWiS,aAAaM,EAAeC,EAAa3qB,KAGxDnB,EAAO4rB,GAAgBE,IAI3BxS,EAAWmS,SAAW,SAAUE,EAAQ3rB,GACtC,IAAK,IAAI4rB,KAAgBD,EAAQ,CAC/B,GAAqB,eAAjBC,EAA+B,SACnC,GAAqB,WAAjBA,EAA2B,SAC/B,IAAIC,EAAgBF,EAAOC,GACvBG,EAASF,EACb,GAA+B,iBAApB,EACT,GAAIA,aAAyBjsB,MAAO,CAClCmsB,EAAS,GACT,IAAK,IAAIlwB,EAAI,EAAGA,EAAIgwB,EAAcxsB,OAAQxD,IACxCkwB,EAAO5nB,KAAK0nB,EAAchwB,SAEnBgwB,aAAyBvS,IAClCyS,EAAS,IAAIzS,EACbA,EAAWmS,SAASI,EAAeE,IAGvC/rB,EAAO4rB,GAAgBG,IAI3BzS,EAAWoS,QAAU,SAAU1rB,EAAQwrB,GACrC,IAAK,IAAII,KAAgBJ,EACF,eAAjBI,GACiB,WAAjBA,IACCA,KAAgB5rB,GACgB,iBAA1BA,EAAO4rB,IACf5rB,EAAO4rB,aAAyBtS,GACW,iBAAnCkS,EAAgBI,IACxBJ,EAAgBI,aAAyBtS,EAC1CA,EAAWoS,QAAQ1rB,EAAO4rB,GAAeJ,EAAgBI,IAC9CA,KAAgB5rB,IAC3BA,EAAO4rB,GAAgBJ,EAAgBI,MAK7CtwB,EAAOD,QAAUie,G,gBClFjB,MAAMhT,EAAM,EAAQ,IACd,WAACwD,GAAc,EAAQ,GAW7B,SAASuB,EAAUtE,GACjB,MAAMsG,EAAMvD,EAAW/C,GACvBzH,KAAKgK,MAAQ+D,EAAI/D,MAGnB+B,EAAU5N,UAAY6I,EAAI7I,UAE1BnC,EAAOD,QAAUgQ,G,gBCnBjB,MAAM,QAACxN,GAAW,EAAQ,IACpB,eAACmuB,GAAkB,EAAQ,IAkE3B7c,EAAiB,SAAU9B,EAAKiE,GACpC,IAAInH,EAAK,KACLC,EAAK,KACL6hB,GAAS,EAQb,OAPA5e,EAAI/D,MAAMrF,QAAQiK,IAChB/D,EAAK+D,EAAKqD,QAAQrO,IAClBkH,EAAK8D,EAAKsD,QAAQtO,IACdiM,EAAewZ,GAAGrX,EAAInH,EAAIC,IAAO+E,EAAeyZ,GAAGtX,EAAInH,EAAIC,KAC7D6hB,GAAUA,KAGPA,GAGT9c,EAAewZ,GAAK,CAACrX,EAAInH,EAAIC,IAAQD,EAAGjL,EAAIoS,EAAGpS,GAAQkL,EAAGlL,EAAIoS,EAAGpS,EACjEiQ,EAAeyZ,GAAK,CAACtX,EAAInH,EAAIC,IAAQkH,EAAGrS,GAAKmL,EAAGnL,EAAIkL,EAAGlL,IAAMqS,EAAGpS,EAAIiL,EAAGjL,IAAMkL,EAAGlL,EAAIiL,EAAGjL,GAAKiL,EAAGlL,EAgB/F3D,EAAOD,QAAU,CACf6T,WA9FiB,SAAU5I,GAC3B,IAAI4lB,EAAS,GACT5lB,EAAI0G,oBAAmB,IACzBkf,EAAO/nB,KAAK,mBAEd,IAAIgoB,EAAa,GACjB7lB,EAAIgD,MAAMvD,KAAI,SAAUmI,GACtB,SAASke,EAASzuB,GAChB,IAAIgK,EAAMhK,EAAEsB,EAAI,IAAMtB,EAAEuB,EAClByI,KAAOwkB,IAAaA,EAAWxkB,GAAO,GAC5CwkB,EAAWxkB,KAGbykB,EAASle,EAAKqD,QAAQrO,KACtBkpB,EAASle,EAAKsD,QAAQtO,QAExB,IAAK,IAAIyE,KAAOwkB,EAAY,CAC1B,IAAIE,EAAQF,EAAWxkB,GACX,EAAR0kB,GACFH,EAAO/nB,KAAK,2BAA6BkoB,EAAQ,eAAiB1kB,GAGtE,IAAIlB,EAAOH,EAAIG,OAIf,GAHIA,EAAO5I,GACTquB,EAAO/nB,KAAK,WAAasC,GAEvBylB,EAAO7sB,OAAS,EAAG,CACrB,IAAIitB,EAAQ,GAIZ,MAHAJ,EAAOnmB,KAAI,SAAUwmB,GACnBD,GAASC,EAAM,QAEX,IAAIzsB,MAAMwsB,KAgElBtf,mBA5DyB,SAAUK,EAAKoD,GACxC,IAAIhC,EAAWpB,EAAI/D,MAAMjK,OACzB,IAAK,IAAIxD,EAAI,EAAGA,EAAI4S,EAAU5S,IAAK,CACjC,IAAI2wB,EAAQnf,EAAI/D,MAAMzN,GACtB,IAAK,IAAI4wB,EAAK5wB,EAAI,EAAG4wB,EAAKhe,EAAUge,IAAM,CACxC,IAAIC,EAAQrf,EAAI/D,MAAMmjB,GACtB,GAAIT,EAAeQ,EAAMjb,QAAQrO,IAAKspB,EAAMhb,QAAQtO,IAAKwpB,EAAMnb,QAAQrO,IAAKwpB,EAAMlb,QAAQtO,KAKxF,OAJIuN,IACFkc,QAAQC,IAAI,QAAU/wB,EAAI,KAAO2wB,GACjCG,QAAQC,IAAI,QAAUH,EAAK,KAAOC,KAE7B,GAIb,OAAO,GA8CPvd,iBACAlC,SAbe,SAAU4f,EAAMC,GAC/B,IAAK,IAAIjxB,EAAI,EAAGkxB,EAAKD,EAAKxjB,MAAMjK,OAAQxD,EAAIkxB,EAAIlxB,IAC9C,IAAKsT,EAAe0d,EAAMC,EAAKxjB,MAAMzN,GAAG0V,QAAQrO,KAC9C,OAAO,EAGX,OAAO,K,gBC/FT,MAAM,IAAC9E,GAAO,EAAQ,GAChB4uB,EAAkB,EAAQ,IAC1BC,EAAkB,EAAQ,KAC1B,aAAC3oB,GAAgB,EAAQ,IACzB,UAAC8I,GAAa,EAAQ,GA8BtB8f,EAAkB,SAAU3hB,EAAK5E,GACrC,GAAI4E,EAAIC,gBACN,OAAOD,EACF,CACL,MAAMnQ,EAAU,IAAI4xB,EACpB,IAAIhtB,EAASmtB,EAAuB/xB,EAASmQ,GAI7C,OAHAvL,EAAOwL,iBAAkB,EACzBxL,EAAOyL,eAAiBF,EAAIE,eAC5BzL,EAAO+Z,WAAaxO,EAAIwO,WACjB/Z,IAILotB,EAAkB,SAAU/f,EAAK1G,GACrC,GAAI0G,EAAI7B,gBACN,OAAO6B,EACF,CACL,IAAIjS,EAAU,IAAI6xB,EACdjtB,EAASqtB,EAAuBjyB,EAASiS,GAE7C,OADArN,EAAOwL,iBAAkB,EAClBxL,IAILmtB,EAAyB,SAAU/xB,EAASkyB,GAChD,IAAIC,EAAQnyB,EACRmJ,EAAc,GAQlB,OAPA+oB,EAAU9jB,SAASvF,SAAQ,SAAU+C,GACnC,IAAIwmB,EAAaD,EAAME,WAAWzmB,GAE9BwmB,EAAW5qB,SAASvD,QAAU,GAChCkF,EAAYJ,KAAKqpB,MAGdlpB,EAAaC,IAGhB8oB,EAAyB,SAAUjyB,EAASsyB,GAChD,IAAIH,EAAQnyB,EACRiV,EAAWqd,EAAUpkB,MAAMvD,KAAI,SAAUmI,GAC3C,OAAOqf,EAAMI,QAAQzf,MAGpBM,QAAO,SAAUN,GAChB,OAAOA,EAAK7O,SAAWjB,KAE3B,OAAOgP,EAAUiD,IAGnB/U,EAAOD,QArEc,SAAUuyB,EAAUjnB,GACvC,OAAIinB,EAASpiB,gBACJoiB,EAEH,UAAWA,EACNR,EAAgBQ,EAAUjnB,GAE1BumB,EAAgBU,EAAUjnB,K,gBCrBvC,MAAM,IAACvI,GAAO,EAAQ,GAChBuE,EAAU,EAAQ,GAClBkrB,EAAe,EAAQ,IAGvBb,EAAkB,WACtB1tB,KAAKwuB,cAAgB,IAAID,EAAa,EAAGzvB,GACzCkB,KAAKyuB,aAAe,IAAIF,EAAa,EAAGzvB,GACxCkB,KAAK0uB,qBAAuB,IAG9BhB,EAAgBvvB,UAAY,CAC1BwwB,iBAAkB,SAAUC,GAC1B,IAAIC,EAAOD,EAAatmB,UACxB,OAAIumB,KAAQ7uB,KAAK0uB,qBACR1uB,KAAK0uB,qBAAqBG,IAEjC7uB,KAAK0uB,qBAAqBG,GAAQD,EAC3BA,IAIXE,UAAW,SAAUC,GACnB,IAAI1Z,EAAW,CAAC0Z,EAAanrB,IAAI3D,GAAI8uB,EAAanrB,IAAIzD,GAAI4uB,EAAanrB,IAAIxD,GACzE2uB,EAAatjB,GAAGxL,GAAI8uB,EAAatjB,GAAGtL,IAItC,OAHaH,KAAKwuB,cAAcQ,eAAe3Z,GAAU,SAAU+C,GACjE,OAAO2W,MAKXE,SAAU,SAAUC,GAClB,IAAI7Z,EAAW,CAAC6Z,EAAYrsB,OAAO5C,GAAIivB,EAAYrsB,OAAO1C,GAAI+uB,EAAYrsB,OAAOzC,GAAI8uB,EAAY9kB,GAIjG,OAHapK,KAAKyuB,aAAaO,eAAe3Z,GAAU,SAAU+C,GAChE,OAAO8W,MAKXf,WAAY,SAAUgB,GACpB,IAAIxoB,EAAW3G,KAAKivB,SAASE,EAAc3rB,OACvCS,EAAYjE,KAAK2uB,iBAAiBQ,EAAc5rB,QAChD0qB,EAAQjuB,KACRwG,EAAc2oB,EAAc7rB,SAASmD,KAAI,SAAUI,GACrD,OAAOonB,EAAMa,UAAUjoB,MAKrBuoB,EAAmB,GACvB,GAAI5oB,EAAYzG,OAAS,EAAG,CAC1B,IAAIsvB,EAAgB7oB,EAAYA,EAAYzG,OAAS,GAAGR,SACxDiH,EAAY7B,SAAQ,SAAUkC,GAC5B,IAAIoO,EAAYpO,EAAOtH,SACnB0V,IAAcoa,GAChBD,EAAiBvqB,KAAKgC,GAExBwoB,EAAgBpa,KAOpB,OAHIma,EAAiBrvB,OAAS,IAC5BqvB,EAAmB,IAEd,IAAI/rB,EAAQ+rB,EAAkBnrB,EAAW0C,KAIpD3K,EAAOD,QAAU2xB,G,cCxDjB,MAAMa,EAAe,SAAUe,EAAeC,GAC5CvvB,KAAKwvB,YAAc,GACnBxvB,KAAKyvB,WAAa,EAAMF,GAG1BhB,EAAapwB,UAAY,CAMvB6wB,eAAgB,SAAU5W,EAAKsX,GAC7B,IAAIb,EAAO,GACPY,EAAazvB,KAAKyvB,WAKtB,GAJArX,EAAIzT,SAAQ,SAAUgrB,GACpB,IAAIC,EAAiBpxB,KAAKynB,MAAM0J,EAAKF,GACrCZ,GAAQe,EAAiB,OAEvBf,KAAQ7uB,KAAKwvB,YACf,OAAOxvB,KAAKwvB,YAAYX,GACnB,CACL,IAAI5wB,EAASyxB,EAAgBtX,GACzByX,EAAYzX,EAAI3R,KAAI,SAAUkpB,GAChC,IAAIG,EAAKtxB,KAAKgL,MAAMmmB,EAAKF,GAEzB,MAAO,CAAMK,EAAK,IADTA,EAAK,EACmB,QAG/BC,EAAY,GADE3X,EAAIrY,OAEtB,IAAK,IAAIiwB,EAAW,EAAGA,EAAWD,IAAaC,EAAU,CACvD,IAAIC,EAAkBD,EACtBnB,EAAO,GACPgB,EAAUlrB,SAAQ,SAAUurB,GAC1BrB,GAAQqB,EAA2B,EAAlBD,GACjBA,IAAoB,KAEtBjwB,KAAKwvB,YAAYX,GAAQ5wB,EAE3B,OAAOA,KAKbjC,EAAOD,QAAUwyB,G,gBCvDjB,MAAMb,EAAkB,EAAQ,IAC1ByC,EAA8B,EAAQ,KACtC,aAACnrB,GAAgB,EAAQ,GA4C/BhJ,EAAOD,QA1Ca,SAAUkQ,GAC5B,GAAIA,EAAIE,eACN,OAAOF,EACF,CACL,IAAImkB,EAAmB,GACnBlkB,EAAkBD,EAAIC,gBACtBmkB,EAAe,IAAI3C,EACvBzhB,EAAI/B,SAASzD,KAAI,SAAUiB,GACzB,IAAIlE,EAAQkE,EAAQlE,MAChBD,EAASmE,EAAQnE,OAChB2I,IAGH1I,EAAQ6sB,EAAapB,SAASzrB,GAC9BD,EAAS8sB,EAAa1B,iBAAiBprB,IAEzC,IAAI8E,EAAM7E,EAAMjE,SAAW,IAAMgE,EAAOhE,SAClC8I,KAAO+nB,EAGXA,EAAiB/nB,GAAKxD,KAAK6C,GAF3B0oB,EAAiB/nB,GAAO,CAACX,MAK7B,IAAI4oB,EAAe,GACnB,IAAK,IAAI7U,KAAY2U,EAAkB,CACrC,IAAIG,EAAiBH,EAAiB3U,GACtC,GAAI8U,EAAexwB,OAAS,EAC1BuwB,EAAeA,EAAavV,OAAOwV,OAC9B,CACL,IAAIC,EAAuB,GAC3BL,EAA4BI,EAAgBC,GAC5CF,EAAeA,EAAavV,OAAOyV,IAGvC,IAAI9vB,EAASsE,EAAasrB,GAI1B,OAHA5vB,EAAOyL,gBAAiB,EAExBzL,EAAO+Z,WAAaxO,EAAIwO,WACjB/Z,K,gBC1CX,MAAM0C,EAAY,EAAQ,IACpB1D,EAAW,EAAQ,IACnB,UAAC8P,GAAa,EAAQ,KACtB,WAAChF,GAAc,EAAQ,GACvB/K,EAAW,EAAQ,GAkKzBzD,EAAOD,QAAU,CAACme,QAhFF,SAAUjO,GACxB,IAAIgM,EAAiBhM,EAAIkO,+BACzB,OAAOlO,EAAIlK,UAAUkW,IA8EIkC,6BArFU,SAAUlO,GAE7C,OADaA,EAAImO,uDACH,IAmFyCA,qDA7JI,SAAUqW,GACrE,GAA6B,IAAzBA,EAAKvmB,SAASnK,OAAc,CAC9B,IAAIpD,EAAI,IAAIyG,EACZ,MAAO,CAACzG,EAAGA,GACN,CAEL,IAAIsP,EAAMwkB,EAAKpiB,gBACX4O,EAAW,GACfhR,EAAI/B,SAASzD,KAAI,SAAUiB,GACzBuV,EAASvV,EAAQlE,MAAMjE,UAAYmI,EAAQlE,SAM7C,IAQIktB,EAAoBC,EARpBC,EAAU,IAAIlxB,EAAS,EAAG,EAAG,GAC7BmxB,EAAU,IAAInxB,EAAS,EAAG,EAAG,GAC7BoxB,EAAU,IAAIpxB,EAAS,EAAG,EAAG,GAC7BqxB,EAAe,IAAIvhB,EAAU,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,GAAI,GAAIohB,GACpDI,EAAe,IAAIxhB,EAAU,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,GAAI,GAAIqhB,GACpDI,GAAU,EACVC,EAAY,EACZC,EAAU,EAEd,IAAK,IAAI1V,KAAYwB,EAAU,CAC7B,IAEIhF,EAAgBmZ,EAFhB5tB,EAAQyZ,EAASxB,GACjB4V,EAAe7tB,EAAMX,OAAO5B,MAAMuC,EAAM4G,GAO5C,GAFqB5G,EAAMX,OAAOrB,MAAMovB,GAAS7wB,SAC5ByD,EAAMX,OAAOrB,MAAMqvB,GAAS9wB,SACZ,CAEnC,IAAIuxB,EAAiB,IAAI9hB,EAAU6hB,EAAc7tB,EAAMX,OAAQ+tB,GAC/D3Y,EAAiBqZ,EAAeze,oBAAoBke,GAAc,EAAO,GACzEK,EAAwBL,EAAale,oBAAoBye,GAAgB,EAAO,OAC3E,CAEL,IAAIA,EAAiB,IAAI9hB,EAAU6hB,EAAc7tB,EAAMX,OAAQguB,GAC/D5Y,EAAiBqZ,EAAeze,oBAAoBme,GAAc,EAAO,GACzEI,EAAwBJ,EAAane,oBAAoBye,GAAgB,EAAO,GAElF,IAAIC,EAAiBtlB,EAAIlK,UAAUkW,GAC/BuZ,GAAQhuB,EAAMX,OAAO1B,IAAI2vB,GACzBhe,EAASye,EAAezhB,YACxB2hB,EAAU3e,EAAO,GAAGjT,EAAIiT,EAAO,GAAGjT,EAClC6xB,EAAWT,EAQf,GAPKS,IACCD,EAAUP,GAEHO,IAAYP,GACjBM,EAAOL,KAFXO,GAAW,GAKXA,EAAU,CAEZ,IAAI7rB,EAAc,IAAInG,EAAS,EAAE,IAAOoT,EAAO,GAAGnT,EAAImT,EAAO,GAAGnT,IAAK,IAAOmT,EAAO,GAAGlT,EAAIkT,EAAO,GAAGlT,IAAKkT,EAAO,GAAGjT,IACnHoY,EAAiBA,EAAe3C,SAASlS,EAAUyC,YAAYA,IAC/DurB,EAAwBhuB,EAAUyC,YAAYA,EAAYjF,WAAW0U,SAAS8b,GAC9EF,EAAYO,EACZN,EAAUK,EACVd,EAAqBzY,EACrB0Y,EAA4BS,EAE9BH,GAAU,EAEZ,MAAO,CAACP,EAAoBC,KAyF+E5gB,qBAlElF,SAAU4hB,EAAMjgB,GAC3C,IAAI3D,EAAM4jB,EAAKtjB,gBAEXujB,EAAW,GACf7jB,EAAI/D,MAAMvD,KAAI,SAAUmI,GAChBA,EAAKqD,QAAQ1S,WAAYqyB,IAC7BA,EAAShjB,EAAKqD,QAAQ1S,UAAY,CAChCqE,IAAKgL,EAAKqD,QAAQrO,IAClBiuB,KAAM,GACNC,GAAI,KAGRF,EAAShjB,EAAKqD,QAAQ1S,UAAUuyB,GAAGjtB,KAAK+J,EAAKsD,QAAQtO,KAC/CgL,EAAKsD,QAAQ3S,WAAYqyB,IAC7BA,EAAShjB,EAAKsD,QAAQ3S,UAAY,CAChCqE,IAAKgL,EAAKsD,QAAQtO,IAClBiuB,KAAM,GACNC,GAAI,KAGRF,EAAShjB,EAAKsD,QAAQ3S,UAAUsyB,KAAKhtB,KAAK+J,EAAKqD,QAAQrO,QAGzD,IAAImuB,EAAU,GACd,IAAK,IAAIC,KAAYJ,EAAU,CAC7B,IAAIK,EAAWL,EAASI,GACxB,GAA8B,IAAzBC,EAASJ,KAAK9xB,QAAyC,IAAvBkyB,EAASH,GAAG/xB,OAAe,CAE9D,IAAImyB,EAAYD,EAASJ,KAAK,GAC1BM,EAAaF,EAASruB,IACtBwuB,EAAUH,EAASH,GAAG,GACtBxnB,EAAK6nB,EAAWnxB,MAAMkxB,GAAW3wB,OACjCgJ,EAAK6nB,EAAQpxB,MAAMmxB,GAAY5wB,OAGnC,GAFmB+I,EAAG9I,MAAM+I,GACQ,KACjB,CAEjB,IAAIghB,EAAQhhB,EAAGvH,eAAiBsH,EAAGtH,eAAiBxE,KAAKkE,GACrD6oB,EAAQ,EACVA,GAAS,EAAI/sB,KAAKkE,GACT6oB,GAAS,EAAI/sB,KAAKkE,KAC3B6oB,GAAS,EAAI/sB,KAAKkE,IAEpB,IAAI2vB,EAAY9nB,EAAGvJ,MAAMsJ,GAAI/I,OACzB+wB,EAAqB,GAAK,IAAM9zB,KAAKkE,GAErC6vB,EAAkB7gB,EAAelT,KAAKmE,IAAI2vB,EAAqB,GAC/DE,EAAeL,EAAWrxB,KAAKuxB,EAAUpxB,MAAMsxB,IAE/CrQ,EAAaqJ,EAAQ8G,EAAUrvB,eAC/ByvB,EAAa,GAAKj0B,KAAKkE,GAAK6oB,GAC5BjJ,EAAW,EAAI9jB,KAAKuoB,KAAK0L,EAAaH,EAAqB,GAE3D7qB,EAAS,CAAC+qB,GACd,IAAK,IAAIj2B,EAAI,EAAGA,GAAK+lB,EAAU/lB,IAAK,CAClC,IAAIwG,EAAQmf,EAAa3lB,EAAI+lB,EAAWmQ,EACpCp0B,EAAIoB,EAAS8C,iBAAiBQ,GAAO9B,MAAMsxB,GAAiBzxB,KAAK0xB,GACrE/qB,EAAO5C,KAAKxG,GAEd0zB,EAAQltB,KAAK2F,EAAW/C,MAI9B,OAAOsG,EAAI4C,SAASohB,M,gBCnKtB,MAAMW,EAAU,EAAQ,IAmCxB12B,EAAOD,QAtBQ,SAAUsL,EAASsrB,GAMhCtrB,EAAUpK,OAAOoV,OAAO,GALP,CACfrB,KAAM,EAAC,GAAM,GAAM,GACnBZ,OAAQ,CAAC,EAAG,EAAG,IAGqB/I,GACtC,MAAM,KAAC2J,EAAI,OAAEZ,GAAU/I,EAGjBurB,GAFND,EAAUD,EAAQC,IAEMlsB,KAAI,SAAUxI,GACpC,IAAI6U,EAAS7U,EAAO6R,YAChBlK,EAAS,CAAC,EAAG,EAAG,GAIpB,OAHIoL,EAAK,KAAIpL,EAAO,GAAKwK,EAAO,IAAM0C,EAAO,GAAGnT,GAAMmT,EAAO,GAAGnT,EAAImT,EAAO,GAAGnT,GAAK,IAC/EqR,EAAK,KAAIpL,EAAO,GAAKwK,EAAO,IAAM0C,EAAO,GAAGlT,GAAMkT,EAAO,GAAGlT,EAAIkT,EAAO,GAAGlT,GAAK,IAC/EoR,EAAK,KAAIpL,EAAO,GAAKwK,EAAO,IAAM0C,EAAO,GAAGjT,GAAMiT,EAAO,GAAGjT,EAAIiT,EAAO,GAAGjT,GAAK,IAC5E5B,EAAOoH,UAAUO,MAG1B,OAA0B,IAAnBgtB,EAAQ7yB,OAAe6yB,EAAQ,GAAKA,I,gBChC7C,MAAM,IAAC9zB,EAAG,SAAEC,GAAY,EAAQ,GAC1BoE,EAAS,EAAQ,GACjB1D,EAAW,EAAQ,GACnB4D,EAAU,EAAQ,IAClB,aAACmF,EAAY,MAAEyB,GAAS,EAAQ,IAChC,WAACO,EAAU,kBAAEvD,GAAqB,EAAQ,GA0B1CsJ,EAAqB,SAAUohB,EAAMxrB,EAAQ+K,GACjD,MAAMlK,EAAM,EAAQ,IACpBkK,EAAaA,GAAc,GACV,IAAGA,EAAa,GACjC,IAAIV,EAAO,GACPohB,EAAW,GACLD,EAAKtjB,gBACXrE,MAAMvD,KAAI,SAAUmI,GACtB,IAAI/R,EAAI+R,EAAKsD,QAAQtO,IAAI5C,MAAM4N,EAAKqD,QAAQrO,KACxCivB,EAAKh2B,EAAEkD,SACX,GAAI8yB,EAAK/zB,EAAK,CACZjC,EAAIA,EAAEoE,MAAM,EAAM4xB,GAClB,IAAIhwB,EAAShG,EAAEgG,SAAS5B,MAAMkF,GAC1B2sB,EAAc,CAChBlkB,EAAKsD,QAAQtO,IAAI9C,KAAK+B,GACtB+L,EAAKsD,QAAQtO,IAAI5C,MAAM6B,GACvB+L,EAAKqD,QAAQrO,IAAI5C,MAAM6B,GACvB+L,EAAKqD,QAAQrO,IAAI9C,KAAK+B,IAGpBkwB,EAASvoB,EAAWsoB,GACxBtiB,EAAK3L,KAAKkuB,GACV,IAAK,IAAItQ,EAAO,EAAGA,EAAO,EAAGA,IAAQ,CACnC,IAAI5X,EAAe,IAAT4X,EAAc7T,EAAKqD,QAAQrO,IAAMgL,EAAKsD,QAAQtO,IACpDkH,EAAe,IAAT2X,EAAc7T,EAAKsD,QAAQtO,IAAMgL,EAAKqD,QAAQrO,IACpDyE,EAAMwC,EAAGlL,EAAI,IAAMkL,EAAGjL,EACpByI,KAAOupB,IACXA,EAASvpB,GAAO,IAElBupB,EAASvpB,GAAKxD,KAAK,CACjB,GAAMgG,EACN,GAAMC,SAKd,IAAK,IAAIzC,KAAOupB,EAAU,CACxB,IACI7T,EAAQC,EADRrhB,EAAIi1B,EAASvpB,GAEb2qB,EAAUr2B,EAAE,GAAGkO,GACnB,GAAiB,IAAblO,EAAEoD,OAAc,CAClB,IAAIkzB,EAAOt2B,EAAE,GAAGmO,GACZooB,EAAOv2B,EAAE,GAAGmO,GAKhB,GAJAiT,EAASkV,EAAKjyB,MAAMgyB,GAAS/vB,eAC7B+a,EAASkV,EAAKlyB,MAAMgyB,GAAS/vB,eACzB+a,EAASD,IAAQC,GAAU,KAC3BA,GAAWD,EAAS,MAAMC,GAAU,KACpCA,EAASD,EAAS,IAAK,CACzB,IAAItgB,EAAIugB,EACRA,EAASD,EAAS,IAClBA,EAAStgB,EAEXsgB,GAAU,GACVC,GAAU,QAEVD,EAAS,EACTC,EAAS,IAEX,IAAImV,EAAcnV,EAASD,EAAS,QAKpC,GAJIoV,IACFpV,EAAS,EACTC,EAAS,KAEPA,EAAUD,EAAShf,EAAW,CAChC,IAAI0I,EAAS,GACR0rB,GACH1rB,EAAO5C,KAAKmuB,GAEd,IAAI1Q,EAAW9jB,KAAKynB,MAAM/U,GAAc8M,EAASD,GAAU,KACvDuE,EAAW,IAAGA,EAAW,GAC7B,IAAK,IAAIG,EAAO,EAAGA,GAAQH,EAAUG,IAAQ,CAC3C,IAAI1f,EAAQgb,EAAS0E,EAAOH,GAAYtE,EAASD,GAC7C0E,IAASH,IAAUvf,EAAQib,GAC/B,IAAIzX,EAAQysB,EAAQlyB,KAAKrB,EAAS+C,iBAAiBO,GAAO9B,MAAMkF,MAC1DgtB,GAAgB1Q,EAAO,IAC3Bhb,EAAO5C,KAAK0B,GAGhB,IAAIwsB,EAAS9rB,EAAkBQ,GAC/B+I,EAAK3L,KAAKkuB,IAGd,IAAIryB,EAAS,IAAIsG,EAEjB,OADAtG,EAASA,EAAOkN,MAAM4C,GACf9P,GAeH6Z,EAAsB,SAAUkW,EAAMtqB,EAAQ+K,EAAYyK,GAC9D,MAAMnB,EAAM,EAAQ,KACd,aAACxV,GAAgB,EAAQ,GAE/B,IACItE,EADAuL,EAAMwkB,EAAK/f,eAGbhQ,EADEib,EACO1P,EAEA,IAAIuO,EAIfvO,EAAI/B,SAASzD,KAAI,SAAUiB,GACzB,IAAI0rB,EAAgB1rB,EAAQlE,MAAMX,OAAOtB,OAAON,MAAM,EAAIkF,GAEtDktB,EADoB3rB,EAAQrC,UAAU+tB,EAAcnyB,OAAO,KAC1B6D,QAAQsuB,GAC7C1yB,EAASA,EAAOia,SAAS0Y,GAAc,GAAO,MAQhD,IAAIC,EAAc,GAClBrnB,EAAI/B,SAASzD,KAAI,SAAUiB,GACzB,IAAIpC,EAAcoC,EAAQpE,SAASvD,OAC/BqO,EAAa1G,EAAQpE,SAASgC,EAAc,GAC5C+pB,EAAgBjhB,EAAW7O,SAC/B,IAAK,IAAIhD,EAAI,EAAGA,EAAI+I,EAAa/I,IAAK,CACpC,IAEIg3B,EAMAhsB,EARAV,EAASa,EAAQpE,SAAS/G,GAC1B0Y,EAAYpO,EAAOtH,SAGrBg0B,EADEte,EAAYoa,EACEpa,EAAY,IAAMoa,EAElBA,EAAgB,IAAMpa,EAGpCse,KAAiBD,EACnB/rB,EAAM+rB,EAAYC,IAElBhsB,EAAM,CACJ+C,GAAI8D,EACJ7D,GAAI1D,EACJ2sB,aAAc,IAEhBF,EAAYC,GAAiBhsB,GAE/BA,EAAIisB,aAAa3uB,KAAK6C,EAAQlE,MAAMX,QAEpCwsB,EAAgBpa,EAChB7G,EAAavH,MAUjB,IAAK,IAAI0sB,KAAiBD,EAAa,CACrC,IAAIG,EAAaH,EAAYC,GACzBvN,EAAayN,EAAWnpB,GAAG1G,IAC3B6hB,EAAWgO,EAAWlpB,GAAG3G,IAEzB8vB,EAAQjO,EAASzkB,MAAMglB,GAAYzkB,OACnCoyB,EAAQF,EAAWD,aAAa,GAAGjyB,OACnCqyB,EAAQD,EAAMnyB,MAAMkyB,GAGpBG,EAAS,GAGb,IAAK,IAAIt3B,EAAI,EAAGA,EAAI2U,EAAY3U,IAC9Bs3B,EAAOhvB,KAAKtI,EAAIiC,KAAKkE,GAAK,EAAIwO,GAIhC,IAAK,IAAI3U,EAAI,EAAGu3B,EAAOL,EAAWD,aAAazzB,OAAQxD,EAAIu3B,EAAMv3B,IAAK,CACpE,IAAIqL,EAAc6rB,EAAWD,aAAaj3B,GACtCw3B,EAAKH,EAAMzyB,IAAIyG,GACfosB,EAAKL,EAAMxyB,IAAIyG,GACf7E,EAAQvE,KAAK0E,MAAM6wB,EAAIC,GAEvBjxB,EAAQ,IAAGA,GAAmB,EAAVvE,KAAKkE,IAC7BmxB,EAAOhvB,KAAK9B,GACZA,EAAQvE,KAAK0E,OAAO6wB,GAAKC,GACrBjxB,EAAQ,IAAGA,GAAmB,EAAVvE,KAAKkE,IAC7BmxB,EAAOhvB,KAAK9B,GAKd8wB,EAASA,EAAOI,KAAKzrB,GAGrB,IACI0rB,EACAC,EAFAC,EAAYP,EAAO9zB,OAGnBs0B,EAAoB,GACpBC,EAAkB,GAClBpqB,EAAW,GACf,IAAK,IAAI3N,GAAK,EAAGA,EAAI63B,EAAW73B,IAAK,CACnC,IAAIwG,EAAQ8wB,EAAQt3B,EAAI,EAAMA,EAAI63B,EAAa73B,GAC3Cw3B,EAAKv1B,KAAKC,IAAIsE,GACdixB,EAAKx1B,KAAKmE,IAAII,GACd1E,EAAIs1B,EAAM1yB,MAAM+yB,EAAK7tB,GAAQrF,KAAK8yB,EAAM3yB,MAAM8yB,EAAK5tB,IACnD0E,EAAKmb,EAAWllB,KAAKzC,GACrByM,EAAK2a,EAAS3kB,KAAKzC,GACnB2jB,GAAO,EAMX,GALIzlB,GAAK,GACHsO,EAAGpJ,WAAWyyB,GAAUp1B,IAC1BkjB,GAAO,IAGNA,EAAM,CACT,GAAIzlB,GAAK,EAAG,CACV83B,EAAkBxvB,KAAK,IAAI1B,EAAO0H,IAClCypB,EAAgBzvB,KAAK,IAAI1B,EAAO2H,IAChC,IAAIiC,EAAkB,CACpB,IAAI5J,EAAOgxB,GACX,IAAIhxB,EAAO2H,GACX,IAAI3H,EAAO0H,GACX,IAAI1H,EAAO+wB,IAETxsB,EAAU,IAAIrE,EAAQ0J,GAC1B7C,EAASrF,KAAK6C,GAEhBwsB,EAASrpB,EACTspB,EAASrpB,GAGbwpB,EAAgB5tB,UAChBwD,EAASrF,KAAK,IAAIxB,EAAQgxB,IAC1BnqB,EAASrF,KAAK,IAAIxB,EAAQixB,IAC1B,IAAI1M,EAAW5iB,EAAakF,GAC5BxJ,EAASA,EAAOia,SAASiN,GAAU,GAAO,GAK5C,IAAI9S,EAAY,GAChB7I,EAAI/B,SAASzD,KAAI,SAAUiB,GACzBA,EAAQpE,SAASmD,KAAI,SAAUI,GAC7B,IACIU,EADA0N,EAAYpO,EAAOtH,SAEnB0V,KAAaH,EACfvN,EAAMuN,EAAUG,IAEhB1N,EAAM,CACJ3D,IAAKiD,EAAOjD,IACZ2wB,QAAS,IAEXzf,EAAUG,GAAa1N,GAEzBA,EAAIgtB,QAAQ1vB,KAAK6C,EAAQlE,MAAMX,cAOnC,IAAK,IAAIoS,KAAaH,EAAW,CAC/B,IAAI0f,EAAY1f,EAAUG,GAEtBwf,EAAQD,EAAUD,QAAQ,GAAGhzB,OAE7BmzB,EAAY,KACZC,EAAyB,EAC7B,IAAK,IAAIp4B,EAAI,EAAGA,EAAIi4B,EAAUD,QAAQx0B,OAAQxD,IAAK,CACjD,IAAIsG,EAAS2xB,EAAUD,QAAQh4B,GAAGgF,OAE9BqzB,EADQH,EAAMjzB,MAAMqB,GACA9C,SACpB60B,EAAc,KACZA,EAAcD,IAChBA,EAAyBC,EACzBF,EAAY7xB,GAIb6xB,IACHA,EAAYD,EAAMvyB,2BAEpB,IAAI2yB,EAAQJ,EAAMjzB,MAAMkzB,GAAWnzB,OAC/BuzB,EAAQD,EAAMrzB,MAAMizB,GACpBM,EAAUva,EAAIiN,OAAO,CACvBrX,OAAQokB,EAAU5wB,IAClBuC,OAAQA,EACR+K,WAAYA,EACZF,KAAM,CAACyjB,EAAOI,EAAOC,KAEvBp0B,EAASA,EAAOia,SAASoa,GAAS,GAAO,GAG3C,OAAOr0B,GAGT1E,EAAOD,QAAU,CACfsU,OApUa,SAAU2kB,EAAO7uB,EAAQ+K,GACtC,IAAIxQ,EAQJ,OAPIuJ,EAAM+qB,IACRt0B,EAASs0B,EAAMpnB,MAAM2M,EAAoBya,EAAO7uB,EAAQ+K,IACxDxQ,EAASA,EAAOgQ,eAChBhQ,EAAO+Z,WAAaua,EAAMva,YAE1B/Z,EAASs0B,EAAMpnB,MAAM2C,EAAmBykB,EAAO7uB,EAAQ+K,IAElDxQ,GA4TP4P,SAzTe,SAAU0kB,EAAO7uB,EAAQ+K,GACxC,IAAIxQ,EAQJ,OAPIuJ,EAAM+qB,IACRt0B,EAASs0B,EAAMrkB,SAAS4J,EAAoBya,EAAO7uB,EAAQ+K,IAC3DxQ,EAASA,EAAOgQ,eAChBhQ,EAAO+Z,WAAaua,EAAMva,YAE1B/Z,EAASs0B,EAAMrkB,SAASJ,EAAmBykB,EAAO7uB,EAAQ+K,IAErDxQ,GAiTP6P,qBACAgK,wB,gBC9UF,MAAM,IAACvT,GAAO,EAAQ,KAChB,WAACwD,GAAc,EAAQ,GAsH7BxO,EAAOD,QAAU,CACfsrB,OA3EF,SAAgBmC,GAMd,IAAI,EAACnsB,EAAC,GAAE0sB,EAAE,OAAE3Z,GAAUnT,OAAOoV,OAAO,GALnB,CACfhV,EAAG,EACH0sB,GAAI,GACJ3Z,QAAQ,GAEwCoZ,IAC9CA,GAAWA,EAAOnsB,GAAMmsB,EAAOO,IAAOP,EAAOpZ,SAAQ/S,EAAImsB,GAC7D,IAAI5jB,GAAoB,IAAXwK,EAAkB,CAAC,EAAG,GAAK,CAAC/S,EAAGA,GAC5C,OAAO2J,EAAIqgB,OAAO,CAACjX,OAAQxK,EAAQO,OAAQ9I,EAAG6T,WAAY6Y,KAmE1DkL,OA3GF,WACE,IACIC,EADA30B,EAAI,CAAC,EAAG,GAERQ,EAAIjB,UACJ0pB,EAASzoB,EAAE,GAYf,OAVIyoB,GAAU7L,OAAOwX,SAAS3L,KAASjpB,EAAI,CAACipB,EAAQA,IAChDA,GAAUA,EAAOzpB,SACnBQ,EAAIQ,EAAE,GACNyoB,EAASzoB,EAAE,IAETyoB,GAAUA,EAAO4L,MAAQ5L,EAAO4L,KAAKr1B,SAAQQ,EAAIipB,EAAO4L,MAE5DF,EAAM,CAAC30B,EAAE,GAAK,EAAGA,EAAE,GAAK,GACpBipB,IAA4B,IAAlBA,EAAOpZ,SAAiB8kB,EAAM,CAAC,EAAG,IAEzCluB,EAAIugB,UAAU,CAACnX,OAAQ8kB,EAAK/uB,OAAQ,CAAC5F,EAAE,GAAK,EAAGA,EAAE,GAAK,MA4F7DmH,QAxCF,SAAiB8hB,GACf,IAAI/hB,EAAS,GAkBb,OAjBI+hB,EAAOlb,OAASkb,EAAOlb,MAAMvO,QAAUypB,EAAOlb,MAAM,GAAGvO,QACtB,iBAAxBypB,EAAO/hB,OAAO,GAAG,KAC1B+hB,EAAO/hB,OAAS+hB,EAAO/hB,OAAOoV,OAAO,CAAC9b,EAAG0H,IAAM1H,EAAEga,OAAOtS,KAE1D+gB,EAAOlb,MAAM3J,QAAQ,CAAC4J,EAAMhS,KAC1BkL,EAAO5C,KAAK,IACZ0J,EAAK5J,QAAQ2P,GAAK7M,EAAOlL,GAAGsI,KAAK2kB,EAAO/hB,OAAO6M,QAExCkV,EAAOlb,OAASkb,EAAOlb,MAAMvO,OACtCypB,EAAOlb,MAAM3J,QAAQpI,GAAKkL,EAAO5C,KAAK2kB,EAAO/hB,OAAOlL,KAGlDkL,EADE+hB,EAAOzpB,OACAypB,EAEAA,EAAO/hB,OAGb+C,EAAW/C,IAsBlB4tB,SAVF,WACE,IAAIt0B,EAAIjB,UAER,OADIiB,EAAE,IAAMA,EAAE,GAAGhB,SAAQgB,EAAIA,EAAE,IACxByJ,EAAWzJ,M,gBCpHpB,MAAM6nB,EAAU,EAAQ,IAClBllB,EAAQ,EAAQ,GAChB4xB,EAAU,EAAQ,IAClB,MAAC1nB,GAAS,EAAQ,KAClB,WAACpD,GAAc,EAAQ,IACvB,MAACT,GAAS,EAAQ,GAkNxB,SAASwrB,IACP,IAAIC,EAAM,GAENz0B,EAAIjB,UACJiB,EAAE,GAAGhB,SAAQgB,EAAIA,EAAE,IACvB,IAAI00B,EAAO,GAEX,IAAK,IAAIl5B,EAAI,EAAGA,EAAIwE,EAAEhB,OAAQxD,IAAK,CACjC,IAAIwR,EAAMhN,EAAExE,GACZ,IAAKwN,EAAMgE,GACT,MAAM,IAAIvN,MAAM,6CAElB,IAAK,IAAI8T,EAAI,EAAGA,EAAIvG,EAAI/D,MAAMjK,OAAQuU,IAAK,CACzC,IAAI3U,EAAIoO,EAAI/D,MAAMsK,GAAGrC,QAAQrO,IAAIjE,EAC7BC,EAAImO,EAAI/D,MAAMsK,GAAGrC,QAAQrO,IAAIhE,EAE7B61B,EAAU91B,EAAI,IAAMC,KAGxB41B,EAAI3wB,KAAK,CAAClF,EAAGA,EAAGC,EAAGA,IACnB61B,EAAU91B,EAAI,IAAMC,OAQxB,IAAI81B,EAAkB,SAAUn5B,EAAGwE,EAAGlE,GACpCmD,KAAK2I,MAAQpM,EACbyD,KAAK+C,MAAQhC,EACbf,KAAKwL,SAAW3O,EAEhBmD,KAAK21B,QAAU,SAAUt3B,GACvB,OAAI2B,KAAK+C,MAAQ1E,EAAE0E,OACT,EACC/C,KAAK+C,MAAQ1E,EAAE0E,MACjB,EAEH/C,KAAKwL,SAAWnN,EAAEmN,UACZ,EACCxL,KAAKwL,SAAWnN,EAAEmN,SACpB,EAGJ,IAIPoqB,EAAa,WACf51B,KAAKyH,OAAS,KACdzH,KAAK61B,QAAU,KAEf71B,KAAK81B,WAAa,WAChB,OAAO91B,KAAK61B,SAGd71B,KAAK+1B,MAAQ,WACX/1B,KAAK61B,QAAU,KACf71B,KAAKyH,OAAS,MAGhBzH,KAAKg2B,IAAM,SAAUnrB,EAAIC,EAAImrB,GAC3B,IAAID,GAAOh2B,KAAKyH,OAAOqD,GAAInL,EAAIK,KAAKyH,OAAOoD,GAAIlL,IAAMK,KAAKyH,OAAOwuB,GAAIr2B,EAAII,KAAKyH,OAAOoD,GAAIjL,IACtFI,KAAKyH,OAAOqD,GAAIlL,EAAII,KAAKyH,OAAOoD,GAAIjL,IAAMI,KAAKyH,OAAOwuB,GAAIt2B,EAAIK,KAAKyH,OAAOoD,GAAIlL,GAEjF,OAAIq2B,EAAM,KACD,EAEFA,GAGTh2B,KAAK+C,MAAQ,SAAU/F,EAAG+D,GAExB,OAAOvC,KAAK0E,MAAOlD,KAAKyH,OAAO1G,GAAGnB,EAAII,KAAKyH,OAAOzK,GAAG4C,EAAKI,KAAKyH,OAAO1G,GAAGpB,EAAIK,KAAKyH,OAAOzK,GAAG2C,IAG9FK,KAAKwL,SAAW,SAAUzK,EAAG0H,GAC3B,OAASzI,KAAKyH,OAAOgB,GAAG9I,EAAIK,KAAKyH,OAAO1G,GAAGpB,IAAMK,KAAKyH,OAAOgB,GAAG9I,EAAIK,KAAKyH,OAAO1G,GAAGpB,IAChFK,KAAKyH,OAAOgB,GAAG7I,EAAII,KAAKyH,OAAO1G,GAAGnB,IAAMI,KAAKyH,OAAOgB,GAAG7I,EAAII,KAAKyH,OAAO1G,GAAGnB,IAG/EI,KAAKk2B,QAAU,SAAUC,GAEvB,GADAn2B,KAAK61B,QAAU,KACXM,EAAQp2B,OAAS,EACnB,OAEFC,KAAKyH,OAAS0uB,EAGd,IAAIh0B,EAAM,EACV,IAAK,IAAI5F,EAAI,EAAGA,EAAIyD,KAAKyH,OAAO1H,OAAQxD,IAClCyD,KAAKyH,OAAOlL,GAAGqD,IAAMI,KAAKyH,OAAOtF,GAAKvC,EACpCI,KAAKyH,OAAOlL,GAAGoD,EAAIK,KAAKyH,OAAOtF,GAAKxC,IACtCwC,EAAM5F,GAECyD,KAAKyH,OAAOlL,GAAGqD,EAAII,KAAKyH,OAAOtF,GAAKvC,IAC7CuC,EAAM5F,GAKV,IAAI65B,EAAK,GACLC,EAAM,EACNC,EAAO,EACX,IAAK,IAAI/5B,EAAI,EAAGA,EAAIyD,KAAKyH,OAAO1H,OAAQxD,IAClCA,IAAM4F,IAGVk0B,EAAMr2B,KAAK+C,MAAMZ,EAAK5F,GAClB85B,EAAM,IACRA,GAAO73B,KAAKkE,IAEd4zB,EAAOt2B,KAAKwL,SAASrJ,EAAK5F,GAC1B65B,EAAGvxB,KAAK,IAAI6wB,EAAgBn5B,EAAG85B,EAAKC,KAGtCF,EAAGnC,MAAK,SAAUlzB,EAAG0H,GACnB,OAAO1H,EAAE40B,QAAQltB,MAInB,IAYI8tB,EAZAC,EAAQ,IAAIl2B,MAAMN,KAAKyH,OAAO1H,OAAS,GACvCuU,EAAI,EACR,IAAK,IAAI/X,EAAI,EAAGA,EAAIyD,KAAKyH,OAAO1H,OAAQxD,IAClCA,IAAM4F,IAGVq0B,EAAMliB,GAAK8hB,EAAG9hB,EAAI,GAAG3L,MACrB2L,KAEFkiB,EAAM,GAAKA,EAAMx2B,KAAKyH,OAAO1H,QAC7By2B,EAAM,GAAKr0B,EAGX,IAAIs0B,EAAI,EACR,IAAK,IAAIl6B,EAAI,EAAGA,GAAKyD,KAAKyH,OAAO1H,OAAQxD,IAAK,CAC5C,KAAOyD,KAAKg2B,IAAIQ,EAAMC,EAAI,GAAID,EAAMC,GAAID,EAAMj6B,KAAO,GACnDk6B,IAEFA,IACAF,EAAMC,EAAMj6B,GACZi6B,EAAMj6B,GAAKi6B,EAAMC,GACjBD,EAAMC,GAAKF,EAGbv2B,KAAK61B,QAAU,IAAIv1B,MAAMm2B,GACzB,IAAK,IAAIl6B,EAAI,EAAGA,EAAIk6B,EAAGl6B,IACrByD,KAAK61B,QAAQt5B,GAAKi6B,EAAMj6B,EAAI,KAK9Bg5B,EAAO,IAAIK,EAEfL,EAAKW,QAAQV,GACb,IAAIK,EAAUN,EAAKO,aAEnB,GAAID,GAAWA,EAAQ91B,OAAS,EAAG,CACjC,IAAI22B,EAAK,GACT,IAAK,IAAIn6B,EAAI,EAAGA,EAAIs5B,EAAQ91B,OAAQxD,IAClCm6B,EAAG7xB,KAAK2wB,EAAIK,EAAQt5B,KAEtB,OAAOiO,EAAWksB,IAwCtB16B,EAAOD,QAAU,CACfsJ,UAlZF,SAAmBsxB,KAAWhE,GAE5B,MAAMiE,EAAYjE,EAAQ5yB,QAAU,GAAK4yB,EAAQ,GAAG5yB,OAAU4yB,EAAQ,GAAKA,EAC3E,IAAI10B,EAAS24B,EAAS,GAEtB,GAAIA,EAAS72B,OAAS,EACpB,IAAK,IAAIxD,EAAI,EAAGA,EAAIq6B,EAAS72B,OAAQxD,IACnC0B,EAASA,EAAO2P,MAAMgpB,EAASr6B,IAGnC,OAAO0B,EAAOoH,UAAUsxB,IAyYxBvmB,OA3RF,SAAgBY,KAAS2hB,GACvB,MAAMiE,EAAYjE,EAAQ5yB,QAAU,GAAK4yB,EAAQ,GAAG5yB,OAAU4yB,EAAQ,GAAKA,EAC3E,IAAI10B,EAAS24B,EAAS,GAEtB,GAAIA,EAAS72B,OAAS,EACpB,IAAK,IAAIxD,EAAI,EAAGA,EAAIq6B,EAAS72B,OAAQxD,IACnC0B,EAASA,EAAO2P,MAAMgpB,EAASr6B,IAMnC,OAHK+D,MAAM0N,QAAQgD,KACjBA,EAAO,CAACA,EAAMA,EAAMA,IAEf/S,EAAOmS,OAAOY,IAgRrB6lB,MA/XF,SAAeA,KAAUlE,GACvB,MAAMiE,EAAYjE,EAAQ5yB,QAAU,GAAK4yB,EAAQ,GAAG5yB,OAAU4yB,EAAQ,GAAKA,EAC3E,IAAI10B,EAAS24B,EAAS,GAEtB,GAAIA,EAAS72B,OAAS,EACpB,IAAK,IAAIxD,EAAI,EAAGA,EAAIq6B,EAAS72B,OAAQxD,IACnC0B,EAASA,EAAO2P,MAAMgpB,EAASr6B,IAGnC,OAAO0B,EAAO44B,MAAMA,IAuXpBC,OA5WF,WACE,IAAI95B,EACAT,EACAgE,EACAlD,EAAI,EACJ0D,EAAIjB,UAiBR,IAhBKiB,EAAE,GAAGhB,QASRQ,EAAIQ,EAAE,GACNxE,EAAI,EACAwE,EAAE,GAAGhB,SACPgB,EAAIA,EAAE,GACNxE,EAAI,KAZNc,EAAI0D,EAAE,GACNR,EAAIQ,EAAE,GACNxE,EAAI,EACAwE,EAAE,GAAGhB,SACPgB,EAAIA,EAAE,GACNxE,EAAI,IAUHS,EAAI+D,EAAExE,KAAMA,EAAIwE,EAAEhB,OAAQxD,IAC7BS,EAAIA,EAAE4Q,MAAM7M,EAAExE,IAEhB,OAAU,IAANc,EACKL,EAAE85B,OAAO,CAAC,EAAG,EAAG,GAAIv2B,EAAGlD,GAEvBL,EAAE+5B,QAAQx2B,EAAE,IAAIy2B,QAAQz2B,EAAE,IAAIgf,QAAQhf,EAAE,KAiVjDwB,UA/TF,SAAmBya,KAAWmW,GAC5B,MAAMiE,EAAYjE,EAAQ5yB,QAAU,GAAK4yB,EAAQ,GAAG5yB,OAAU4yB,EAAQ,GAAKA,EAC3E,IAQIsE,EARAh5B,EAAS24B,EAAS,GAEtB,GAAIA,EAAS72B,OAAS,EACpB,IAAK,IAAIxD,EAAI,EAAGA,EAAIq6B,EAAS72B,OAAQxD,IACnC0B,EAASA,EAAO2P,MAAMgpB,EAASr6B,IAKnC,IAAK+D,MAAM0N,QAAQwO,GACjB,MAAM,IAAIhc,MAAM,+BAQlB,OANAgc,EAAO7X,QAAQwE,IACb,IAAKwU,OAAOwX,SAAShsB,GACnB,MAAM,IAAI3I,MAAM,iFAGpBy2B,EAAuB,IAAIrO,EAAQpM,GAC5Bve,EAAO8D,UAAUk1B,IA4SxB3a,OAxQF,SAAgBqa,KAAWhE,GACzB,MAAMiE,EAAYjE,EAAQ5yB,QAAU,GAAK4yB,EAAQ,GAAG5yB,OAAU4yB,EAAQ,GAAKA,EAC3E,IAAI10B,EAAS24B,EAAS,GAEtB,GAAIA,EAAS72B,OAAS,EACpB,IAAK,IAAIxD,EAAI,EAAGA,EAAIq6B,EAAS72B,OAAQxD,IACnC0B,EAASA,EAAO2P,MAAMgpB,EAASr6B,IAGnC,MAAMiH,EAAQ,IAAIE,EAAM,IAAI4xB,EAAQqB,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAAIp1B,OAAQ,GAC7E,OAAOtD,EAAOi5B,SAAS1zB,IA+PvB6M,OApPF,SAAgBlK,EAAQnI,EAAGC,GACzB,OAAOA,EAAOoS,OAAOlK,EAAQnI,IAoP7BsS,SAzOF,SAAkBnK,EAAQnI,EAAGC,GAC3B,OAAOA,EAAOqS,SAASnK,EAAQnI,IAyO/Bm5B,UA/NF,WACE9J,QAAQC,IAAI,oCA+NZiI,OACA6B,WArCF,SAAoB5N,EAAQmJ,GAM1B,IAAI5xB,EAAIjB,UACJuf,GAAS,EACT/K,EAAI,OAEYrG,IAAhBlN,EAAEuT,GAAG+K,SACPA,EAASte,EAAEuT,KAAK+K,QAGdte,EAAEuT,GAAGvU,SACPgB,EAAIA,EAAEuT,IAGR,IAAI+iB,EAAQ,GACRC,EAAcv2B,EAAEhB,QAAUsf,EAAS,EAAI,GAC3C,IAAK,IAAI9iB,EAAI,EAAGA,EAAI+6B,EAAa/6B,IAC/B86B,EAAMxyB,KAAK0wB,EAAKx0B,EAAExE,GAAIwE,GAAGxE,EAAI,GAAKwE,EAAEhB,UAEtC,OAAO6N,EAAMypB,M,2KC/Zf,S,oFCAa,EAAAE,aAAe,EAAQ,IACvB,EAAAC,aAAe,EAAQ,IACpC,mBACa,EAAAC,gBAAkB,EAAQ,IAC1B,EAAAC,WAAa,EAAQ,IACrB,EAAAvvB,MAAQ,EAAQ,IAChB,EAAAwvB,MAAQ,EAAQ,IAChB,EAAAC,KAAO,EAAQ,IAId,EAAA5wB,KAAD,EAA2B,EAAQ,KAAS,IAAtC,EAAAwT,IAAG,MAAE,EAAAzQ,MAAK,QAAE,EAAAE,MAAK,S,gBCVpC,MAAM,IAACuQ,GAAO,EAAQ,KAChB,OAAC6M,GAAU,EAAQ,KACnB,eAACwC,GAAkB,EAAQ,KAC3B,UAACxkB,EAAS,MAAEwxB,GAAS,EAAQ,IAC7BgB,EAAW,EAAQ,GACnBvC,EAAU,EAAQ,GAClB7T,EAAU,EAAQ,GAwGxB,SAASqW,EAAetO,GAKtB,IAAI,EAACnsB,EAAC,GAAE0sB,GAAM9sB,OAAOoV,OAAO,GAJX,CACfhV,EAAG,EACH0sB,GAAI,GAEoCP,GAEtCuO,EAAK,CACP,CAAC,QAAU,GAAW,SACtB,CAAC,SAAW,EAAU,SACtB,EAAE,SAAW,EAAU,SACvB,EAAE,QAAU,GAAW,SACvB,CAAC,GAAW,QAAU,SACtB,CAAC,EAAU,QAAU,SACrB,CAAC,EAAU,SAAW,SACtB,CAAC,GAAW,SAAW,SACvB,EAAE,SAAW,SAAW,GACxB,CAAC,SAAW,SAAW,GACvB,CAAC,QAAU,QAAU,GACrB,EAAE,QAAU,QAAU,IAEpBC,EAAK,CAAC,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,GAAI,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,GAAI,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,GAAI,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,GAAI,GAAI,CAAC,EAAG,EAAG,GACjI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,GAAI,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,GAAI,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,GAAI,GAAI,GAAI,CAAC,GAAI,GAAI,GAAI,CAAC,EAAG,EAAG,IAEnGC,EAAoB,SAAU55B,EAAG0rB,EAAInkB,GACvC,IAAIiF,EAAKxM,EAAE,GACPyM,EAAKzM,EAAE,GACP43B,EAAK53B,EAAE,GACPL,EAAI4H,EACJhJ,EAAI,GACJs7B,EAAI,GAWR,IAAK,IAAI37B,EAAI,EAAGA,EAAIwtB,EAAIxtB,IACtB,IAAK,IAAI+X,EAAI,EAAGA,EAAIyV,EAAKxtB,EAAG+X,IAAK,CAC/B,IAAI4Q,EAAK3oB,EAAIwtB,EACT5E,GAAM5oB,EAAI,GAAKwtB,EACfoO,EAAK7jB,GAAKyV,EAAKxtB,GACf67B,GAAM9jB,EAAI,IAAMyV,EAAKxtB,GACrB87B,EAAKtO,EAAKxtB,EAAI,EAAI+X,GAAKyV,EAAKxtB,EAAI,GAAK,EACrC+7B,EAAI,GAERA,EAAE,GAAKC,EAAKA,EAAK1tB,EAAIC,EAAIqtB,GAAKlC,EAAI/Q,GAClCoT,EAAE,GAAKC,EAAKA,EAAK1tB,EAAIC,EAAIstB,GAAKnC,EAAI/Q,GAClCoT,EAAE,GAAKC,EAAKA,EAAK1tB,EAAIC,EAAIutB,GAAKpC,EAAI9Q,GAGlC,IAAK,IAAIV,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAIpnB,EAAImB,KAAK8C,KAAKg3B,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,IACzE,IAAK,IAAIjoB,EAAI,EAAGA,EAAI,EAAGA,IACrB87B,EAAE7T,GAAGjoB,IAAMa,EAOf,GAJAT,EAAEiI,KAAKyzB,EAAE,GAAIA,EAAE,GAAIA,EAAE,IACrBJ,EAAErzB,KAAK,CAAC7G,EAAGA,EAAI,EAAGA,EAAI,IACtBA,GAAK,EAEDsW,EAAIyV,EAAKxtB,EAAI,EAAG,CAClB,IAAIi8B,EAAKzO,EAAKxtB,EAAI,GAAK+X,EAAI,IAAMyV,EAAKxtB,EAAI,GAAK,EAC/C+7B,EAAE,GAAKC,EAAKA,EAAK1tB,EAAIC,EAAIstB,GAAKnC,EAAI/Q,GAClCoT,EAAE,GAAKC,EAAKA,EAAK1tB,EAAIC,EAAI0tB,GAAKvC,EAAI9Q,GAClCmT,EAAE,GAAKC,EAAKA,EAAK1tB,EAAIC,EAAIutB,GAAKpC,EAAI9Q,GAGlC,IAAK,IAAIV,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAIpnB,EAAImB,KAAK8C,KAAKg3B,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,GAAK6T,EAAE7T,GAAG,IACzE,IAAK,IAAIjoB,EAAI,EAAGA,EAAI,EAAGA,IACrB87B,EAAE7T,GAAGjoB,IAAMa,EAGfT,EAAEiI,KAAKyzB,EAAE,GAAIA,EAAE,GAAIA,EAAE,IACrBJ,EAAErzB,KAAK,CAAC7G,EAAGA,EAAI,EAAGA,EAAI,IACtBA,GAAK,GAIX,MAAO,CAACyJ,OAAQ7K,EAAG67B,UAAWP,EAAGtyB,OAAQ5H,IAG3C,MAAMu6B,EAAO,SAAUx3B,EAAG0H,EAAGyvB,GAC3B,IAAIQ,EAAK,EAAIR,EACTt7B,EAAI,GACR,IAAK,IAAIL,EAAI,EAAGA,EAAI,EAAGA,IACrBK,EAAEL,GAAKwE,EAAExE,GAAKm8B,EAAKjwB,EAAElM,GAAK27B,EAE5B,OAAOt7B,GAGL4sB,GACEA,EAAOO,KAAIA,EAAKvrB,KAAKgL,MAAMggB,EAAOO,GAAK,IAGzCA,GAAM,IAAGA,EAAK,GAElB,IAAIntB,EAAI,GACJs7B,EAAI,GACJtyB,EAAS,EAEb,IAAK,IAAIrJ,EAAI,EAAGA,EAAIy7B,EAAGj4B,OAAQxD,IAAK,CAClC,IAAIo8B,EAAIV,EAAkB,CAACF,EAAGC,EAAGz7B,GAAG,IAAKw7B,EAAGC,EAAGz7B,GAAG,IAAKw7B,EAAGC,EAAGz7B,GAAG,KAAMwtB,EAAInkB,GAC1EhJ,EAAIA,EAAEme,OAAO4d,EAAElxB,QACfywB,EAAIA,EAAEnd,OAAO4d,EAAEF,WACf7yB,EAAS+yB,EAAE/yB,OAEb,OAAOixB,EAAMx5B,EAAG0qB,EAAW,CAACtgB,OAAQ7K,EAAG67B,UAAWP,KA0IpD,SAASnQ,EAAWyB,GAClB,IAAIoP,EAAM,GACNC,EAAMrP,EAAOiP,WAAajP,EAAOtf,SACjC4uB,EAAStP,EAAOsP,QAAU,KAE9B,IAAK,IAAIv8B,EAAI,EAAGA,EAAIs8B,EAAI94B,OAAQxD,IAAK,CACnC,IAAIw8B,EAAK,GACT,IAAK,IAAIzkB,EAAI,EAAGA,EAAIukB,EAAIt8B,GAAGwD,OAAQuU,IACjCykB,EAAGzkB,GAAKkV,EAAO/hB,OAAOoxB,EAAIt8B,GAAG+X,IAG/B,IAAI/T,EAAI,GACR,IAAK,IAAI+T,EAAIukB,EAAIt8B,GAAGwD,OAAS,EAAGuU,GAAK,EAAGA,IACtC/T,EAAEsE,KAAK,IAAI4c,EAAQ,IAAI6T,EAAQyD,EAAGzkB,GAAG,GAAIykB,EAAGzkB,GAAG,GAAIykB,EAAGzkB,GAAG,MAE3D,IAAIhW,EAAIu5B,EAASp0B,cACbq1B,GAAUA,EAAOv8B,KACnB+B,EAAIu5B,EAAS3zB,OAAOC,UAAU20B,EAAOv8B,KAEvCq8B,EAAI/zB,KAAK,IAAIgzB,EAASt3B,EAAGjC,IAI3B,MAAM,aAAC0G,GAAgB,EAAQ,GAC/B,OAAOA,EAAa4zB,GAGtB58B,EAAOD,QAAU,CACf2rB,KA5WF,SAAc8B,GASZ,IAAI,MAACvD,EAAK,OAAE9f,EAAM,GAAE4jB,EAAE,KAAEqL,GAAQn4B,OAAOoV,OAAO,GAR7B,CACf+iB,KAAM,EACNxvB,OAAQ,CAAC,EAAG,EAAG,GACfqgB,OAAO,EACP9f,OAAQ,EACR4jB,GAAI,GAGsDP,GACxD5jB,EAAS,CAAC,EAAG,EAAG,GAChBrF,EAAI,KACJipB,GAAUA,EAAOzpB,SAAQQ,EAAIipB,GAC7BA,GAAUA,EAAO4L,MAAQ5L,EAAO4L,KAAKr1B,SAAQQ,EAAIipB,EAAO4L,MACxD5L,GAAUA,EAAO4L,OAAS5L,EAAO4L,KAAKr1B,SAAQq1B,EAAO5L,EAAO4L,MAC5D5L,GAA6B,iBAAXA,IAAsB4L,EAAO5L,GAC/CA,IAA2B,IAAjBA,EAAOvD,QACnBA,GAAQ,EACR9f,EAAS5F,GAAKA,EAAER,QAAUQ,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAM,GAAK60B,EAAO,IAE1D5L,GAAUA,EAAOrjB,SACnB8f,GAAQ,EACR9f,EAASqjB,EAAOrjB,QAGlB,IAAIxG,EAAIy1B,EACJx1B,EAAIw1B,EACJv1B,EAAIu1B,EACJ70B,GAAKA,EAAER,UACRJ,EAAGC,EAAGC,GAAKU,GAEdqF,EAAS,CAACjG,EAAI,EAAGC,EAAI,EAAGC,EAAI,GAC5B,IAAI5B,EAASgoB,EACTzL,EAAImN,YAAY,CAACxhB,OAAQ,CAACxG,EAAI,EAAGC,EAAI,EAAGC,EAAI,GAAIm5B,YAAa7yB,EAAQ+K,WAAY6Y,IACjFvP,EAAIkN,KAAK,CAACvhB,OAAQ,CAACxG,EAAI,EAAGC,EAAI,EAAGC,EAAI,KAQzC,OAPI2pB,GAAUA,EAAOpZ,QAAUoZ,EAAOpZ,OAAOrQ,OAC3C6F,EAAS,CAAC4jB,EAAOpZ,OAAO,GAAK,EAAIzQ,EAAI,EAAG6pB,EAAOpZ,OAAO,GAAK,EAAIxQ,EAAI,EAAG4pB,EAAOpZ,OAAO,GAAK,EAAIvQ,EAAI,GACxF2pB,IAA4B,IAAlBA,EAAOpZ,OAC1BxK,EAAS,CAAC,EAAG,EAAG,GACP4jB,IAA4B,IAAlBA,EAAOpZ,SAC1BxK,EAAS,CAACjG,EAAI,EAAGC,EAAI,EAAGC,EAAI,IAEtB+F,EAAO,IAAMA,EAAO,IAAMA,EAAO,GAAMP,EAAUO,EAAQ3H,GAAUA,GAmU3EwpB,OAlTF,SAAgB+B,GAOd,IAAI,EAACnsB,EAAC,GAAE0sB,EAAE,KAAEkP,GAAQh8B,OAAOoV,OAAO,GANjB,CACfhV,EAAG,EACH0sB,GAAI,GACJkP,KAAM,UAGwCzP,GAC5C5jB,EAAS,CAAC,EAAG,EAAG,GAChB4jB,GAA6B,iBAAXA,IACpBnsB,EAAImsB,GAIN,IAAII,EAAkB,aAATqP,EAAsBnB,EAAetO,GAAUhP,EAAIiN,OAAO,CAACthB,OAAQ9I,EAAG6T,WAAY6Y,IAU/F,OAPIP,GAAUA,EAAOpZ,QAAUoZ,EAAOpZ,OAAOrQ,OAC3C6F,EAAS,CAAC4jB,EAAOpZ,OAAO,GAAK,EAAI/S,EAAGmsB,EAAOpZ,OAAO,GAAK,EAAI/S,EAAGmsB,EAAOpZ,OAAO,GAAK,EAAI/S,GAC5EmsB,IAA4B,IAAlBA,EAAOpZ,OAC1BxK,EAAS,CAAC,EAAG,EAAG,GACP4jB,IAA4B,IAAlBA,EAAOpZ,SAC1BxK,EAAS,CAACvI,EAAGA,EAAGA,IAEVuI,EAAO,IAAMA,EAAO,IAAMA,EAAO,GAAMP,EAAUO,EAAQgkB,GAAUA,GA2R3EhC,SApJF,SAAkB4B,GAChB,MAAMM,EAAW,CACfzsB,EAAG,EACH67B,GAAI,EACJC,GAAI,EACJnN,EAAG,EACHjC,GAAI,GACJ9D,OAAO,GAET,IA+BIhoB,GA/BA,GAACi7B,EAAE,GAAEC,EAAE,EAAEnN,EAAC,GAAEjC,EAAE,MAAE9D,GAAShpB,OAAOoV,OAAO,GAAIyX,EAAUN,GACrD5jB,EAAS,CAAC,EAAG,EAAG,GAChB7E,EAAIjB,UA8BR,GA7BI0pB,GAAUA,EAAO3sB,IACnBq8B,EAAKC,EAAK3P,EAAO3sB,EAAI,GAEnB2sB,GAAUA,EAAOnsB,IACnB67B,EAAK1P,EAAOnsB,EACZ87B,EAAK3P,EAAOnsB,GAEVmsB,GAAUA,EAAOwC,IACnBA,EAAIxC,EAAOwC,GAETxC,IAAWA,EAAO0P,IAAM1P,EAAO2P,MACjCD,EAAK1P,EAAO0P,GACZC,EAAK3P,EAAO2P,GACR3P,EAAOwC,IAAGA,EAAIxC,EAAOwC,IAEvBxC,IAAWA,EAAO4P,IAAM5P,EAAO6P,MACjCH,EAAK1P,EAAO4P,GAAK,EACjBD,EAAK3P,EAAO6P,GAAK,GAGft4B,GAAKA,EAAE,IAAMA,EAAE,GAAGhB,SACpBgB,EAAIA,EAAE,GACNm4B,EAAKn4B,EAAE,GACPo4B,EAAKp4B,EAAE,GACPirB,EAAIjrB,EAAE,GACW,IAAbA,EAAEhB,SAAcgqB,EAAKhpB,EAAE,KAIzByoB,GAAWA,EAAOxK,OAASwK,EAAOvK,IACpChhB,EAASgoB,EACLzL,EAAIqN,gBAAgB,CAAC7I,MAAOwK,EAAOxK,MAAOC,IAAKuK,EAAOvK,IAAKqa,YAAaJ,EAAIK,UAAWJ,EAAIjoB,WAAY6Y,IACvGvP,EAAIoN,SAAS,CAAC5I,MAAOwK,EAAOxK,MAAOC,IAAKuK,EAAOvK,IAAKqa,YAAaJ,EAAIK,UAAWJ,EAAIjoB,WAAY6Y,QAC/F,CACL9rB,EAASgoB,EACLzL,EAAIqN,gBAAgB,CAAC7I,MAAO,CAAC,EAAG,EAAG,GAAIC,IAAK,CAAC,EAAG,EAAG+M,GAAIsN,YAAaJ,EAAIK,UAAWJ,EAAIjoB,WAAY6Y,IACnGvP,EAAIoN,SAAS,CAAC5I,MAAO,CAAC,EAAG,EAAG,GAAIC,IAAK,CAAC,EAAG,EAAG+M,GAAIsN,YAAaJ,EAAIK,UAAWJ,EAAIjoB,WAAY6Y,IAChG,IAAI1sB,EAAI67B,EAAKC,EAAKD,EAAKC,EACnB3P,GAAUA,EAAOpZ,QAAUoZ,EAAOpZ,OAAOrQ,OAC3C6F,EAAS,CAAC4jB,EAAOpZ,OAAO,GAAK,EAAI/S,EAAGmsB,EAAOpZ,OAAO,GAAK,EAAI/S,EAAGmsB,EAAOpZ,OAAO,IAAM4b,EAAI,EAAI,GACjFxC,IAA4B,IAAlBA,EAAOpZ,OAC1BxK,EAAS,CAAC,EAAG,GAAIomB,EAAI,GACZxC,IAA4B,IAAlBA,EAAOpZ,SAC1BxK,EAAS,CAAC,EAAG,EAAG,IAElB3H,EAAU2H,EAAO,IAAMA,EAAO,IAAMA,EAAO,GAAMP,EAAUO,EAAQ3H,GAAUA,EAE/E,OAAOA,GA0FP65B,iBACA0B,MA1EF,SAAehQ,GAQbA,EAASvsB,OAAOoV,OAAO,GAPN,CACfonB,GAAI,EACJC,GAAI,EACJC,IAAK,GACLC,IAAK,GACLC,KAAM,GAE6BrQ,GAQrC,IAAI,GAACiQ,EAAE,GAAEC,EAAE,IAAEC,EAAG,IAAEC,EAAG,KAAEC,GAAQrQ,EAE3BmQ,EAAM,IAAGA,EAAM,GACfC,EAAM,IAAGA,EAAM,GAEnB,IAAIE,EAAazS,EAAO,CAAChqB,EAAGo8B,EAAI1P,GAAI4P,EAAKvpB,QAAQ,IAKjD,OAHIypB,IAAMC,EAAaA,EAAWva,QAAQsa,IAC7BhQ,EAAe,CAACE,GAAI6P,GAAMv0B,EAAU,CAACq0B,EAAI,EAAG,GAAII,KAmD7D/R,e,gBC1YF,MAAM3kB,EAAY,EAAQ,IACpB1D,EAAW,EAAQ,GACnBgE,EAAQ,EAAQ,GAsFtB1H,EAAOD,QAAU,CACforB,oCApF0C,SAAU4S,GACpDA,EAAK7C,SAAW,SAAU1zB,GACxB,OAAOxD,KAAK+B,UAAUqB,EAAUiV,UAAU7U,KAG5Cu2B,EAAKC,UAAY,WACf,IAAIx2B,EAAQ,IAAIE,EAAMhE,EAASe,OAAO,EAAG,EAAG,GAAI,GAChD,OAAOT,KAAKk3B,SAAS1zB,IAGvBu2B,EAAKE,UAAY,WACf,IAAIz2B,EAAQ,IAAIE,EAAMhE,EAASe,OAAO,EAAG,EAAG,GAAI,GAChD,OAAOT,KAAKk3B,SAAS1zB,IAGvBu2B,EAAKG,UAAY,WACf,IAAI12B,EAAQ,IAAIE,EAAMhE,EAASe,OAAO,EAAG,EAAG,GAAI,GAChD,OAAOT,KAAKk3B,SAAS1zB,IAGvBu2B,EAAK10B,UAAY,SAAU9E,GACzB,OAAOP,KAAK+B,UAAUqB,EAAUyC,YAAYtF,KAG9Cw5B,EAAKlD,MAAQ,SAAUqB,GACrB,OAAOl4B,KAAK+B,UAAUqB,EAAUqV,QAAQyf,KAG1C6B,EAAKhD,QAAU,SAAUoD,GACvB,OAAOn6B,KAAK+B,UAAUqB,EAAUsU,UAAUyiB,KAG5CJ,EAAK/C,QAAU,SAAUmD,GACvB,OAAOn6B,KAAK+B,UAAUqB,EAAUuU,UAAUwiB,KAG5CJ,EAAKxa,QAAU,SAAU4a,GACvB,OAAOn6B,KAAK+B,UAAUqB,EAAUwU,UAAUuiB,KAG5CJ,EAAKjD,OAAS,SAAUhf,EAAgBC,EAActV,GACpD,OAAOzC,KAAK+B,UAAUqB,EAAUyU,SAASC,EAAgBC,EAActV,KAGzEs3B,EAAKK,kBAAoB,SAAU7O,EAAO8O,EAAMC,EAAOC,GACrDA,EAAWA,GAAY,CAAC,EAAG,EAAG,GAE9B,IAAIC,EAAMp3B,EAAUwU,UAAU2T,GAC1BkP,EAAKr3B,EAAUsU,UAAU2iB,GACzBK,EAAMt3B,EAAUwU,UAAU0iB,GAC1BK,EAAIv3B,EAAUyC,YAAY,IAAInG,EAAS66B,IAE3C,OAAOv6B,KAAK+B,UAAU24B,EAAIplB,SAASmlB,GAAInlB,SAASklB,GAAKllB,SAASqlB,KAGhEZ,EAAKa,eAAiB,SAAUrP,EAAO8O,EAAMC,EAAOC,GAClDA,EAAWA,GAAY,CAAC,EAAG,EAAG,GAE9B,IAAIE,EAAKr3B,EAAUsU,UAAU6T,GACzBsP,EAAKz3B,EAAUuU,UAAU0iB,GACzBS,EAAK13B,EAAUwU,UAAU0iB,GACzBK,EAAIv3B,EAAUyC,YAAY,IAAInG,EAAS66B,IAE3C,OAAOv6B,KAAK+B,UAAU+4B,EAAGxlB,SAASulB,GAAIvlB,SAASmlB,GAAInlB,SAASqlB,MAsB9DvT,wBAjB8B,SAAU2S,EAAM/oB,GAC9C+oB,EAAK3pB,OAAS,SAAU2qB,IACtBA,EAAQz6B,MAAMnC,UAAUsI,IAAI/J,KAAKoD,WAAW,SAAUiB,GACpD,OAAOA,MAGEhB,SACTg7B,EAAQ/pB,EAAK5I,SAEf,IAAIK,EAAIzI,KAAK8P,YACb,OAAO9P,KAAKqF,UAAU2L,EAAKvK,KAAI,SAAU1F,GACvC,OAAOg6B,EAAMC,QAAQj6B,IAAM,IAAM0H,EAAE,GAAG1H,GAAK0H,EAAE,GAAG1H,IAAM,EAAI,U,gBCpFhE,MAAM,UAACpC,EAAS,IAAEG,GAAO,EAAQ,GAE3BuE,GADS,EAAQ,GACP,EAAQ,IAsIxB,MAAM43B,EAAkB,WACtBj7B,KAAKk7B,OAAS,KACdl7B,KAAKm7B,SAAW,GAChBn7B,KAAK0H,QAAU,KACf1H,KAAKo7B,SAAU,GAGjBH,EAAgB98B,UAAY,CAG1Bgd,YAAa,SAAUjR,GAErB,IAAKlK,KAAKq7B,aACR,MAAM,IAAI76B,MAAM,oBAElB,IAAIytB,EAAQjuB,KACZkK,EAASzD,KAAI,SAAUiB,GACrBumB,EAAMqN,SAAS5zB,OAOnB6zB,OAAQ,WACN,IAAKv7B,KAAKo7B,QAAS,CAGjB,GAFAp7B,KAAKo7B,SAAU,EAEXz8B,EAAW,CACb,GAAIqB,KAAKq7B,aAAc,MAAM,IAAI76B,MAAM,oBACvC,GAAIR,KAAKm7B,SAASp7B,OAAQ,MAAM,IAAIS,MAAM,oBAI5C,IAAIg7B,EAAkBx7B,KAAKk7B,OAAOC,SAC9B5+B,EAAIi/B,EAAgBR,QAAQh7B,MAChC,GAAIzD,EAAI,EAAG,MAAM,IAAIiE,MAAM,oBAC3Bg7B,EAAgB/xB,OAAOlN,EAAG,GAG1ByD,KAAKk7B,OAAOO,iCAIhBC,UAAW,WACT,OAAO17B,KAAKo7B,SAGdC,WAAY,WACV,OAAQr7B,KAAKk7B,QAIfjoB,OAAQ,WACN,IAAKjT,KAAKq7B,aAAc,MAAM,IAAI76B,MAAM,oBACxCR,KAAK27B,aAGPxN,WAAY,WACV,IAAKnuB,KAAK0H,QAAS,MAAM,IAAIlH,MAAM,oBACnC,OAAOR,KAAK0H,SAGdk0B,YAAa,SAAUl7B,GACrB,IAEInE,EAAG+X,EAAG9X,EAAGq/B,EAFTV,EAAW,CAACn7B,MACZ87B,EAAQ,CAACX,GAEb,IAAK5+B,EAAI,EAAGA,EAAIu/B,EAAM/7B,SAAUxD,EAE9B,IADA4+B,EAAWW,EAAMv/B,GACZ+X,EAAI,EAAG9X,EAAI2+B,EAASp7B,OAAQuU,EAAI9X,EAAG8X,IACtCunB,EAAOV,EAAS7mB,GACZunB,EAAKn0B,QAEPhH,EAAOmE,KAAKg3B,EAAKn0B,SAGjBo0B,EAAMj3B,KAAKg3B,EAAKV,WAUxBY,aAAc,SAAUv4B,EAAOw4B,EAAoBC,EAAmBC,EAAYC,GAChF,GAAIn8B,KAAKm7B,SAASp7B,OAAQ,CACxB,IACIxD,EACA+X,EACA9X,EACAq/B,EACAO,EALAN,EAAQ,CAAC97B,KAAKm7B,UAMlB,IAAK5+B,EAAI,EAAGA,EAAIu/B,EAAM/7B,OAAQxD,IAE5B,IADA6/B,EAAQN,EAAMv/B,GACT+X,EAAI,EAAG9X,EAAI4/B,EAAMr8B,OAAQuU,EAAI9X,EAAG8X,IACnCunB,EAAOO,EAAM9nB,GACTunB,EAAKV,SAASp7B,OAChB+7B,EAAMj3B,KAAKg3B,EAAKV,UAGhBU,EAAKQ,cAAc74B,EAAOw4B,EAAoBC,EAAmBC,EAAYC,QAKnFn8B,KAAKq8B,cAAc74B,EAAOw4B,EAAoBC,EAAmBC,EAAYC,IAKjFE,cAAe,SAAU74B,EAAOw4B,EAAoBC,EAAmBC,EAAYC,GACjF,IAAIz0B,EAAU1H,KAAK0H,QACnB,GAAIA,EAAS,CACX,IAAI40B,EAAQ50B,EAAQ5B,iBAChBy2B,EAAeD,EAAM,GAAKx9B,EAC1B8I,EAAcpE,EAAMX,OACpB25B,EAAeF,EAAM,GACrBz/B,EAAI+K,EAAYzG,IAAIq7B,GAAgBh5B,EAAM4G,EAC9C,GAAIvN,EAAI0/B,EACNL,EAAWr3B,KAAK7E,WACX,GAAInD,GAAK0/B,EACdJ,EAAUt3B,KAAK7E,UACV,CACL,IAAIy8B,EAnPZ,SAA6Bj5B,EAAOkE,GAClC,IAAIhH,EAAS,CACXu4B,KAAM,KACN55B,MAAO,KACPC,KAAM,MAGJsI,EAAcpE,EAAMX,OACpBS,EAAWoE,EAAQpE,SACnBgC,EAAchC,EAASvD,OAC3B,GAAI2H,EAAQlE,MAAM7B,OAAO6B,GACvB9C,EAAOu4B,KAAO,MACT,CACL,IAAIyD,EAAQl5B,EAAM4G,EACduyB,GAAW,EACXC,GAAU,EACVC,EAAe,GACfC,GAAUh+B,EACd,IAAK,IAAIvC,EAAI,EAAGA,EAAI+I,EAAa/I,IAAK,CACpC,IAAIkB,EAAImK,EAAYzG,IAAImC,EAAS/G,GAAGqH,KAAO84B,EACvCK,EAAUt/B,EAAI,EAClBo/B,EAAah4B,KAAKk4B,GACdt/B,EAAIqB,IAAK69B,GAAW,GACpBl/B,EAAIq/B,IAAQF,GAAU,GAE5B,GAAMD,GAAeC,EAId,GAAKA,EAEL,GAAKD,EAEL,CAELj8B,EAAOu4B,KAAO,EACd,IAAI+D,EAAgB,GAChBC,EAAe,GACfF,EAASF,EAAa,GAC1B,IAAK,IAAIhwB,EAAc,EAAGA,EAAcvH,EAAauH,IAAe,CAClE,IAAIhG,EAASvD,EAASuJ,GAClBqwB,EAAkBrwB,EAAc,EAChCqwB,GAAmB53B,IAAa43B,EAAkB,GACtD,IAAIC,EAAaN,EAAaK,GAC9B,GAAIH,IAAWI,EAETJ,EACFE,EAAap4B,KAAKgC,GAElBm2B,EAAcn4B,KAAKgC,OAEhB,CAEL,IAAIN,EAAQM,EAAOjD,IACfqE,EAAY3E,EAAS45B,GAAiBt5B,IACtCw5B,GArEmBC,EAsEG92B,EAtEK+2B,EAsEEr1B,EAtEMs1B,EAsEK/5B,EAAMoH,uBAAuBrE,EAAO0B,GArEjFo1B,EAAO57B,WAAW87B,GAAqBF,EAAO57B,WAAW67B,IAsEpDE,EAAqB32B,EAAO8E,YAAYrI,EAAS45B,GAAkBE,GACnEL,GACFE,EAAap4B,KAAKgC,GAClBo2B,EAAap4B,KAAK24B,GAClBR,EAAcn4B,KAAK24B,KAEnBR,EAAcn4B,KAAKgC,GACnBm2B,EAAcn4B,KAAK24B,GACnBP,EAAap4B,KAAK24B,IAGtBT,EAASI,EAGX,IAAIM,EAAc3+B,EAAMA,EACxB,GAAIm+B,EAAal9B,QAAU,EAAG,CAC5B,IAAIqO,EAAa6uB,EAAaA,EAAal9B,OAAS,GACpD,IAAK,IAAI8M,EAAc,EAAGA,EAAcowB,EAAal9B,OAAQ8M,IAAe,CAC1E,IAAIhG,EAASo2B,EAAapwB,GACtBhG,EAAOjD,IAAIlC,kBAAkB0M,EAAWxK,KAAO65B,IACjDR,EAAaxzB,OAAOoD,EAAa,GACjCA,KAEFuB,EAAavH,GAGjB,GAAIm2B,EAAcj9B,QAAU,EAAG,CAC7B,IAAIqO,EAAa4uB,EAAcA,EAAcj9B,OAAS,GACtD,IAAK,IAAI8M,EAAc,EAAGA,EAAcmwB,EAAcj9B,OAAQ8M,IAAe,CAC3E,IAAIhG,EAASm2B,EAAcnwB,GACvBhG,EAAOjD,IAAIlC,kBAAkB0M,EAAWxK,KAAO65B,IACjDT,EAAcvzB,OAAOoD,EAAa,GAClCA,KAEFuB,EAAavH,GAGbm2B,EAAcj9B,QAAU,IAC1BW,EAAOrB,MAAQ,IAAIgE,EAAQ25B,EAAet1B,EAAQnE,OAAQmE,EAAQlE,QAEhEy5B,EAAal9B,QAAU,IACzBW,EAAOpB,KAAO,IAAI+D,EAAQ45B,EAAcv1B,EAAQnE,OAAQmE,EAAQlE,aAlElE9C,EAAOu4B,KAAO,OAFdv4B,EAAOu4B,KAAO,MALe,CAE7B,IAAIx7B,EAAImK,EAAYzG,IAAIuG,EAAQlE,MAAMX,QACtCnC,EAAOu4B,KAAQx7B,GAAK,EAAK,EAAI,GA1CnC,IAAiC4/B,EAAQC,EAAQC,EAoH/C,OAAO78B,EA6IiBg9B,CAAoBl6B,EAAOkE,GAC7C,OAAQ+0B,EAAYxD,MAClB,KAAK,EAEH+C,EAAmBn3B,KAAK7E,MACxB,MAEF,KAAK,EAEHi8B,EAAkBp3B,KAAK7E,MACvB,MAEF,KAAK,EAEHk8B,EAAWr3B,KAAK7E,MAChB,MAEF,KAAK,EAEHm8B,EAAUt3B,KAAK7E,MACf,MAEF,KAAK,EAEH,GAAIy8B,EAAYp9B,MAAO,CACrB,IAAIs+B,EAAY39B,KAAKs7B,SAASmB,EAAYp9B,OAC1C68B,EAAWr3B,KAAK84B,GAElB,GAAIlB,EAAYn9B,KAAM,CACpB,IAAIs+B,EAAW59B,KAAKs7B,SAASmB,EAAYn9B,MACzC68B,EAAUt3B,KAAK+4B,QAa3BtC,SAAU,SAAU5zB,GAClB,IAAIm2B,EAAW,IAAI5C,EAInB,OAHA4C,EAAS3C,OAASl7B,KAClB69B,EAASn2B,QAAUA,EACnB1H,KAAKm7B,SAASt2B,KAAKg5B,GACZA,GAGTlC,UAAW,WACT,IAEIp/B,EAAG+X,EAAG9X,EAAGq/B,EAFTV,EAAW,CAACn7B,MACZ87B,EAAQ,CAACX,GAEb,IAAK5+B,EAAI,EAAGA,EAAIu/B,EAAM/7B,OAAQxD,IAE5B,IADA4+B,EAAWW,EAAMv/B,GACZ+X,EAAI,EAAG9X,EAAI2+B,EAASp7B,OAAQuU,EAAI9X,EAAG8X,IACtCunB,EAAOV,EAAS7mB,GACZunB,EAAKn0B,UACPm0B,EAAKn0B,QAAUm0B,EAAKn0B,QAAQvC,WAE9B22B,EAAMj3B,KAAKg3B,EAAKV,WAKtBM,6BAA8B,WAC5B,IAAII,EAAO77B,KACX,KAAO67B,EAAKn0B,SACVm0B,EAAKn0B,QAAU,KACXm0B,EAAKX,SACPW,EAAOA,EAAKX,UAUpB,MAAMnhB,EAAO,SAAU7P,GACrBlK,KAAK89B,YAAc,IAAI7C,EACvBj7B,KAAK+9B,SAAW,IAAIC,EAAK,MACrB9zB,GAAUlK,KAAKmb,YAAYjR,IAGjC6P,EAAK5b,UAAY,CACf8U,OAAQ,WACNjT,KAAK89B,YAAY7qB,SACjBjT,KAAK+9B,SAAS9qB,UAKhB4H,OAAQ,SAAUrM,EAAMyvB,GACtBA,IAA4BA,EAC5Bj+B,KAAK+9B,SAASljB,OAAOrM,EAAMyvB,IAG7BnjB,YAAa,WACX,IAAIpa,EAAS,GAEb,OADAV,KAAK89B,YAAYlC,YAAYl7B,GACtBA,GAGTya,YAAa,SAAUjR,GACrB,IAAI+jB,EAAQjuB,KACRk+B,EAAmBh0B,EAASzD,KAAI,SAAUpI,GAC5C,OAAO4vB,EAAM6P,YAAYxC,SAASj9B,MAEpC2B,KAAK+9B,SAASI,oBAAoBD,KAYtC,MAAMF,EAAO,SAAU9C,GACrBl7B,KAAKwD,MAAQ,KACbxD,KAAKX,MAAQ,KACbW,KAAKV,KAAO,KACZU,KAAKk+B,iBAAmB,GACxBl+B,KAAKk7B,OAASA,GAGhB8C,EAAK7/B,UAAY,CAEf8U,OAAQ,WACN,IACI4oB,EADAC,EAAQ,CAAC97B,MAEb,IAAK,IAAIzD,EAAI,EAAGA,EAAIu/B,EAAM/7B,OAAQxD,IAAK,CACrCs/B,EAAOC,EAAMv/B,GACTs/B,EAAKr4B,QAAOq4B,EAAKr4B,MAAQq4B,EAAKr4B,MAAM2B,WACpC02B,EAAKx8B,OAAOy8B,EAAMj3B,KAAKg3B,EAAKx8B,OAC5Bw8B,EAAKv8B,MAAMw8B,EAAMj3B,KAAKg3B,EAAKv8B,MAC/B,IAAI8+B,EAAOvC,EAAKx8B,MAChBw8B,EAAKx8B,MAAQw8B,EAAKv8B,KAClBu8B,EAAKv8B,KAAO8+B,IAMhBC,aAAc,SAAUH,EAAkBD,GACxC,IACIpC,EADA73B,EAAO,CAAC,KAAQhE,KAAM,iBAAoBk+B,GAE1C1H,EAAQ,GAEZ,EAAG,CAKD,GAJAqF,EAAO73B,EAAK63B,KACZqC,EAAmBl6B,EAAKk6B,iBAGpBrC,EAAKr4B,MAAO,CACd,IAAI24B,EAAY,GACZD,EAAa,GACbF,EAAqBiC,EAA0B9B,EAAYD,EAC3D14B,EAAQq4B,EAAKr4B,MACb86B,EAAsBJ,EAAiBn+B,OAC3C,IAAK,IAAIxD,EAAI,EAAGA,EAAI+hC,EAAqB/hC,IAAK,CAC5C,IAAIgiC,EAAQL,EAAiB3hC,GACxBgiC,EAAM7C,aACT6C,EAAMxC,aAAav4B,EAAOw4B,EAAoBG,EAAWD,EAAYC,GAIrEN,EAAKx8B,OAAU68B,EAAWn8B,OAAS,GACrCy2B,EAAM3xB,KAAK,CAAC,KAAQg3B,EAAKx8B,MAAO,iBAAoB68B,IAEtD,IAAIsC,EAAerC,EAAUp8B,OAC7B,GAAI87B,EAAKv8B,MAASk/B,EAAe,EAC/BhI,EAAM3xB,KAAK,CAAC,KAAQg3B,EAAKv8B,KAAM,iBAAoB68B,SAGnD,IAAK,IAAI5/B,EAAI,EAAGA,EAAIiiC,EAAcjiC,IAChC4/B,EAAU5/B,GAAGg/B,SAInBv3B,EAAOwyB,EAAMiI,iBACY,IAAX,IAKlB5jB,OAAQ,SAAUrM,EAAMyvB,GACtB,IAAIpC,EAAO77B,KACPw2B,EAAQ,GACZ,GACMqF,EAAKqC,iBAAiBn+B,OAAS,GACjCyO,EAAKuvB,SAASM,aAAaxC,EAAKqC,iBAAkBD,GAEhDpC,EAAKx8B,OAAOm3B,EAAM3xB,KAAKg3B,EAAKx8B,OAC5Bw8B,EAAKv8B,MAAMk3B,EAAM3xB,KAAKg3B,EAAKv8B,MAC/Bu8B,EAAOrF,EAAMiI,iBACY,IAAX,IAGlBN,oBAAqB,SAAUD,GAC7B,IACIrC,EADA73B,EAAO,CAAC,KAAQhE,KAAM,iBAAoBk+B,GAE1C1H,EAAQ,GACZ,EAAG,CAID,GAHAqF,EAAO73B,EAAK63B,KAGoB,KAFhCqC,EAAmBl6B,EAAKk6B,kBAEHn+B,OAAc,CACjCiE,EAAOwyB,EAAMiI,MACb,SAEF,IAAIxQ,EAAQ4N,EACZ,IAAKA,EAAKr4B,MAAO,CACf,IAAIk7B,EAAYR,EAAiB,GAAG/P,aAAa3qB,MACjDq4B,EAAKr4B,MAAQk7B,EAEf,IAAIxC,EAAa,GACbC,EAAY,GAEhB,IAAK,IAAI5/B,EAAI,EAAGyB,EAAIkgC,EAAiBn+B,OAAQxD,EAAIyB,IAAKzB,EACpD2hC,EAAiB3hC,GAAGw/B,aAAa9N,EAAMzqB,MAAOyqB,EAAMiQ,iBAAkB/B,EAAWD,EAAYC,GAG3FD,EAAWn8B,OAAS,IACjB87B,EAAKx8B,QAAOw8B,EAAKx8B,MAAQ,IAAI2+B,EAAKnC,IACvCrF,EAAM3xB,KAAK,CAAC,KAAQg3B,EAAKx8B,MAAO,iBAAoB68B,KAElDC,EAAUp8B,OAAS,IAChB87B,EAAKv8B,OAAMu8B,EAAKv8B,KAAO,IAAI0+B,EAAKnC,IACrCrF,EAAM3xB,KAAK,CAAC,KAAQg3B,EAAKv8B,KAAM,iBAAoB68B,KAGrDn4B,EAAOwyB,EAAMiI,iBACY,IAAX,IAGlBE,sBAAuB,SAAUpK,EAASqK,GACpCA,EAAW,GACT5+B,KAAKk7B,SACP3G,EAAQ1vB,KAAK7E,KAAKk7B,OAAO13B,MAAMX,QAC/B7C,KAAKk7B,OAAOyD,sBAAsBpK,EAASqK,EAAW,MAM9D5iC,EAAOD,QAAUge,G,gBCjgBjB,MAAM,IAACjb,GAAO,EAAQ,IAChB,aAACgK,GAAgB,EAAQ,GAsB/B9M,EAAOD,QAAU,CAAC2wB,eAlBK,SAAUmS,EAASC,EAAOC,EAASC,GACxD,GAAIF,EAAMn9B,OAAOo9B,IAAYC,EAAMr9B,OAAOk9B,GAAU,CAElD,GADQG,EAAMh+B,MAAM+9B,GAASx9B,OAAOT,KAAKg+B,EAAM99B,MAAM69B,GAASt9B,QAAQxB,SAC9DjB,EACN,OAAO,MAEJ,CACL,IAAImgC,EAAKH,EAAM99B,MAAM69B,GACjBzF,EAAK4F,EAAMh+B,MAAM+9B,GAErB,GAAIvgC,KAAKqC,IAAIo+B,EAAGz9B,MAAM43B,IAAO,KAAM,OAAO,EAC1C,IAAI8F,EAASp2B,GAAcm2B,EAAGt/B,EAAGy5B,EAAGz5B,GAAIs/B,EAAGr/B,EAAGw5B,EAAGx5B,EAAGi/B,EAAQl/B,EAAIo/B,EAAQp/B,EAAGk/B,EAAQj/B,EAAIm/B,EAAQn/B,GAC/F,GAAKs/B,EAAO,GAAK,MAAUA,EAAO,GAAK,SAAcA,EAAO,GAAK,MAAUA,EAAO,GAAK,QAAW,OAAO,EAG3G,OAAO,K,sTCpBF,IAAAn1B,EAAA,KAAAA,MAWP,mBACE,IAKI/M,EALE8sB,EAAW,CACfqV,WAAW,GAGT93B,EAAU,EAAH,GAAOyiB,GAEdvtB,EAAI,EACJwE,EAAIjB,UAEJiB,EAAE,GAAGhB,SAAQgB,EAAIA,EAAE,IAEnB,cAAeA,EAAE,KACnBsG,EAAUpK,OAAOoV,OAAO,GAAIyX,EAAU/oB,EAAE,IACxC/D,EAAI+D,EAAExE,MAGRS,EAAI+D,EAAExE,KAGiB,iBAAVwE,EAAExE,IAAqBwN,EAAMhJ,EAAExE,KAAO8K,EAAQ83B,YACzDniC,EAAI+D,EAAExE,GAAGuI,QAAQ,CAACc,OAAQ,CAAC,EAAG,EAAG,OAEnC,KAAOrJ,EAAIwE,EAAEhB,OAAQxD,IAAK,CACxB,IAAIgL,EAAMxG,EAAExE,GAEW,iBAAVwE,EAAExE,IAAqBwN,EAAMhJ,EAAExE,KAAO8K,EAAQ83B,YACzD53B,EAAMxG,EAAExE,GAAGuI,QAAQ,CAACc,OAAQ,CAAC,EAAG,EAAG,OAErC5I,EAAIA,EAAE4Q,MAAMrG,GAEd,OAAOvK,I,8EC1CF,IAAA+M,EAAA,KAAAA,MAaP,wBACE,IAAI9L,EACA1B,EAAI,EACJwE,EAAIjB,UAER,IADIiB,EAAE,GAAGhB,SAAQgB,EAAIA,EAAE,IAClB9C,EAAS8C,EAAExE,KAAMA,EAAIwE,EAAEhB,OAAQxD,IAEhC0B,EADE8L,EAAMhJ,EAAExE,IACD0B,EAAO0S,SAAS5P,EAAExE,IAElB0B,EAAO0S,SAAS5P,EAAExE,GAAGwH,SAAS,EAAG,EAAG,IAGjD,OAAO9F,I,8ECzBF,IAAA8L,EAAA,KAAAA,MAYP,0BACE,IAAI9L,EACA1B,EAAI,EACJwE,EAAIjB,UAER,IADIiB,EAAE,GAAGhB,SAAQgB,EAAIA,EAAE,IAClB9C,EAAS8C,EAAExE,KAAMA,EAAIwE,EAAEhB,OAAQxD,IAEhC0B,EADE8L,EAAMhJ,EAAExE,IACD0B,EAAO4S,UAAU9P,EAAExE,IAEnB0B,EAAO4S,UAAU9P,EAAExE,GAAGwH,SAAS,EAAG,EAAG,IAGlD,OAAO9F,I,gBCxBT,MAAMswB,EAAe,EAAQ,KACvB,IAACzvB,GAAO,EAAQ,GAChB0O,EAAO,EAAQ,IAEfmgB,EAAkB,WACtB3tB,KAAKwuB,cAAgB,IAAID,EAAa,EAAGzvB,IAG3C6uB,EAAgBxvB,UAAY,CAC1B2wB,UAAW,SAAUC,GACnB,IAAI1Z,EAAW,CAAC0Z,EAAanrB,IAAI3D,GAAI8uB,EAAanrB,IAAIzD,IAItD,OAHaH,KAAKwuB,cAAcQ,eAAe3Z,GAAU,SAAU+C,GACjE,OAAO2W,MAKXV,QAAS,SAAU+Q,GACjB,IAAIntB,EAAUjS,KAAK8uB,UAAUsQ,EAAWntB,SACpCC,EAAUlS,KAAK8uB,UAAUsQ,EAAWltB,SACxC,OAAO,IAAI1E,EAAKyE,EAASC,KAI7BlW,EAAOD,QAAU4xB,G,gBCxBjB,MAAM,IAAC7uB,GAAO,EAAQ,GAChBsW,EAAmB,EAAQ,KAC3B,+BAAC1L,EAA8B,aAAET,EAAY,aAAET,GAAgB,EAAQ,GACvErF,EAAS,EAAQ,GACjB1D,EAAW,EAAQ,GACnBiZ,EAAS,EAAQ,IACjBrV,EAAU,EAAQ,GAGlBg8B,EAA0B,SAAUhC,EAAQC,EAAQC,GACxD,OAAOF,EAAO57B,WAAW87B,GAAqBF,EAAO57B,WAAW67B,IAiYlEthC,EAAOD,QA5X6B,SAAUw0B,EAAgBD,GAC5D,IAAIrjB,EAAcsjB,EAAexwB,OACjC,GAAIkN,EAAc,EAAG,CACnB,IAAIzJ,EAAQ+sB,EAAe,GAAG/sB,MAC1BD,EAASgtB,EAAe,GAAGhtB,OAC3BwD,EAAa,IAAIqO,EAAiB5R,GAClC87B,EAAoB,GACpBC,EAAuB,GACvBC,EAA0B,GAC1BC,EAAsB,GACtBC,EAA8B,GAG9BC,EAAkB,GAKlBC,EAA2B,EAAM9gC,EAAM,GAC3C,IAAK,IAAIyO,EAAe,EAAGA,EAAeN,EAAaM,IAAgB,CACrE,IAAIsyB,EAAStP,EAAehjB,GACxBuyB,EAAa,GACbC,EAAgB,GAChBz6B,EAAcu6B,EAAOv8B,SAASvD,OAC9BigC,GAAY,EAChB,GAAI16B,EAAc,EAAG,CACnB,IAAI26B,EAAMC,EAAMC,EAChB,IAAK,IAAI5jC,EAAI,EAAGA,EAAI+I,EAAa/I,IAAK,CACpC,IAKI6jC,EALAC,EAAQt5B,EAAWG,KAAK24B,EAAOv8B,SAAS/G,GAAGqH,KAC3C08B,EAAeT,EAAOv8B,SAAS/G,GAAGkP,GAGlC80B,EAAiB/hC,KAAKgL,MAAM62B,EAAMzgC,EAAIggC,GAEtCW,KAAkBZ,EACpBS,EAAOT,EAAgBY,GACdA,EAAiB,KAAKZ,EAC/BS,EAAOT,EAAgBY,EAAiB,GAC/BA,EAAiB,KAAKZ,EAC/BS,EAAOT,EAAgBY,EAAiB,IAExCH,EAAOC,EAAMzgC,EACb+/B,EAAgBY,GAAkBF,EAAMzgC,GAE1CygC,EAAQ5gC,EAASgB,OAAO4/B,EAAM1gC,EAAGygC,GACjCN,EAAWj7B,KAAKw7B,GAChBN,EAAcl7B,KAAKy7B,GACnB,IAAI1gC,EAAIygC,EAAMzgC,GACH,IAANrD,GAAaqD,EAAIqgC,KACpBA,EAAOrgC,EACPogC,EAAWzjC,IAEF,IAANA,GAAaqD,EAAIsgC,KACpBA,EAAOtgC,EACPugC,EAAW5jC,GAEPqD,KAAK8/B,IACTA,EAA4B9/B,GAAK,IAEnC8/B,EAA4B9/B,GAAG2N,IAAgB,EAE7C0yB,GAAQC,GAEVJ,EAAa,GACbC,EAAgB,GAChBz6B,EAAc,EACd06B,GAAY,IAENC,KAAQR,IACZA,EAAoBQ,GAAQ,IAE9BR,EAAoBQ,GAAMp7B,KAAK0I,IAInCuyB,EAAWp5B,UACXq5B,EAAcr5B,UACds5B,EAAW16B,EAAc06B,EAAW,EACpCV,EAAkBz6B,KAAKi7B,GACvBP,EAAqB16B,KAAKk7B,GAC1BP,EAAwB36B,KAAKm7B,GAE/B,IAAIQ,EAAe,GACnB,IAAK,IAAIC,KAAef,EAA6Bc,EAAa37B,KAAK47B,GACvED,EAAavM,KAAKzrB,GAalB,IAAIk4B,EAAiB,GACjBC,EAAoB,GACxB,IAAK,IAAIC,EAAS,EAAGA,EAASJ,EAAazgC,OAAQ6gC,IAAU,CAC3D,IAuDIC,EAvDAC,EAAmB,GACnBC,EAAwBP,EAAaI,GACrCH,EAAc9iB,OAAOojB,GAOrBC,EAA2BtB,EAA4BqB,GAC3D,IAAK,IAAIE,EAAqB,EAAGA,EAAqBP,EAAe3gC,SAAUkhC,EAAoB,CACjG,IAAIC,EAAgBR,EAAeO,GAC/B1zB,EAAe2zB,EAAc3zB,aACjC,GAAIyzB,EAAyBzzB,GAAe,CAE1C,IAAIuyB,EAAaR,EAAkB/xB,GAC/BwyB,EAAgBR,EAAqBhyB,GACrCjI,EAAcw6B,EAAW//B,OACzBohC,EAAqBD,EAAcE,gBACnCC,EAAsBH,EAAcI,iBAExC,OAAa,CACX,IAAIC,EAAsBJ,EAAqB,EAE/C,GADII,GAAuBj8B,IAAai8B,EAAsB,GAC1DzB,EAAWyB,GAAqB3hC,IAAM6gC,EAAa,MACvDU,EAAqBI,EAEvB,IAAIC,EAAuBH,EAAsB,EAKjD,GAJIG,EAAuB,IAAGA,EAAuBl8B,EAAc,GAC/Dw6B,EAAW0B,GAAsB5hC,IAAM6gC,IACzCY,EAAsBG,GAEnBL,IAAuBD,EAAcE,iBAAqBD,IAAuBE,EAGpFX,EAAej3B,OAAOw3B,EAAoB,KACxCA,MACG,CACLC,EAAcE,gBAAkBD,EAChCD,EAAcI,iBAAmBD,EACjCH,EAAcO,QAAU3B,EAAWqB,GACnCD,EAAcQ,UAAY3B,EAAcoB,GACxCD,EAAcS,SAAW7B,EAAWuB,GACpCH,EAAcU,WAAa7B,EAAcsB,GACzC,IAAIE,EAAsBJ,EAAqB,EAC3CI,GAAuBj8B,IAAai8B,EAAsB,GAC9DL,EAAcW,WAAa/B,EAAWyB,GACtCL,EAAcY,aAAe/B,EAAcwB,GAC3C,IAAIC,EAAuBH,EAAsB,EAC7CG,EAAuB,IAAGA,EAAuBl8B,EAAc,GACnE47B,EAAca,YAAcjC,EAAW0B,GACvCN,EAAcc,cAAgBjC,EAAcyB,KAKlD,GAAIZ,GAAUJ,EAAazgC,OAAS,EAElC2gC,EAAiB,GACjBG,EAAkB,SAEpB,CACEA,EAAkBljB,OAAO6iB,EAAaI,EAAS,IAC/C,IAAIqB,EAAoB,IAAOxB,EAAcI,GAEzCqB,EAAyBzC,EAAoBsB,GACjD,IAAK,IAAIoB,KAAoBD,EAAwB,CACnD,IAAI30B,EAAe20B,EAAuBC,GACtCrC,EAAaR,EAAkB/xB,GAC/BwyB,EAAgBR,EAAqBhyB,GACrCjI,EAAcw6B,EAAW//B,OACzBqiC,EAAiB5C,EAAwBjyB,GAGzC80B,EAAqBD,EACzB,OAAa,CACX,IAAI7lC,EAAI8lC,EAAqB,EAE7B,GADI9lC,GAAK+I,IAAa/I,EAAI,GACtBujC,EAAWvjC,GAAGqD,IAAM6gC,EAAa,MACrC,GAAIlkC,IAAM6lC,EAAgB,MAC1BC,EAAqB9lC,EAEvB,IAAI+lC,EAAsBF,EAC1B,OAAa,CACX,IAAI7lC,EAAI+lC,EAAsB,EAE9B,GADI/lC,EAAI,IAAGA,EAAI+I,EAAc,GACzBw6B,EAAWvjC,GAAGqD,IAAM6gC,EAAa,MACrC,GAAIlkC,IAAM8lC,EAAoB,MAC9BC,EAAsB/lC,EAExB,IAAIglC,EAAsBc,EAAqB,EAC3Cd,GAAuBj8B,IAAai8B,EAAsB,GAC9D,IAAIC,EAAuBc,EAAsB,EAC7Cd,EAAuB,IAAGA,EAAuBl8B,EAAc,GACnE,IAAIi9B,EAAmB,CACrBh1B,aAAcA,EACd6zB,gBAAiBiB,EACjBf,iBAAkBgB,EAClBb,QAAS3B,EAAWuC,GACpBX,UAAW3B,EAAcsC,GACzBV,SAAU7B,EAAWwC,GACrBV,WAAY7B,EAAcuC,GAC1BT,WAAY/B,EAAWyB,GACvBO,aAAc/B,EAAcwB,GAC5BQ,YAAajC,EAAW0B,GACxBQ,cAAejC,EAAcyB,IAE/Bv4B,EAAay3B,EAAgB6B,GAAkB,SAAUC,EAAKC,GAC5D,IAAIC,EAAKh5B,EACP84B,EAAIf,QAASe,EAAIX,WAAYI,GAC3BU,EAAKj5B,EACP+4B,EAAIhB,QAASgB,EAAIZ,WAAYI,GAC/B,OAAIS,EAAKC,EAAW,EAChBD,EAAKC,GAAY,EACd,MAQX,IAAK,IAAIC,KAAoBlC,EAAgB,CAC3C,IAAIQ,EAAgBR,EAAekC,GAK/BjjC,GAHa2/B,EADE4B,EAAc3zB,cAEJxN,OAErB2J,EAA+Bw3B,EAAcO,QAASP,EAAcW,WAAYpB,IACpFgB,EAAUhiC,EAASgB,OAAOd,EAAG8gC,GAC7BiB,EAAYR,EAAcQ,UAAUtgC,KAAK8/B,EAAcY,aACzDzC,EAAwB6B,EAAcO,QACpCP,EAAcW,WACdJ,IACJ9hC,EAAI+J,EAA+Bw3B,EAAcS,SAAUT,EAAca,YAAatB,GACtF,IAAIkB,EAAWliC,EAASgB,OAAOd,EAAG8gC,GAC9BmB,EAAaV,EAAcU,WAAWxgC,KAAK8/B,EAAcc,cAC3D3C,EAAwB6B,EAAcS,SACpCT,EAAca,YACdJ,IACJhiC,EAAI+J,EAA+Bw3B,EAAcO,QAASP,EAAcW,WAAYhB,GACpF,IAAIgB,EAAapiC,EAASgB,OAAOd,EAAGkhC,GAChCiB,EAAeZ,EAAcQ,UAAUtgC,KAAK8/B,EAAcY,aAC5DzC,EAAwB6B,EAAcO,QACpCP,EAAcW,WACdA,IACJliC,EAAI+J,EAA+Bw3B,EAAcS,SAAUT,EAAca,YAAalB,GACtF,IAAIkB,EAActiC,EAASgB,OAAOd,EAAGkhC,GAKjCgC,EAAa,CACfpB,QAASA,EACTC,UAAWA,EACXC,SAAUA,EACVC,WAAYA,EACZC,WAAYA,EACZC,aAAcA,EACdC,YAAaA,EACbC,cAZkBd,EAAcU,WAAWxgC,KAAK8/B,EAAcc,cAC9D3C,EAAwB6B,EAAcS,SACpCT,EAAca,YACdA,IAUFe,SAAUpqB,EAAOlO,WAAWi3B,EAASI,GACrCkB,UAAWrqB,EAAOlO,WAAWu3B,EAAaJ,IAE5C,GAAIb,EAAiB/gC,OAAS,EAAG,CAC/B,IAAIijC,EAAiBlC,EAAiBA,EAAiB/gC,OAAS,GAC5Dq5B,EAAKyJ,EAAWpB,QAAQhgC,WAAWuhC,EAAerB,UAClDtI,EAAKwJ,EAAWhB,WAAWpgC,WAAWuhC,EAAejB,aACpD3I,EAAKt6B,GAASu6B,EAAKv6B,IAEtB+jC,EAAWpB,QAAUuB,EAAevB,QACpCoB,EAAWnB,UAAYsB,EAAetB,UACtCmB,EAAWC,SAAWE,EAAeF,SACrCD,EAAWhB,WAAamB,EAAenB,WACvCgB,EAAWf,aAAekB,EAAelB,aACzChB,EAAiBr3B,OAAOq3B,EAAiB/gC,OAAS,EAAG,IAGzD+gC,EAAiBj8B,KAAKg+B,GAExB,GAAIjC,EAAS,EAAG,CAEd,IAAIqC,EAAuB,GACvBC,EAAiB,GACrB,IAAK,IAAI3mC,EAAI,EAAGA,EAAIukC,EAAiB/gC,OAAQxD,IAAK,CAChD,IAAI4mC,EAAcrC,EAAiBvkC,GACnC,IAAK,IAAI4wB,EAAK,EAAGA,EAAKwT,EAAkB5gC,OAAQotB,IAC9C,IAAK+V,EAAe/V,GACpB,CAGE,IAAIiW,EAAczC,EAAkBxT,GACpC,GAAIiW,EAAYvB,WAAWpgC,WAAW0hC,EAAY1B,SAAW3iC,GACvDskC,EAAYrB,YAAYtgC,WAAW0hC,EAAYxB,UAAY7iC,EAAK,CAElEokC,EAAe/V,IAAM,EAErB,IAAIiM,EAAK+J,EAAYL,SAAS/3B,YAAYpL,EAAIyjC,EAAYN,SAAS/3B,YAAYpL,EAC3E05B,EAAK8J,EAAYJ,UAAUh4B,YAAYpL,EAAIyjC,EAAYL,UAAUh4B,YAAYpL,EAC7E0jC,EAAoB7kC,KAAKqC,IAAIu4B,GAAMt6B,EACnCwkC,EAAqB9kC,KAAKqC,IAAIw4B,GAAMv6B,EAEpCykC,EAAoBD,GAAuBjK,GAAM,GAD9BgK,GAAsBjK,GAAM,IAE3BmK,IAGtBJ,EAAYN,WAAaO,EAAYP,WACrCM,EAAYE,kBAAoBA,EAChCF,EAAYG,mBAAqBA,EACjCL,EAAqB9V,IAAM,GAE7B,QAMV,IAAK,IAAIA,EAAK,EAAGA,EAAKwT,EAAkB5gC,OAAQotB,IAC9C,IAAK8V,EAAqB9V,GAAK,CAG7B,IAAIiW,EAAczC,EAAkBxT,GACpCiW,EAAYP,WAAWW,YAAY3+B,KAAKu+B,EAAYrB,aACpDqB,EAAYP,WAAWY,mBAAmB5+B,KAAKu+B,EAAYpB,eACvDoB,EAAYrB,YAAYtgC,WAAW2hC,EAAYvB,YAAc/iC,IAE/DskC,EAAYP,WAAWa,WAAW7+B,KAAKu+B,EAAYvB,YACnDuB,EAAYP,WAAWc,kBAAkB9+B,KAAKu+B,EAAYtB,eAG5DsB,EAAYP,WAAWa,WAAWh9B,UAClC08B,EAAYP,WAAWc,kBAAkBj9B,UACzC,IAAIk9B,EAAWR,EAAYP,WAAWW,YAAYzoB,OAAOqoB,EAAYP,WAAWa,YAC5E3D,EAAgBqD,EAAYP,WAAWY,mBAAmB1oB,OAAOqoB,EAAYP,WAAWc,mBACxFE,EAAa,GACjBD,EAASn9B,KAAI,SAAUq9B,EAASvnC,GAC9B,IAAIgP,EAAUxE,EAAWoS,KAAK2qB,GAC1BC,EAAW5gC,EAAOuC,aAAa6F,EAASw0B,EAAcxjC,IAC1DsnC,EAAWh/B,KAAKk/B,MAElB,IAAIr8B,EAAU,IAAIrE,EAAQwgC,EAAYtgC,EAAQC,GAC9C8sB,EAAazrB,KAAK6C,IAIxB,IAAK,IAAInL,EAAI,EAAGA,EAAIukC,EAAiB/gC,OAAQxD,IAAK,CAChD,IAAI4mC,EAAcrC,EAAiBvkC,GAC9B4mC,EAAYN,YAiBVM,EAAYE,oBACfF,EAAYN,WAAWa,WAAW7+B,KAAKs+B,EAAY1B,SACnD0B,EAAYN,WAAWc,kBAAkB9+B,KAAKs+B,EAAYzB,YAEvDyB,EAAYG,qBACfH,EAAYN,WAAWW,YAAY3+B,KAAKs+B,EAAYxB,UACpDwB,EAAYN,WAAWY,mBAAmB5+B,KAAKs+B,EAAYvB,eArB7DuB,EAAYN,WAAa,CACvBa,WAAY,GACZC,kBAAmB,GACnBH,YAAa,GACbC,mBAAoB,IAEtBN,EAAYN,WAAWa,WAAW7+B,KAAKs+B,EAAY1B,SACnD0B,EAAYN,WAAWc,kBAAkB9+B,KAAKs+B,EAAYzB,WACtDyB,EAAY1B,QAAQhgC,WAAW0hC,EAAYxB,UAAY7iC,IAEzDqkC,EAAYN,WAAWW,YAAY3+B,KAAKs+B,EAAYxB,UACpDwB,EAAYN,WAAWY,mBAAmB5+B,KAAKs+B,EAAYvB,cAcjEjB,EAAoBG,M,gBCrY5B,MAAMrhC,EAAW,EAAQ,GA+BzBzD,EAAOD,QAAU,CAACoL,KA1BL,SAAU4G,GACrB,IAAIvJ,EAAc,EAKlB,OAJAuJ,EAAI/D,MAAMvD,KAAI,SAAUmI,GACtBpK,GAAeoK,EAAKqD,QAAQrO,IAAIpC,MAAMoN,EAAKsD,QAAQtO,QAErDY,GAAe,GACRA,GAoBesL,UAjBN,SAAU/B,GAC1B,IAAI1H,EAEFA,EADuB,IAArB0H,EAAI/D,MAAMjK,OACD,IAAIN,EAAS,EAAG,GAEhBsO,EAAI/D,MAAM,GAAGiI,QAAQrO,IAElC,IAAI0C,EAAWD,EAOf,OANA0H,EAAI/D,MAAMvD,KAAI,SAAUmI,GACtBvI,EAAWA,EAASlE,IAAIyM,EAAKqD,QAAQrO,KACrCyC,EAAWA,EAASlE,IAAIyM,EAAKsD,QAAQtO,KACrC0C,EAAWA,EAASlE,IAAIwM,EAAKqD,QAAQrO,KACrC0C,EAAWA,EAASlE,IAAIwM,EAAKsD,QAAQtO,QAEhC,CAACyC,EAAUC,M,gBC5BpB,MAAMmb,EAAU,EAAQ,GAClB6T,EAAU,EAAQ,GAClBuC,EAAW,EAAQ,GA4DzB77B,EAAOD,QAAU,CAAC8sB,iBAxBOmb,IACvB,IAAIv8B,EAkBJ,MAjBI,UAAWu8B,GACbv8B,EAAS,GACTu8B,EAAMh6B,MAAMrF,QAAQiK,IAClBnH,EAAO5C,KAAK,CAAC+J,EAAKqD,QAAQrO,IAAIjE,EAAGiP,EAAKqD,QAAQrO,IAAIhE,IAClD6H,EAAO5C,KAAK,CAAC+J,EAAKsD,QAAQtO,IAAIjE,EAAGiP,EAAKsD,QAAQtO,IAAIhE,OAS3C,WAAYokC,IACrBv8B,EAASu8B,EAAMv8B,OAAOhB,IAAIpI,GAAK,CAAEA,EAAEsB,EAAGtB,EAAEuB,KAGnC6H,GAK2BqhB,MA5BpC,SAAetrB,EAAO2E,EAAKC,GACzB,OAAO5D,KAAK2D,IAAI3D,KAAK4D,IAAI5E,EAAO2E,GAAMC,IA2BG2mB,8BA9CL,CAACvM,EAAQma,KAC7C,MAAOrf,EAAIhN,EAAIC,GAAMosB,EAErB,IAAIh3B,EAAI2X,EAAKkF,EAAOnH,SAAS,GAAK/K,EAAKkS,EAAOnH,SAAS,GAAK9K,EAAKiS,EAAOnH,SAAS,GADtE,EACgFmH,EAAOnH,SAAS,GACvGzV,EAAI0X,EAAKkF,EAAOnH,SAAS,GAAK/K,EAAKkS,EAAOnH,SAAS,GAAK9K,EAAKiS,EAAOnH,SAAS,GAFtE,EAEgFmH,EAAOnH,SAAS,GACvGxV,EAAIyX,EAAKkF,EAAOnH,SAAS,GAAK/K,EAAKkS,EAAOnH,SAAS,GAAK9K,EAAKiS,EAAOnH,SAAS,IAHtE,EAGiFmH,EAAOnH,SAAS,IACxGjL,EAAIkN,EAAKkF,EAAOnH,SAAS,IAAM/K,EAAKkS,EAAOnH,SAAS,IAAM9K,EAAKiS,EAAOnH,SAAS,IAJxE,EAImFmH,EAAOnH,SAAS,IAG9G,GAAU,IAANjL,EAAS,CACX,MAAMmN,EAAO,EAAMnN,EACnBzK,GAAK4X,EACL3X,GAAK2X,EACL1X,GAAK0X,EAEP,MAAO,CAAC5X,EAAGC,EAAGC,IA+B0DmpB,kBArDhDvhB,IAExB,MAAMnE,EAAWmE,EAAOhB,IAAIF,GAAS,IAAIkb,EAAQ,IAAI6T,EAAQ/uB,KAC7D,OAAO,IAAIsxB,EAASv0B,M,gBCZtB,MAAMwe,EAAS,EAAQ,IA+EvB9lB,EAAOD,QA7EiB,SAAU41B,GAChC,IAAI5jB,EAAM4jB,EAAKtjB,gBACX41B,EAAmB,GACnBC,EAA6B,GACjCn2B,EAAI/D,MAAMvD,KAAI,SAAUmI,GACtB,IAAIu1B,EAAUv1B,EAAKrP,SACnB0kC,EAAiBE,GAAWv1B,EAC5B,IAAIw1B,EAAiBx1B,EAAKqD,QAAQ1S,SAC5B6kC,KAAkBF,IACtBA,EAA2BE,GAAkB,IAE/CF,EAA2BE,GAAgBv/B,KAAKs/B,MAElD,IAAI71B,EAAQ,GACZ,OAAa,CACX,IAAI+1B,EAAe,KACnB,IAAK,IAAIC,KAAcJ,EAA4B,CACjD,IAAIK,EAAoBL,EAA2BI,GACnDD,EAAeE,EAAkB,GACjCA,EAAkB96B,OAAO,EAAG,GACK,IAA7B86B,EAAkBxkC,eACbmkC,EAA2BI,GAEpC,MAEF,GAAqB,OAAjBD,EAAuB,MAC3B,IAAIG,EAAwB,GAExBC,EAAUR,EADAI,GAEVD,EAAiBK,EAAQxyB,QAAQ1S,SACrC,OAAa,CACXilC,EAAsB3/B,KAAK4/B,EAAQxyB,QAAQrO,KAC3C,IAAI8gC,EAAgBD,EAAQvyB,QAAQ3S,SACpC,GAAImlC,IAAkBN,EAAgB,MACtC,KAAMM,KAAiBR,GACrB,MAAM,IAAI1jC,MAAM,uBAElB,IAAImkC,EAAuBT,EAA2BQ,GAClDE,GAAiB,EACrB,GAAoC,IAAhCD,EAAqB5kC,OACvB6kC,EAAgB,MACX,CAGL,IAAIC,EAAY,KACZC,EAAWL,EAAQ15B,YAAY9H,eACnC,IAAK,IAAIoM,EAAY,EAAGA,EAAYs1B,EAAqB5kC,OAAQsP,IAAa,CAC5E,IAAI01B,EAAsBJ,EAAqBt1B,GAG3C21B,EAFef,EAAiBc,GACXh6B,YAAY9H,eACd6hC,EACnBE,GAAY,MAAKA,GAAY,KAC7BA,GAAY,MAAKA,GAAY,MAC5BJ,EAAgB,GAAOI,EAAWH,KACrCD,EAAgBv1B,EAChBw1B,EAAYG,IAIlB,IAAIC,EAAcN,EAAqBC,GACvCD,EAAqBl7B,OAAOm7B,EAAe,GACP,IAAhCD,EAAqB5kC,eAChBmkC,EAA2BQ,GAEpCD,EAAUR,EAAiBgB,GAIzBT,EAAsBzkC,OAAS,GACjCykC,EAAsB3/B,KAAK2/B,EAAsB5vB,SAEnD,IAAIrG,EAAO,IAAIuT,EAAO0iB,GAAuB,GAC7Cl2B,EAAMzJ,KAAK0J,GAEb,OAAOD,I,cCrETtS,EAAOD,QANP,SAAiBmpC,GACf,OAAKA,EACDA,EAAKC,cAAgB7kC,MAAc,CAAC4kC,GACjCA,EAFW,K,gBCFpB,MAAM7hC,EAAU,EAAQ,IAClB,aAAC2B,GAAgB,EAAQ,IACzB,cAAC0D,GAAiB,EAAQ,GA0F1B08B,EAAY,SAAUC,EAAOnmC,EAAQD,EAAKqmC,GAC9C,IAAIC,EAAermC,EAAOoE,SAAS8E,MAAM,GACrCo9B,EAAYvmC,EAAIqE,SAAS8E,MAAM,GAC/BD,EAAQlJ,EAAIsE,QAAU,KAGrBgiC,EAAa,GAAG3hC,IAAIjC,OAAO4jC,EAAaA,EAAaxlC,OAAS,GAAG6D,MACpE2hC,EAAa1gC,KAAK0gC,EAAa,IAI5BC,EAAU,GAAG5hC,IAAIjC,OAAO6jC,EAAUA,EAAUzlC,OAAS,GAAG6D,MAC3D4hC,EAAU3gC,KAAK2gC,EAAU,IAEvBF,IACFC,EAAeA,EAAa7+B,UAC5B8+B,EAAYA,EAAU9+B,WAGxB,IAeI++B,EAfAC,EAAUF,EAAUzlC,OAAS,EAC7B4lC,EAAUJ,EAAaxlC,OAAS,EAChC6lC,EAASF,EAAUC,EACnBE,EAAYD,EAAS,EACrBE,EAAeF,EAAS,EAExBG,EAAO,GAEX,IAAK,IAAIxpC,EAAIiC,KAAKqC,IAAI+kC,GAASrpC,EAAI,EAAGA,IACpCwpC,EAAKlhC,KAAK,CACR4gC,IAAK58B,IACLF,OAAQ,IAKZ,GAAIm9B,EACF,IAAK,IAAIvpC,EAAI,EAAGA,EAAIopC,EAASppC,IAAK,CAChCkpC,EAAMF,EAAahpC,GAAGqH,IAAIlC,kBAAkB6jC,EAAahpC,EAAI,GAAGqH,KAEhE,IAAK,IAAI0Q,EAAIyxB,EAAKhmC,OAAS,EAAGuU,GAAK,EAAGA,IACpC,GAAIyxB,EAAKzxB,GAAGmxB,IAAMA,EAAK,CACrBM,EAAKzxB,GAAGmxB,IAAMA,EACdM,EAAKp9B,MAAQ2L,EACb,YAID,GAAIuxB,EACT,IAAK,IAAItpC,EAAI,EAAGA,EAAImpC,EAASnpC,IAAK,CAChCkpC,EAAMD,EAAUjpC,GAAGqH,IAAIlC,kBAAkB8jC,EAAUjpC,EAAI,GAAGqH,KAE1D,IAAK,IAAI0Q,EAAIyxB,EAAKhmC,OAAS,EAAGuU,GAAK,EAAGA,IACpC,GAAIyxB,EAAKzxB,GAAGmxB,IAAMA,EAAK,CACrBM,EAAKzxB,GAAGmxB,IAAMA,EACdM,EAAKp9B,MAAQ2L,EACb,OAMRyxB,EAAK9R,KAAKvrB,GACV,IAOIs9B,EACAC,EACAC,EATAC,EAAc,SAA6Btb,EAAQE,EAAQqb,EAAQj+B,GACrE,OAAO,IAAI9E,EAAQ,CAACwnB,EAAQE,EAAQqb,GAASj+B,IAI3Ck+B,EAASd,EAAa,GACtBe,EAASd,EAAU,GAIvB,IAAK,IAAIe,EAAK,EAAGC,EAAK,EAAG1S,EAAO4R,EAAUC,EAASY,EAAKC,EAAK1S,GAAO,CAClE,GAAIiS,EAAKhmC,OAAQ,CACf,GAAI8lC,GAAaW,IAAOT,EAAK,GAAGp9B,MAAO,CACrCq9B,EAAcR,IAAYgB,GAE1BnB,EAAMxgC,KAAKshC,EACTH,EAAaM,EAAQD,EAAQl+B,IAE/Bm+B,EAASN,EACTD,EAAKnxB,QACL,SACK,GAAIkxB,GAAgBS,IAAOR,EAAK,GAAGp9B,MAAO,CAC/Cq9B,EAAcT,IAAegB,GAC7BlB,EAAMxgC,KAAKshC,EACTG,EAAQD,EAAQL,EAAa79B,IAE/Bk+B,EAASL,EACTD,EAAKnxB,QACL,UAKFqxB,EADEM,EAAKZ,EACKW,EAAO1iC,IAAIlC,kBAAkB6jC,EAAagB,EAAK,GAAG3iC,KAElDiF,IAGZq9B,EADEM,EAAKd,EACKW,EAAOziC,IAAIlC,kBAAkB8jC,EAAUgB,EAAK,GAAG5iC,KAE/CiF,IAEVo9B,GAAaC,GACfF,EAAcT,IAAegB,GAC7BlB,EAAMxgC,KAAKshC,EACTG,EAAQD,EAAQL,EAAa79B,IAE/Bk+B,EAASL,GACAQ,EAAKd,IACdM,EAAcR,IAAYgB,GAE1BnB,EAAMxgC,KAAKshC,EACTH,EAAaM,EAAQD,EAAQl+B,IAE/Bm+B,EAASN,GAIb,OAAOX,GAGTrpC,EAAOD,QAzMiB,SAAU2L,EAASL,GACzC,IAOIo/B,EAPAv8B,EAAW,GACX+B,EAAM,KACNy6B,EAAO,KACPxnC,EAAS,KACTD,EAAM,KACN0nC,EAAY,EACZC,GAAQ,EAERzhC,EAAU,KAad,GAXIkC,IACFu/B,EAAQC,QAAQx/B,EAAc,MAE1BA,EAAQy/B,YACVH,EAAYt/B,EAAQy/B,WAGlBz/B,EAAQ0/B,WACVN,EAAap/B,EAAQ0/B,YAGpBN,EAAY,CACf,IAAIxR,EAAS5xB,EAAQmE,iBAAiB,CACpC,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,KAETi/B,EAAa,SAAUhpC,EAAG2K,GACxB,OAAa,IAAN3K,GAAiB,IAANA,EAAUw3B,EAAO5vB,UAAU,CAAC,EAAG,EAAG5H,IAAM,MAG9D,IAAK,IAAIlB,EAAI,EAAGu3B,EAAO6S,EAAY,EAAGpqC,GAAKu3B,EAAMv3B,IAE/C,GADA0P,EAAMw6B,EAAW/pC,KAAKgL,EAASnL,EAAIu3B,EAAMv3B,GACrC0P,EAAK,CACP,KAAMA,aAAe5I,GACnB,MAAM,IAAI7C,MAAM,4DAElByL,EAAIpI,gBAEA6iC,GACc,OAAZvhC,IACFA,EAAUuhC,EAAKljC,MAAM6H,sBAAsBY,EAAI3I,SAAS,GAAGM,KAAO,GAEpEwhC,EAAUl7B,EAAUw8B,EAAMz6B,EAAK9G,IAE/BjG,EAAS+M,EAEXy6B,EAAOz6B,EAKX,GAFAhN,EAAMgN,EAEF26B,EAAO,CACY1nC,EAAOoE,SAASvD,SAAWd,EAAIqE,SAASvD,QAC3Db,EAAOoE,SAAS0jC,OAAM,SAAUzmC,EAAGoI,GACjC,OAAOpI,EAAEqD,IAAIjC,OAAO1C,EAAIqE,SAASqF,GAAO/E,SAK1CwhC,EAAUl7B,EAAUjL,EAAKC,EAAQiG,QAKnC+E,EAAS+8B,QAAQ9hC,EAAUjG,EAASA,EAAOiG,WAC3C+E,EAASrF,KAAKM,EAAUlG,EAAIkG,UAAYlG,GAE1C,OAAO+F,EAAakF,K,gBCpFtB,MAAM,IAACpL,GAAO,EAAQ,GAChBuE,EAAU,EAAQ,GAClBK,EAAQ,EAAQ,GAEtB,SAASwjC,EAAQC,EAASC,EAAqBC,EAAmBp1B,EAASC,EAAS3E,GAClF,IAAI+5B,EAAWr1B,EAAQ1S,SACnBgoC,EAASr1B,EAAQ3S,SACrB,GAAI+nC,IAAaC,EAAQ,MAAM,IAAI/mC,MAAM,oBACzC,IAAIgnC,EAAaF,EAAW,IAAMC,EAElC,GADqBA,EAAS,IAAMD,KACdH,EAKpB,OADAM,EAAWN,EAASC,EAAqBC,EAAmBn1B,EAASD,EAAS,MACvE,KAGT,IAAIy1B,EAAa,CACfz1B,QAASA,EACTC,QAASA,EACT3E,aAAcA,GAiBhB,OAfMi6B,KAAcL,EAGlBA,EAAQK,GAAY3iC,KAAK6iC,GAFzBP,EAAQK,GAAc,CAACE,GAIrBJ,KAAYF,EACdA,EAAoBE,GAAUziC,KAAK2iC,GAEnCJ,EAAoBE,GAAY,CAACE,GAE/BD,KAAUF,EACZA,EAAkBE,GAAQ1iC,KAAK2iC,GAE/BH,EAAkBE,GAAU,CAACC,GAExBA,EAGT,SAASC,EAAWN,EAASC,EAAqBC,EAAmBp1B,EAASC,EAAS3E,GACrF,IAAI+5B,EAAWr1B,EAAQ1S,SACnBgoC,EAASr1B,EAAQ3S,SACjB4kC,EAAUmD,EAAW,IAAMC,EAE/B,KAAMpD,KAAWgD,GAAU,MAAM,IAAI3mC,MAAM,oBAC3C,IAAImnC,GAAO,EACPC,EAAWT,EAAQhD,GACvB,IAAK,IAAI5nC,EAAI,EAAGA,EAAIqrC,EAAS7nC,OAAQxD,IAAK,CACxC,IAAIsrC,EAAUD,EAASrrC,GACvB,GAAIsrC,EAAQ51B,UAAYA,IACpB41B,EAAQ31B,UAAYA,IACH,OAAjB3E,GACEs6B,EAAQt6B,eAAiBA,IAD/B,CAGAo6B,EAAMprC,EACN,OAEF,GAAIorC,EAAM,EAAG,MAAM,IAAInnC,MAAM,oBAM7B,GALAonC,EAASn+B,OAAOk+B,EAAK,GACG,IAApBC,EAAS7nC,eACJonC,EAAQhD,GAEjBwD,EAAMP,EAAoBE,GAAUtM,QAAQmJ,GACxCwD,EAAM,EAAG,MAAM,IAAInnC,MAAM,oBAO7B,GANA4mC,EAAoBE,GAAU79B,OAAOk+B,EAAK,GACG,IAAzCP,EAAoBE,GAAUvnC,eACzBqnC,EAAoBE,GAG7BK,EAAMN,EAAkBE,GAAQvM,QAAQmJ,GACpCwD,EAAM,EAAG,MAAM,IAAInnC,MAAM,oBAC7B6mC,EAAkBE,GAAQ99B,OAAOk+B,EAAK,GACG,IAArCN,EAAkBE,GAAQxnC,eACrBsnC,EAAkBE,GAgP7BvrC,EAAOD,QAxNe,SAAUiJ,EAAciH,GAC5CA,EAAMA,EAAIoC,gBACV,IAAI84B,EAAU,GAGd,IAAK,IAAI55B,EAAe,EAAGA,EAAetB,EAAI/B,SAASnK,OAAQwN,IAAgB,CAC7E,IAAI7F,EAAUuE,EAAI/B,SAASqD,GACvBjI,EAAcoC,EAAQpE,SAASvD,OAEnC,GAAIuF,GAAe,EAAG,CACpB,IAAIuB,EAASa,EAAQpE,SAAS,GAC1B2R,EAAYpO,EAAOtH,SACvB,IAAK,IAAIsN,EAAc,EAAGA,EAAcvH,EAAauH,IAAe,CAClE,IAAIqwB,EAAkBrwB,EAAc,EAChCqwB,IAAoB53B,IAAa43B,EAAkB,GACvD,IAAI4K,EAAapgC,EAAQpE,SAAS45B,GAC9BwH,EAAgBoD,EAAWvoC,SAC3B4kC,EAAUlvB,EAAY,IAAMyvB,EAC5BqD,EAAiBrD,EAAgB,IAAMzvB,EAC3C,GAAI8yB,KAAkBZ,EAAS,CAE7B,IAAIa,EAAKb,EAAQY,GACjBC,EAAGv+B,QAAQ,EAAG,GACI,IAAdu+B,EAAGjoC,eACEonC,EAAQY,OAEZ,CACL,IAAIF,EAAU,CACZ51B,QAASpL,EACTqL,QAAS41B,EACTv6B,aAAcA,GAEV42B,KAAWgD,EAGfA,EAAQhD,GAASt/B,KAAKgjC,GAFtBV,EAAQhD,GAAW,CAAC0D,GAKxBhhC,EAASihC,EACT7yB,EAAYyvB,IAOlB,IAAI0C,EAAsB,GACtBC,EAAoB,GACpBY,EAAe,GACfC,GAAiB,EACrB,IAAK,IAAI/D,KAAWgD,EAClBe,GAAiB,EACjBD,EAAa9D,IAAW,EACxBgD,EAAQhD,GAAS19B,KAAI,SAAUohC,GAC7B,IAAIP,EAAWO,EAAQ51B,QAAQ1S,SAC3BgoC,EAASM,EAAQ31B,QAAQ3S,SACzB+nC,KAAYF,EACdA,EAAoBE,GAAUziC,KAAKs/B,GAEnCiD,EAAoBE,GAAY,CAACnD,GAE/BoD,KAAUF,EACZA,EAAkBE,GAAQ1iC,KAAKs/B,GAE/BkD,EAAkBE,GAAU,CAACpD,MAMnC,IAAK+D,EAAgB,CAEnB,IAAIh+B,EAAW+B,EAAI/B,SAAS9B,MAAM,GAClC,OAAa,CACX,IAAI8/B,GAAiB,EACrB,IAAK,IAAI/D,KAAWgD,EAClBe,GAAiB,EACjBD,EAAa9D,IAAW,EAE1B,GAAI+D,EAAgB,MACpB,IAAIC,GAAgB,EACpB,OAAa,CACX,IAAIC,EAAiB,KACrB,IAAK,IAAIjE,KAAW8D,EAAc,CAChCG,EAAiBjE,EACjB,MAEF,GAAuB,OAAnBiE,EAAyB,MAC7B,IAAIC,GAAe,EACnB,GAAID,KAAkBjB,EAAS,CAC7B,IAAIS,EAAWT,EAAQiB,GACvB,GAAwB,IAApBR,EAAS7nC,OAAc,MAAM,IAAIS,MAAM,oBAC3C,IAAIqnC,EAAUD,EAAS,GACvB,IAAK,IAAIU,EAAiB,EAAGA,EAAiB,EAAGA,IAAkB,CACjE,IAAIC,EAAkC,IAAnBD,EAAwBT,EAAQ51B,QAAU41B,EAAQ31B,QACjEs2B,EAAgC,IAAnBF,EAAwBT,EAAQ31B,QAAU21B,EAAQ51B,QAC/DmyB,EAAiBmE,EAAYhpC,SAC7BkpC,EAAeD,EAAUjpC,SACzBmpC,EAAgB,GACG,IAAnBJ,EACElE,KAAkBiD,IACpBqB,EAAgBrB,EAAkBjD,IAGhCA,KAAkBgD,IACpBsB,EAAgBtB,EAAoBhD,IAGxC,IAAK,IAAIuE,EAAoB,EAAGA,EAAoBD,EAAc3oC,OAAQ4oC,IAAqB,CAC7F,IACIC,EAAezB,EADGuB,EAAcC,IACQ,GACxCE,EAA8C,IAAnBP,EAAwBM,EAAa32B,QAAU22B,EAAa12B,QACvF42B,EAA4C,IAAnBR,EAAwBM,EAAa12B,QAAU02B,EAAa32B,QACrF82B,EAA6BF,EAAwBtpC,SAEzD,GAD+BupC,EAAsBvpC,WACpB6kC,EAAgB,MAAM,IAAI5jC,MAAM,oBACjE,GAAIuoC,IAA+BN,EAAc,CAE/ChB,EAAWN,EAASC,EAAqBC,EAAmBkB,EAAaC,EAAW,MACpFf,EAAWN,EAASC,EAAqBC,EAAmBmB,EAAWD,EAAa,MACpFF,GAAe,EACfC,EAAiB,EACjBH,GAAgB,EAChB,MACK,CACL,IAAIa,EAAWT,EAAY3kC,IACvBqlC,EAAST,EAAU5kC,IAEnBmH,EADW89B,EAAwBjlC,IACd5C,MAAMgoC,GAE3BvrC,EAAIwrC,EAAOjoC,MAAMgoC,GAAU7nC,IAAI4J,GAAaA,EAAU5J,IAAI4J,GAC9D,GAAKtN,EAAI,GAAOA,EAAI,EAAI,CAGtB,GAFmBurC,EAASloC,KAAKiK,EAAU9J,MAAMxD,IACdiE,kBAAkBunC,GAC9BnqC,EAAMA,EAAM,CAEjC,IAAIyO,EAAeq7B,EAAar7B,aAC5B7F,EAAUwC,EAASqD,GAEnB27B,EAAqBN,EAAa12B,QAAQ3S,SAC1C4pC,GAA2B,EAC/B,IAAK,IAAI5sC,EAAI,EAAGA,EAAImL,EAAQpE,SAASvD,OAAQxD,IAC3C,GAAImL,EAAQpE,SAAS/G,GAAGgD,WAAa2pC,EAAoB,CACvDC,EAA0B5sC,EAC1B,MAGJ,GAAI4sC,EAA0B,EAAG,MAAM,IAAI3oC,MAAM,oBAEjD,IAAIgG,EAAckB,EAAQpE,SAAS8E,MAAM,GACzC5B,EAAYiD,OAAO0/B,EAAyB,EAAGX,GAC/C,IAAIta,EAAa,IAAI7qB,EAAQmD,EAAakB,EAAQnE,QAGlD,GAAIqF,MAAMslB,EAAW1qB,MAAM4G,GAAI,CAC7B,IAAIg/B,GAAQ,EACRC,EAAO,SAAUtC,GACnB7Y,EAAW5qB,SAASqB,SAAQ,SAAU2kC,GAChCF,GACJrC,EAASuC,OAIbD,GAAK,SAAUtoC,GACbsoC,GAAK,SAAU5gC,GACb4gC,GAAK,SAAUzsC,GACbsxB,EAAW1qB,MAAQE,EAAM8G,WAAWzJ,EAAE6C,IAAK6E,EAAE7E,IAAKhH,EAAEgH,KAC/CgF,MAAMslB,EAAW1qB,MAAM4G,KAC1Bg/B,GAAQ,YAMlBl/B,EAASqD,GAAgB2gB,EAGzBuZ,EAAWN,EAASC,EAAqBC,EAAmBuB,EAAa32B,QAAS22B,EAAa12B,QAAS3E,GACxG,IAAIg8B,EAAcrC,EAAQC,EAASC,EAAqBC,EAAmBuB,EAAa32B,QAASu2B,EAAWj7B,GACxGi8B,EAActC,EAAQC,EAASC,EAAqBC,EAAmBmB,EAAWI,EAAa12B,QAAS3E,GACxF,OAAhBg8B,IAAsBtB,EAAasB,IAAe,GAClC,OAAhBC,IAAsBvB,EAAauB,IAAe,GACtDnB,GAAe,EACfC,EAAiB,EACjBH,GAAgB,EAChB,WAORE,UACKJ,EAAaG,GAGxB,IAAKD,EAAe,MAEtB,IAAIsB,EAASzkC,EAAakF,GAC1Bu/B,EAAOhvB,WAAaxO,EAAIwO,WACxBgvB,EAAOv9B,iBAAkB,EACzBu9B,EAAOt9B,gBAAiB,EACxBF,EAAMw9B,EAWR,OAAOx9B,I,gBCxTT,MAAMvM,EAAW,EAAQ,GA+CzB1D,EAAOD,QAAU,CAAC+W,OArCH,SAAU7G,GACvB,IAAKA,EAAI7F,kBAAmB,CAC1B,IAAIC,EAAW,IAAI3G,EAAS,EAAG,EAAG,GAC9B4G,EAAW,IAAI5G,EAAS,EAAG,EAAG,GAC9BwK,EAAW+B,EAAI/B,SACf+C,EAAc/C,EAASnK,OAC3B,IAAK,IAAIxD,EAAI,EAAGA,EAAI0Q,EAAa1Q,IAAK,CACpC,IACIuW,EADU5I,EAAS3N,GACF0J,cACX,IAAN1J,GACF8J,EAAWyM,EAAO,GAClBxM,EAAWwM,EAAO,KAElBzM,EAAWA,EAASlE,IAAI2Q,EAAO,IAC/BxM,EAAWA,EAASlE,IAAI0Q,EAAO,KAInC7G,EAAI7F,kBAAoB,CAACC,EAAUC,GAErC,OAAO2F,EAAI7F,mBAiBasjC,OAdX,SAAUz9B,GACvB,IAAIvL,EAASuL,EAAI0Q,cAAclW,KAAI,SAAUmW,GAC3C,OAAOA,EAAQnY,iBAAiB,CAAC,cAEnC4oB,QAAQC,IAAI,SAAU5sB,IAUUyG,KAPrB,SAAU8E,GACrB,IAAIvL,EAASuL,EAAI0Q,cAAclW,KAAI,SAAUmW,GAC3C,OAAOA,EAAQnY,iBAAiB,CAAC,YAEnC4oB,QAAQC,IAAI,OAAQ5sB,M,gBC5CtB,MAAMsG,EAAM,EAAQ,IACd,IAAClI,GAAO,EAAQ,GAqBtB9C,EAAOD,QAAU,CAAC+K,0BAhBgB,SAAUmF,EAAKlF,GAC/C,IAAIyJ,EAAO,GAYX,OAXAvE,EAAI/B,SAASgF,QAAO,SAAU7Q,GAE5B,OAAOA,EAAEmF,MAAMX,OAAO7B,MAAM+F,EAAWvD,MAAMX,QAAQxB,gBAAmBvC,EAAMA,KAE7E2H,KAAI,SAAUiB,GACb,IAAIqG,EAAMrG,EAAQZ,0BAA0BC,GACxCgH,EAAI/D,MAAMjK,OAAS,GACrByQ,EAAK3L,KAAKkJ,OAGH,IAAI/G,GAAM4G,MAAM4C,M,gBClB/B,MAAM,IAAC1R,GAAO,EAAQ,GAChB4E,EAAQ,EAAQ,GAChBimC,EAAU,EAAQ,GAClBloB,EAAU,EAAQ,GAClBoW,EAAW,EAAQ,GACnBziB,EAAmB,EAAQ,IA8DjCpZ,EAAOD,QAAU,CAACse,WAxDC,SAAUpO,EAAKlF,GAChC,IAAI6iC,EAAS7iC,EAAWvD,MACpBqmC,EAAS9iC,EAAWvD,MAAM2B,UAC9BykC,EAAS,IAAIlmC,EAAMkmC,EAAO/mC,OAAQ+mC,EAAOx/B,GACzCy/B,EAAS,IAAInmC,EAAMmmC,EAAOhnC,OAAQgnC,EAAOz/B,EAAK,EAAItL,GAClD,IAAIgrC,EAAQ79B,EAAIqO,WAAWsvB,GAE3B,OADAE,EAAQA,EAAMxvB,WAAWuvB,GAClBC,EAAMhjC,0BAA0BC,IAiDXuT,WA1CX,SAAUrO,EAAKzI,GAChC,GAA4B,IAAxByI,EAAI/B,SAASnK,OAAc,CAE7B,OAAO,IADK,EAAQ,KAQtB,IAAIgqC,EAAcvmC,EAAMX,OAAO5B,MAAMuC,EAAM4G,GACvC4/B,EAAc,EAClB/9B,EAAI/B,SAASzD,KAAI,SAAUiB,GACzBA,EAAQpE,SAASmD,KAAI,SAAUI,GAC7B,IAAI2E,EAAW3E,EAAOjD,IAAIlC,kBAAkBqoC,GACxCv+B,EAAWw+B,IAAaA,EAAcx+B,SAG9Cw+B,EAAcxrC,KAAK8C,KAAK0oC,GACxBA,GAAe,KAEf,IAAI1mC,EAAW,GACXyD,EAAa,IAAIqO,EAAiB5R,GACtCF,EAASuB,KAAK4c,EAAQ/b,aAAaqB,EAAWoS,KAAK,IAAIwwB,EAAQK,GAAcA,IAC3E,IAAIL,EAAQK,GAAcA,KAC5B1mC,EAASuB,KAAK4c,EAAQ/b,aAAaqB,EAAWoS,KAAK,IAAIwwB,GAASK,GAAcA,IAC5E,IAAIL,GAASK,GAAcA,KAC7B1mC,EAASuB,KAAK4c,EAAQ/b,aAAaqB,EAAWoS,KAAK,IAAIwwB,GAASK,EAAaA,IAC3E,IAAIL,GAASK,EAAaA,KAC5B1mC,EAASuB,KAAK4c,EAAQ/b,aAAaqB,EAAWoS,KAAK,IAAIwwB,EAAQK,EAAaA,IAC1E,IAAIL,EAAQK,EAAaA,KAC3B,MAGMtiB,EAHU,IAAImQ,EAASv0B,EAAU,KAAME,EAAM2B,WAG9BL,QAAQtB,EAAMX,OAAO5B,OAAO+oC,IAGjD,IAAItpC,EAASuL,EAAI4E,UAAU6W,GAE3B,OADAhnB,EAAO+Z,WAAaxO,EAAIwO,WACjB/Z,K,gBChEG,EAAQ,GAApB,MACM,sBAACogB,EAAqB,mBAAEH,EAAkB,iBAAED,GAAoB,EAAQ,KACxE,oBAAC9hB,GAAuB,EAAQ,GAChCa,EAAW,EAAQ,GAEnBqiB,GADU,EAAQ,IACT,EAAQ,MACjB,kBAACzV,EAAiB,WAAE7B,EAAU,UAAEqE,EAAS,UAAEf,GAAa,EAAQ,GAkEhEyZ,EAAY,SAAUlgB,GAE1B,IAAIzK,EAAGS,EACP,GAAK,YAFLgK,EAAUA,GAAW,KAEU,YAAaA,EAAU,CACpD,GAAK,WAAYA,GAAa,WAAYA,EACxC,MAAM,IAAI7G,MAAM,mGAElB,IAAIypC,EAAUnpB,EAAsBzZ,EAAS,UAAW,CAAC,EAAG,IACxD6iC,EAAUppB,EAAsBzZ,EAAS,UAAW,CAAC,EAAG,IAC5DzK,EAAIqtC,EAAQnpC,KAAKopC,GAASjpC,MAAM,IAChC5D,EAAI6sC,EAAQlpC,MAAMipC,GAAShpC,MAAM,SAEjCrE,EAAIkkB,EAAsBzZ,EAAS,SAAU,CAAC,EAAG,IACjDhK,EAAIyjB,EAAsBzZ,EAAS,SAAU,CAAC,EAAG,IAEnDhK,EAAIA,EAAEwD,MACN,IAAIspC,EAAQ,IAAI1qC,EAASpC,EAAEsC,GAAItC,EAAEuC,GAC7B6H,EAAS,CACX7K,EAAEkE,KAAKzD,GAAIT,EAAEkE,KAAKqpC,GAAQvtC,EAAEoE,MAAM3D,GAAIT,EAAEoE,MAAMmpC,IAEhD,OAAO3/B,EAAW/C,IAsFpBzL,EAAOD,QAAU,CACfsrB,OApKa,SAAUhgB,GAEvB,IAAI+I,EAAS0Q,EADbzZ,EAAUA,GAAW,GACuB,SAAU,CAAC,EAAG,IACtDlB,EAASwa,EAAmBtZ,EAAS,SAAU,GAC/C6J,EAAawP,EAAiBrZ,EAAS,aAAczI,GACrD6I,EAAS,GACb,IAAK,IAAIlL,EAAI,EAAGA,EAAI2U,EAAY3U,IAAK,CACnC,IAAI+F,EAAU,EAAI9D,KAAKkE,GAAKnG,EAAI2U,EAC5B3K,EAAQ9G,EAAS8C,iBAAiBD,GAASrB,MAAMkF,GAAQrF,KAAKsP,GAClE3I,EAAO5C,KAAK0B,GAEd,OAAOiE,EAAW/C,IA0JlB6f,QAhJc,SAAUjgB,GAExB,IAAIzK,EAAIkkB,EADRzZ,EAAUA,GAAW,GACkB,SAAU,CAAC,EAAG,IACjDhK,EAAIyjB,EAAsBzZ,EAAS,SAAU,CAAC,EAAG,IACrDhK,EAAIA,EAAEwD,MACN,IAAImgB,EAAMN,EAAiBrZ,EAAS,aAAczI,GAE9CwrC,EAAK,IAAItoB,EAAO,CAAC,CAACllB,EAAE+C,EAAG/C,EAAEgD,EAAIvC,EAAEuC,KAkBnC,OAjBAwqC,EAAKA,EAAG5kB,UAAU,CAAC5oB,EAAE+C,EAAG/C,EAAEgD,EAAIvC,EAAEuC,GAAI,CAClC+lB,QAAStoB,EAAEsC,EACXimB,QAASvoB,EAAEuC,EACXimB,cAAe,EACf3U,WAAY8P,EACZ8E,WAAW,EACXukB,OAAO,IAETD,EAAKA,EAAG5kB,UAAU,CAAC5oB,EAAE+C,EAAG/C,EAAEgD,EAAIvC,EAAEuC,GAAI,CAClC+lB,QAAStoB,EAAEsC,EACXimB,QAASvoB,EAAEuC,EACXimB,cAAe,EACf3U,WAAY8P,EACZ8E,WAAW,EACXukB,OAAO,IAETD,EAAKA,EAAGvnB,QACDhU,EAAUu7B,IAwHjB7iB,YACAC,iBArEuB,SAAUngB,GAEjC,IAAI+I,EAAQjK,EACZ,GAAK,YAFLkB,EAAUA,GAAW,KAEU,YAAaA,EAAU,CACpD,GAAK,WAAYA,GAAa,WAAYA,EACxC,MAAM,IAAI7G,MAAM,0GAElB,IAAIypC,EAAUnpB,EAAsBzZ,EAAS,UAAW,CAAC,EAAG,IACxD6iC,EAAUppB,EAAsBzZ,EAAS,UAAW,CAAC,EAAG,IAC5D+I,EAAS65B,EAAQnpC,KAAKopC,GAASjpC,MAAM,IACrCkF,EAAS+jC,EAAQlpC,MAAMipC,GAAShpC,MAAM,SAEtCmP,EAAS0Q,EAAsBzZ,EAAS,SAAU,CAAC,EAAG,IACtDlB,EAAS2a,EAAsBzZ,EAAS,SAAU,CAAC,EAAG,IAExDlB,EAASA,EAAOtF,MAChB,IAAIm4B,EAAcrY,EAAmBtZ,EAAS,cAAe,IACzD6J,EAAawP,EAAiBrZ,EAAS,aAAczI,GACrD0rC,EAAiB9rC,KAAK2D,IAAIgE,EAAOxG,EAAGwG,EAAOvG,GAC/C0qC,GAAkB,GAClBtR,EAAcx6B,KAAK2D,IAAI62B,EAAasR,GACpCtR,EAAcx6B,KAAK4D,IAAI,EAAG42B,GAC1B7yB,EAAS,IAAI1G,EAAS0G,EAAOxG,EAAIq5B,EAAa7yB,EAAOvG,EAAIo5B,GACzD,IAAIuR,EAAOhjB,EAAU,CACnBnX,OAAQA,EACRjK,OAAQA,IAKV,OAHI6yB,EAAc,IAChBuR,EAAOA,EAAKl6B,OAAO2oB,EAAa9nB,IAE3Bq5B,GAwCPl+B,sB,gBCvLF,MAAM,YAACkU,EAAW,sBAAEM,EAAqB,sBAAEC,EAAqB,0BAAEC,EAAyB,mBAAEJ,EAAkB,iBAAED,GAAoB,EAAQ,KACvI,oBAAC7hB,EAAmB,oBAAED,EAAmB,IAAEE,GAAO,EAAQ,GAC1Dw2B,EAAU,EAAQ,GAClB7T,EAAU,EAAQ,GAClBoW,EAAW,EAAQ,IACnB,UAACroB,GAAa,EAAQ,IACtBwK,EAAa,EAAQ,KACrB,aAAChV,GAAgB,EAAQ,GAgGzByiB,EAAS,SAAUpgB,GAEvB,IAGIupB,EAASC,EAASC,EAHlB1gB,EAASyQ,EADbxZ,EAAUA,GAAW,GACuB,SAAU,CAAC,EAAG,EAAG,IACzDlB,EAASwa,EAAmBtZ,EAAS,SAAU,GAC/C6J,EAAawP,EAAiBrZ,EAAS,aAAcxI,GAErD,SAAUwI,GACZupB,EAAUvpB,EAAQ2J,KAAK,GAAGzP,OAAON,MAAMkF,GACvC0qB,EAAUxpB,EAAQ2J,KAAK,GAAGzP,OAAON,MAAMkF,GACvC2qB,EAAUzpB,EAAQ2J,KAAK,GAAGzP,OAAON,MAAMkF,KAEvCyqB,EAAU,IAAI0E,EAAQ,CAAC,EAAG,EAAG,IAAIr0B,MAAMkF,GACvC0qB,EAAU,IAAIyE,EAAQ,CAAC,GAAI,EAAG,IAAIr0B,MAAMkF,GACxC2qB,EAAU,IAAIwE,EAAQ,CAAC,EAAG,EAAG,IAAIr0B,MAAMkF,IAErC+K,EAAa,IAAGA,EAAa,GACjC,IACIs5B,EADAC,EAAcjsC,KAAKynB,MAAM/U,EAAa,GAEtChH,EAAW,GACf,IAAK,IAAIwgC,EAAS,EAAGA,GAAUx5B,EAAYw5B,IAAU,CACnD,IAAI3nC,EAAkB,EAAVvE,KAAKkE,GAAWgoC,EAASx5B,EACjCy5B,EAAgB/Z,EAAQ3vB,MAAMzC,KAAKmE,IAAII,IAAQjC,KAAK+vB,EAAQ5vB,MAAMzC,KAAKC,IAAIsE,KAC/E,GAAI2nC,EAAS,EAAG,CAEd,IACIE,EAAcC,EADdvnC,EAAW,GAEf,IAAK,IAAIwnC,EAAS,EAAGA,GAAUL,EAAaK,IAAU,CACpD,IAAIC,EAAQ,GAAMvsC,KAAKkE,GAAKooC,EAASL,EACjCO,EAAWxsC,KAAKmE,IAAIooC,GACpBE,EAAWzsC,KAAKC,IAAIssC,GACpBD,EAAS,IACXxnC,EAAW,GACXA,EAASuB,KAAK,IAAI4c,EAAQrR,EAAOtP,KAAK0pC,EAAkBvpC,MAAM2pC,GAAc5pC,MAAM8vB,EAAQ7vB,MAAM4pC,OAChGvnC,EAASuB,KAAK,IAAI4c,EAAQrR,EAAOtP,KAAK6pC,EAAc1pC,MAAM2pC,GAAc5pC,MAAM8vB,EAAQ7vB,MAAM4pC,OACxFC,EAASL,GACXnnC,EAASuB,KAAK,IAAI4c,EAAQrR,EAAOtP,KAAK6pC,EAAc1pC,MAAM+pC,GAAUhqC,MAAM8vB,EAAQ7vB,MAAMgqC,OAE1F3nC,EAASuB,KAAK,IAAI4c,EAAQrR,EAAOtP,KAAK0pC,EAAkBvpC,MAAM+pC,GAAUhqC,MAAM8vB,EAAQ7vB,MAAMgqC,OAC5F/gC,EAASrF,KAAK,IAAIgzB,EAASv0B,IAC3BA,EAAW,GACXA,EAASuB,KAAK,IAAI4c,EAAQrR,EAAOtP,KAAK0pC,EAAkBvpC,MAAM2pC,GAAc9pC,KAAKgwB,EAAQ7vB,MAAM4pC,OAC/FvnC,EAASuB,KAAK,IAAI4c,EAAQrR,EAAOtP,KAAK6pC,EAAc1pC,MAAM2pC,GAAc9pC,KAAKgwB,EAAQ7vB,MAAM4pC,OACvFC,EAASL,GACXnnC,EAASuB,KAAK,IAAI4c,EAAQrR,EAAOtP,KAAK6pC,EAAc1pC,MAAM+pC,GAAUlqC,KAAKgwB,EAAQ7vB,MAAMgqC,OAEzF3nC,EAASuB,KAAK,IAAI4c,EAAQrR,EAAOtP,KAAK0pC,EAAkBvpC,MAAM+pC,GAAUlqC,KAAKgwB,EAAQ7vB,MAAMgqC,OAC3F3nC,EAASoD,UACTwD,EAASrF,KAAK,IAAIgzB,EAASv0B,KAE7BsnC,EAAeI,EACfH,EAAeI,GAGnBT,EAAoBG,EAEtB,IAAIjqC,EAASsE,EAAakF,GAI1B,OAHAxJ,EAAO+Z,WAAWgN,OAAS,IAAIzN,EAC/BtZ,EAAO+Z,WAAWgN,OAAOrX,OAAS,IAAIklB,EAAQllB,GAC9C1P,EAAO+Z,WAAWgN,OAAOyjB,UAAY96B,EAAOtP,KAAK8vB,GAC1ClwB,GA2XT1E,EAAOD,QAAU,CACf2rB,KAzgBW,SAAUrgB,GACrB,IAAIzK,EACAS,EACA4sC,EACAC,EAEJ,GAAK,YADL7iC,EAAUA,GAAW,KACU,YAAaA,EAAU,CACpD,GAAK,WAAYA,GAAa,WAAYA,EACxC,MAAM,IAAI7G,MAAM,8FAElBypC,EAAUppB,EAAsBxZ,EAAS,UAAW,CAAC,EAAG,EAAG,IAC3D6iC,EAAUrpB,EAAsBxZ,EAAS,UAAW,CAAC,EAAG,EAAG,IAC3DzK,EAAIqtC,EAAQnpC,KAAKopC,GAASjpC,MAAM,IAChC5D,EAAI6sC,EAAQlpC,MAAMipC,GAAShpC,MAAM,SAEjCrE,EAAIikB,EAAsBxZ,EAAS,SAAU,CAAC,EAAG,EAAG,IACpDhK,EAAIwjB,EAAsBxZ,EAAS,SAAU,CAAC,EAAG,EAAG,IAEtDhK,EAAIA,EAAEwD,MACN,IAAIH,EAASsE,EAAa,CACxB,CACE,CAAC,EAAG,EAAG,EAAG,GACV,EAAE,EAAG,EAAG,IAEV,CACE,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAI,EAAG,IAEV,CACE,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,GAAI,EAAG,IAEV,CACE,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAI,IAEV,CACE,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,GAAI,IAEV,CACE,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,EAAG,EAAG,KAETyB,KAAI,SAAU0kC,GACd,IAAI7nC,EAAW6nC,EAAK,GAAG1kC,KAAI,SAAUlK,GACnC,IAAIqH,EAAM,IAAI0xB,EACZ14B,EAAE+C,EAAItC,EAAEsC,GAAK,KAAW,EAAJpD,GAAS,GAAIK,EAAEgD,EAAIvC,EAAEuC,GAAK,KAAW,EAAJrD,GAAS,GAAIK,EAAEiD,EAAIxC,EAAEwC,GAAK,KAAW,EAAJtD,GAAS,IACjG,OAAO,IAAIklB,EAAQ7d,MAErB,OAAO,IAAIi0B,EAASv0B,EAAU,UAahC,OAXA5C,EAAO+Z,WAAWiN,KAAO,IAAI1N,EAC7BtZ,EAAO+Z,WAAWiN,KAAKtX,OAAS,IAAIklB,EAAQ14B,GAE5C8D,EAAO+Z,WAAWiN,KAAK0jB,YAAc,CACnC,IAAI57B,EAAU,IAAI8lB,EAAQ,CAACj4B,EAAEsC,EAAG,EAAG,IAAImB,KAAKlE,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,IAClE,IAAI4S,EAAU,IAAI8lB,EAAQ,EAAEj4B,EAAEsC,EAAG,EAAG,IAAImB,KAAKlE,GAAI,EAAE,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,IACpE,IAAI4S,EAAU,IAAI8lB,EAAQ,CAAC,EAAGj4B,EAAEuC,EAAG,IAAIkB,KAAKlE,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,IAClE,IAAI4S,EAAU,IAAI8lB,EAAQ,CAAC,GAAIj4B,EAAEuC,EAAG,IAAIkB,KAAKlE,GAAI,CAAC,GAAI,EAAG,GAAI,CAAC,EAAG,EAAG,IACpE,IAAI4S,EAAU,IAAI8lB,EAAQ,CAAC,EAAG,EAAGj4B,EAAEwC,IAAIiB,KAAKlE,GAAI,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,IAClE,IAAI4S,EAAU,IAAI8lB,EAAQ,CAAC,EAAG,GAAIj4B,EAAEwC,IAAIiB,KAAKlE,GAAI,CAAC,EAAG,GAAI,GAAI,CAAC,EAAG,EAAG,KAE/D8D,GA2cP+mB,SACAE,YAlGkB,SAAUtgB,GAC5B,IACI+I,EACAi7B,EACApB,EACAC,EAEJ,GAAK,YADL7iC,EAAUA,GAAW,KACU,YAAaA,EAAU,CACpD,GAAK,WAAYA,GAAa,WAAYA,EACxC,MAAM,IAAI7G,MAAM,qGAElBypC,EAAUppB,EAAsBxZ,EAAS,UAAW,CAAC,EAAG,EAAG,IAC3D6iC,EAAUrpB,EAAsBxZ,EAAS,UAAW,CAAC,EAAG,EAAG,IAC3D+I,EAAS65B,EAAQnpC,KAAKopC,GAASjpC,MAAM,IACrCoqC,EAAanB,EAAQlpC,MAAMipC,GAAShpC,MAAM,SAE1CmP,EAASyQ,EAAsBxZ,EAAS,SAAU,CAAC,EAAG,EAAG,IACzDgkC,EAAaxqB,EAAsBxZ,EAAS,SAAU,CAAC,EAAG,EAAG,IAE/DgkC,EAAaA,EAAWxqC,MACxB,IAAIqQ,EAAawP,EAAiBrZ,EAAS,aAAcxI,GACrDqS,EAAa,IAAGA,EAAa,GAC7BA,EAAa,GAAM,GAAKA,EAAa,IAAGA,EAAa,GACzD,IAAI8nB,EAAcnY,EAAsBxZ,EAAS,cAAe,CAAC,GAAK,GAAK,KAE3E2xB,EAAc1D,EAAQ70B,OAAOjC,KAAK4D,IAAI42B,EAAYr5B,EAxBtC,KAwBiDnB,KAAK4D,IAAI42B,EAAYp5B,EAxBtE,KAwBiFpB,KAAK4D,IAAI42B,EAAYn5B,EAxBtG,MAyBZ,IAAIyrC,EAAcD,EAAWrqC,MAAMg4B,GACnC,GAAIsS,EAAY3rC,EAAI,GAAK2rC,EAAY1rC,EAAI,GAAK0rC,EAAYzrC,EAAI,EAC5D,MAAM,IAAIW,MAAM,0BAElB,IAAIwgB,EAAMyG,EAAO,CAACthB,OAAQ,EAAG+K,WAAYA,IAiBzC,OAhBA8P,EAAMA,EAAI6V,MAAMmC,GAChBsS,EAAY3rC,EAAIb,IAAQkiB,EAAMA,EAAIpF,eAAe,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,EAAI0vB,EAAY3rC,IACvF2rC,EAAY1rC,EAAId,IAAQkiB,EAAMA,EAAIpF,eAAe,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,EAAI0vB,EAAY1rC,IACvF0rC,EAAYzrC,EAAIf,IAAQkiB,EAAMA,EAAIpF,eAAe,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,GAAI,EAAI0vB,EAAYzrC,IACvFmhB,EAAMA,EAAI3b,UAAU,EAAEimC,EAAY3rC,EAAIyQ,EAAOzQ,GAAI2rC,EAAY1rC,EAAIwQ,EAAOxQ,GAAI0rC,EAAYzrC,EAAIuQ,EAAOvQ,IACnGmhB,EAAMA,EAAItQ,eACVsQ,EAAIvG,WAAWkN,YAAc,IAAI3N,EACjCgH,EAAIvG,WAAWkN,YAAYvX,OAAS,IAAIqR,EAAQrR,GAChD4Q,EAAIvG,WAAWkN,YAAYyjB,YAAc,CACvC,IAAI57B,EAAU,IAAI8lB,EAAQ,CAAC+V,EAAW1rC,EAAG,EAAG,IAAImB,KAAKsP,GAAS,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,IAChF,IAAIZ,EAAU,IAAI8lB,EAAQ,EAAE+V,EAAW1rC,EAAG,EAAG,IAAImB,KAAKsP,GAAS,EAAE,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,IAClF,IAAIZ,EAAU,IAAI8lB,EAAQ,CAAC,EAAG+V,EAAWzrC,EAAG,IAAIkB,KAAKsP,GAAS,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,IAChF,IAAIZ,EAAU,IAAI8lB,EAAQ,CAAC,GAAI+V,EAAWzrC,EAAG,IAAIkB,KAAKsP,GAAS,CAAC,GAAI,EAAG,GAAI,CAAC,EAAG,EAAG,IAClF,IAAIZ,EAAU,IAAI8lB,EAAQ,CAAC,EAAG,EAAG+V,EAAWxrC,IAAIiB,KAAKsP,GAAS,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG,EAAG,IAChF,IAAIZ,EAAU,IAAI8lB,EAAQ,CAAC,EAAG,GAAI+V,EAAWxrC,IAAIiB,KAAKsP,GAAS,CAAC,EAAG,GAAI,GAAI,CAAC,EAAG,EAAG,KAE7E4Q,GAoDP4G,SA5We,SAAUvgB,GACzB,IAAI/I,EAAIuiB,EAAsBxZ,EAAS,QAAS,CAAC,GAAI,EAAG,IACpDkkC,EAAI1qB,EAAsBxZ,EAAS,MAAO,CAAC,EAAG,EAAG,IACjDhK,EAAIsjB,EAAmBtZ,EAAS,SAAU,GAC1CmkC,EAAO7qB,EAAmBtZ,EAAS,YAAahK,GAChDouC,EAAS9qB,EAAmBtZ,EAAS,cAAehK,GACpDkuB,EAAQ5K,EAAmBtZ,EAAS,cAAe,KAGvD,GAFAkkB,EAAQA,EAAQ,IAAMA,EAAQ,IAAMA,EAE/BigB,EAAO,GAAOC,EAAS,EAC1B,MAAM,IAAIjrC,MAAM,iCAElB,GAAc,IAATgrC,GAA2B,IAAXC,EACnB,MAAM,IAAIjrC,MAAM,sDAGlB,IAAImpB,EAASjJ,EAAiBrZ,EAAS,aAAczI,GACjD8sC,EAAMH,EAAEvqC,MAAM1C,GACdqtC,EAAQD,EAAInqC,OACZqqC,EAAQD,EAAMzpC,0BAA0BX,OAGxCsqC,EAAQD,EAAMpqC,MAAMmqC,GAAOpqC,OAC3Byd,EAAQ,IAAIyC,EAAQnjB,GACpB2gB,EAAM,IAAIwC,EAAQ8pB,GAClBrhC,EAAW,GAEf,SAAS3D,EAAMiwB,EAAOpuB,EAAOjC,GAC3B,IAAIpD,EAAQqF,EAAQ5J,KAAKkE,GAAK6oB,EAAQ,IAClCugB,EAAMF,EAAM3qC,MAAMzC,KAAKmE,IAAII,IAAQjC,KAAK+qC,EAAM5qC,MAAMzC,KAAKC,IAAIsE,KAC7Da,EAAMtF,EAAEwC,KAAK4qC,EAAIzqC,MAAMu1B,IAAQ11B,KAAKgrC,EAAI7qC,MAAMkF,IAClD,OAAO,IAAIsb,EAAQ7d,GAGrB,GAAI2nB,EAAQ,EAAG,CACb,IAAK,IAAIhvB,EAAI,EAAGA,EAAIotB,EAAQptB,IAAK,CAC/B,IAAI2oB,EAAK3oB,EAAIotB,EACTxE,GAAM5oB,EAAI,GAAKotB,EACf6hB,IAASC,GACXvhC,EAASrF,KAAK,IAAIgzB,EAAS,CAAC7Y,EAAOzY,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG4e,EAAIqmB,MACpEthC,EAASrF,KAAK,IAAIgzB,EAAS,CAACtxB,EAAM,EAAG4e,EAAIqmB,GAAOjlC,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG4e,EAAIqmB,MACrGthC,EAASrF,KAAK,IAAIgzB,EAAS,CAAC5Y,EAAK1Y,EAAM,EAAG4e,EAAIqmB,GAAOjlC,EAAM,EAAG2e,EAAIsmB,QAE9DC,EAAS,IACXvhC,EAASrF,KAAK,IAAIgzB,EAAS,CAAC7Y,EAAOzY,EAAM,EAAG2e,EAAIumB,GAASllC,EAAM,EAAG4e,EAAIsmB,MACtEvhC,EAASrF,KAAK,IAAIgzB,EAAS,CAACtxB,EAAM,EAAG2e,EAAIumB,GAASllC,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG4e,EAAIsmB,OAEjFD,EAAO,IACTthC,EAASrF,KAAK,IAAIgzB,EAAS,CAAC5Y,EAAK1Y,EAAM,EAAG4e,EAAIqmB,GAAOjlC,EAAM,EAAG2e,EAAIsmB,MAClEthC,EAASrF,KAAK,IAAIgzB,EAAS,CAACtxB,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG4e,EAAIqmB,GAAOjlC,EAAM,EAAG4e,EAAIsmB,QAInFlgB,EAAQ,MACVrhB,EAASrF,KAAK,IAAIgzB,EAAS,CAAC7Y,EAAOC,EAAK1Y,EAAM,EAAG,EAAGklC,MACpDvhC,EAASrF,KAAK,IAAIgzB,EAAS,CAACtxB,EAAM,EAAG,EAAGklC,GAASxsB,EAAK1Y,EAAM,EAAG,EAAGilC,MAClEthC,EAASrF,KAAK,IAAIgzB,EAAS,CAAC7Y,EAAOzY,EAAM,EAAG,EAAGklC,GAASxsB,KACxD/U,EAASrF,KAAK,IAAIgzB,EAAS,CAACtxB,EAAM,EAAG,EAAGklC,GAASllC,EAAM,EAAG,EAAGilC,GAAOvsB,MAGxE,IAAIve,EAASsE,EAAakF,GAC1BxJ,EAAO+Z,WAAWmN,SAAW,IAAI5N,EACjCtZ,EAAO+Z,WAAWmN,SAAS5I,MAAQ,IAAIxP,EAAUlR,EAAGqtC,EAAM/qC,UAAWgrC,GACrElrC,EAAO+Z,WAAWmN,SAAS3I,IAAM,IAAIzP,EAAU+7B,EAAGI,EAAOC,GACzD,IAAIG,EAAYztC,EAAEwC,KAAK4qC,EAAIzqC,MAAM,KAC7B+qC,EAASJ,EAAM9U,OAAOx4B,EAAGqtC,GAAQpgB,EAAQ,GAAGtqB,OAAOwqC,EAASD,GAAQ,GACpES,EAAWD,EAAOxqC,MAAMmqC,GAI5B,OAFAjrC,EAAO+Z,WAAWmN,SAASskB,WAAa,IAAI18B,EAAUu8B,EAAUjrC,KAAKkrC,GAASA,EAAQL,GACtFjrC,EAAO+Z,WAAWmN,SAASukB,aAAe,IAAI38B,EAAUu8B,EAAUjrC,KAAKmrC,GAAWA,EAAUN,GACrFjrC,GAuSPmnB,gBAnRsB,SAAUxgB,GAChC,IAII+kC,EAJAvhC,EAAKgW,EAAsBxZ,EAAS,QAAS,CAAC,GAAI,EAAG,IACrDyD,EAAK+V,EAAsBxZ,EAAS,MAAO,CAAC,EAAG,EAAG,IAClDlB,EAASwa,EAAmBtZ,EAAS,SAAU,GAC/C0D,EAAYD,EAAG9J,MAAM6J,GAGvBuhC,EADE5tC,KAAKqC,IAAIkK,EAAUpL,GAAKnB,KAAKqC,IAAIkK,EAAUnL,GAC7B,IAAI01B,EAAQ,EAAG,EAAG,GAElB,IAAIA,EAAQ,EAAG,EAAG,GAEpC,IAAIzyB,EAASge,EAAsBxZ,EAAS,SAAU+kC,GAClDl7B,EAAawP,EAAiBrZ,EAAS,aAAcxI,GACrDqS,EAAa,IAAGA,EAAa,GACjC,IAAIhH,EAAW,GACXugC,EAAcjsC,KAAKgL,MAAM,IAAO0H,GAEpC,GADanG,EAAUhL,SACVjB,EACX,OAAO2oB,EAAO,CACZrX,OAAQvF,EACR1E,OAAQA,EACR+K,WAAYA,IAGhB,IAGIs5B,EAHA1Z,EAAU/lB,EAAUxJ,OAAON,MAAMkF,GACjCyqB,EAAUE,EAAQtvB,MAAMqB,GAAQtB,OAAON,MAAMkF,GAC7C0qB,EAAUD,EAAQpvB,MAAMsvB,GAASvvB,OAAON,MAAMkF,GAElD,IAAK,IAAIukC,EAAS,EAAGA,GAAUx5B,EAAYw5B,IAAU,CACnD,IAAI3nC,EAAkB,EAAVvE,KAAKkE,GAAWgoC,EAASx5B,EACjCy5B,EAAgB/Z,EAAQ3vB,MAAMzC,KAAKmE,IAAII,IAAQjC,KAAK+vB,EAAQ5vB,MAAMzC,KAAKC,IAAIsE,KAC/E,GAAI2nC,EAAS,EAAG,CAEd,IAMIE,EAAcC,EANdvnC,EAAW,GACfA,EAASuB,KAAK,IAAI4c,EAAQ5W,EAAG/J,KAAK6pC,KAClCrnC,EAASuB,KAAK,IAAI4c,EAAQ5W,EAAG/J,KAAK0pC,KAClClnC,EAASuB,KAAK,IAAI4c,EAAQ3W,EAAGhK,KAAK0pC,KAClClnC,EAASuB,KAAK,IAAI4c,EAAQ3W,EAAGhK,KAAK6pC,KAClCzgC,EAASrF,KAAK,IAAIgzB,EAASv0B,IAE3B,IAAK,IAAIwnC,EAAS,EAAGA,GAAUL,EAAaK,IAAU,CACpD,IAAIC,EAAQ,GAAMvsC,KAAKkE,GAAKooC,EAASL,EAEjCO,EAAWxsC,KAAKmE,IAAIooC,GACpBE,EAAWzsC,KAAKC,IAAIssC,GACpBD,EAAS,IACXxnC,EAAW,GACXA,EAASuB,KAAK,IAAI4c,EAAQ5W,EAAG/J,KAAK0pC,EAAkBvpC,MAAM2pC,GAAc5pC,MAAM8vB,EAAQ7vB,MAAM4pC,OAC5FvnC,EAASuB,KAAK,IAAI4c,EAAQ5W,EAAG/J,KAAK6pC,EAAc1pC,MAAM2pC,GAAc5pC,MAAM8vB,EAAQ7vB,MAAM4pC,OACpFC,EAASL,GACXnnC,EAASuB,KAAK,IAAI4c,EAAQ5W,EAAG/J,KAAK6pC,EAAc1pC,MAAM+pC,GAAUhqC,MAAM8vB,EAAQ7vB,MAAMgqC,OAEtF3nC,EAASuB,KAAK,IAAI4c,EAAQ5W,EAAG/J,KAAK0pC,EAAkBvpC,MAAM+pC,GAAUhqC,MAAM8vB,EAAQ7vB,MAAMgqC,OACxF/gC,EAASrF,KAAK,IAAIgzB,EAASv0B,IAC3BA,EAAW,GACXA,EAASuB,KAAK,IAAI4c,EAAQ3W,EAAGhK,KAAK0pC,EAAkBvpC,MAAM2pC,GAAc9pC,KAAKgwB,EAAQ7vB,MAAM4pC,OAC3FvnC,EAASuB,KAAK,IAAI4c,EAAQ3W,EAAGhK,KAAK6pC,EAAc1pC,MAAM2pC,GAAc9pC,KAAKgwB,EAAQ7vB,MAAM4pC,OACnFC,EAASL,GACXnnC,EAASuB,KAAK,IAAI4c,EAAQ3W,EAAGhK,KAAK6pC,EAAc1pC,MAAM+pC,GAAUlqC,KAAKgwB,EAAQ7vB,MAAMgqC,OAErF3nC,EAASuB,KAAK,IAAI4c,EAAQ3W,EAAGhK,KAAK0pC,EAAkBvpC,MAAM+pC,GAAUlqC,KAAKgwB,EAAQ7vB,MAAMgqC,OACvF3nC,EAASoD,UACTwD,EAASrF,KAAK,IAAIgzB,EAASv0B,KAE7BsnC,EAAeI,EACfH,EAAeI,GAGnBT,EAAoBG,EAEtB,IAAIjqC,EAASsE,EAAakF,GACtBwhC,EAAM5a,EAAQvvB,OACdqqC,EAAQhb,EAAQrvB,OAKpB,OAJAb,EAAO+Z,WAAWoN,gBAAkB,IAAI7N,EACxCtZ,EAAO+Z,WAAWoN,gBAAgB7I,MAAQ,IAAIxP,EAAU3E,EAAI6gC,EAAI9qC,UAAWgrC,GAC3ElrC,EAAO+Z,WAAWoN,gBAAgB5I,IAAM,IAAIzP,EAAU1E,EAAI4gC,EAAKE,GAC/DlrC,EAAO+Z,WAAWoN,gBAAgBqjB,UAAYrgC,EAAG/J,KAAK8vB,GAC/ClwB,GAuMPonB,iBAhLuB,SAAUzgB,GACjC,IAAI/I,EAAIuiB,EAAsBxZ,EAAS,QAAS,CAAC,GAAI,EAAG,IACpDkkC,EAAI1qB,EAAsBxZ,EAAS,MAAO,CAAC,EAAG,EAAG,IACjDhK,EAAIyjB,EAAsBzZ,EAAS,SAAU,CAAC,EAAG,IACjDmkC,EAAO1qB,EAAsBzZ,EAAS,YAAahK,GACnDouC,EAAS3qB,EAAsBzZ,EAAS,cAAehK,GAE3D,GAAKmuC,EAAKvrC,GAAK,GAAOwrC,EAAOxrC,GAAK,GAAOurC,EAAKrrC,GAAK,GAAOsrC,EAAOtrC,GAAK,EACpE,MAAM,IAAIK,MAAM,iCAElB,KAAiB,IAAZgrC,EAAKvrC,IAAwB,IAAZurC,EAAKrrC,IAA4B,IAAdsrC,EAAOxrC,IAA0B,IAAdwrC,EAAOtrC,IACjE,MAAM,IAAIK,MAAM,sDAGlB,IAAImpB,EAASjJ,EAAiBrZ,EAAS,aAAczI,GACjD8sC,EAAMH,EAAEvqC,MAAM1C,GACdqtC,EAAQD,EAAInqC,OACZqqC,EAAQD,EAAMzpC,0BAA0BX,OAGxCsqC,EAAQD,EAAMpqC,MAAMmqC,GAAOpqC,OAC3Byd,EAAQ,IAAIyC,EAAQnjB,GACpB2gB,EAAM,IAAIwC,EAAQ8pB,GAClBrhC,EAAW,GAEf,SAAS3D,EAAMiwB,EAAOpuB,EAAOjC,GAC3B,IAAIpD,EAAQqF,EAAQ5J,KAAKkE,GAAK,EAC1BopC,EAAMF,EAAM3qC,MAAMkF,EAAOlG,GAAKzB,KAAKmE,IAAII,IAAQjC,KAAK+qC,EAAM5qC,MAAMkF,EAAOhG,GAAK3B,KAAKC,IAAIsE,KACrFa,EAAMtF,EAAEwC,KAAK4qC,EAAIzqC,MAAMu1B,IAAQ11B,KAAKgrC,GACxC,OAAO,IAAIrqB,EAAQ7d,GAGrB,IAAK,IAAIrH,EAAI,EAAGA,EAAIotB,EAAQptB,IAAK,CAC/B,IAAI2oB,EAAK3oB,EAAIotB,EACTxE,GAAM5oB,EAAI,GAAKotB,EAEf6hB,EAAKvrC,KAAOwrC,EAAOxrC,IAAMurC,EAAKrrC,KAAOsrC,EAAOtrC,IAC9C+J,EAASrF,KAAK,IAAIgzB,EAAS,CAAC7Y,EAAOzY,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG4e,EAAIqmB,MACpEthC,EAASrF,KAAK,IAAIgzB,EAAS,CAACtxB,EAAM,EAAG4e,EAAIqmB,GAAOjlC,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG4e,EAAIqmB,MACrGthC,EAASrF,KAAK,IAAIgzB,EAAS,CAAC5Y,EAAK1Y,EAAM,EAAG4e,EAAIqmB,GAAOjlC,EAAM,EAAG2e,EAAIsmB,QAE9DC,EAAOxrC,GAAK,IACdiK,EAASrF,KAAK,IAAIgzB,EAAS,CAAC7Y,EAAOzY,EAAM,EAAG2e,EAAIumB,GAASllC,EAAM,EAAG4e,EAAIsmB,MACtEvhC,EAASrF,KAAK,IAAIgzB,EAAS,CAACtxB,EAAM,EAAG2e,EAAIumB,GAASllC,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG4e,EAAIsmB,OAEjFD,EAAKvrC,GAAK,IACZiK,EAASrF,KAAK,IAAIgzB,EAAS,CAAC5Y,EAAK1Y,EAAM,EAAG4e,EAAIqmB,GAAOjlC,EAAM,EAAG2e,EAAIsmB,MAClEthC,EAASrF,KAAK,IAAIgzB,EAAS,CAACtxB,EAAM,EAAG2e,EAAIsmB,GAAOjlC,EAAM,EAAG4e,EAAIqmB,GAAOjlC,EAAM,EAAG4e,EAAIsmB,QAIvF,IAAI/qC,EAASsE,EAAakF,GAK1B,OAJAxJ,EAAO+Z,WAAWmN,SAAW,IAAI5N,EACjCtZ,EAAO+Z,WAAWmN,SAAS5I,MAAQ,IAAIxP,EAAUlR,EAAGqtC,EAAM/qC,UAAWgrC,GACrElrC,EAAO+Z,WAAWmN,SAAS3I,IAAM,IAAIzP,EAAU+7B,EAAGI,EAAOC,GACzDlrC,EAAO+Z,WAAWmN,SAASsjB,UAAY5sC,EAAEwC,KAAK8qC,EAAM3qC,MAAMwqC,IACnD/qC,GAyHPqnB,WA/CiB,SAAU1gB,GAE3B,GAAK,WADLA,EAAUA,GAAW,KACU,UAAWA,EACxC,MAAM,IAAI7G,MAAM,gDAElB,IAAI8C,EAAWyd,EAA0B1Z,EAAS,SAAU,CAC1D,CAAC,EAAG,EAAG,GACP,CAAC,GAAI,EAAG,GACR,EAAE,GAAI,EAAG,GACT,EAAE,EAAG,EAAG,GACR,CAAC,EAAG,EAAG,KAENZ,KAAI,SAAU+Y,GACb,OAAO,IAAIiC,EAAQjC,MAEnB6sB,EAAQ9rB,EAAYlZ,EAAS,QAAS,CACxC,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,KAGTglC,EAAM1nC,SAAQ,SAAU2nC,GACtBA,EAAK5lC,aAEP,IAAIwD,EAAWmiC,EAAM5lC,KAAI,SAAU6lC,GACjC,OAAO,IAAIzU,EAASyU,EAAK7lC,KAAI,SAAUkhC,GACrC,OAAOrkC,EAASqkC,UAQpB,OAAO3iC,EAAakF,GAAUwG,kB,cCzhBhC,MAAM67B,EAAY,CAEhB,MAAS,CAAC,EAAS,EAAS,GAC5B,OAAU,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACvC,KAAQ,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACrC,MAAS,CAAC,EAAW,EAAW,GAChC,OAAU,CAAC,IAAM,IAAK,EAAS,GAC/B,IAAO,CAAC,EAAW,EAAS,GAC5B,OAAU,CAAC,IAAM,IAAK,EAAS,IAAM,KACrC,QAAW,CAAC,EAAW,EAAS,GAChC,MAAS,CAAC,EAAS,IAAM,IAAK,GAC9B,KAAQ,CAAC,EAAS,EAAW,GAC7B,MAAS,CAAC,IAAM,IAAK,IAAM,IAAK,GAChC,OAAU,CAAC,EAAW,EAAW,GACjC,KAAQ,CAAC,EAAS,EAAS,IAAM,KACjC,KAAQ,CAAC,EAAS,EAAS,GAC3B,KAAQ,CAAC,EAAS,IAAM,IAAK,IAAM,KACnC,KAAQ,CAAC,EAAS,EAAW,GAE7B,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,GACpC,aAAgB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAE7C,WAAc,CAAC,IAAM,IAAK,EAAW,IAAM,KAC3C,MAAS,CAAC,IAAM,IAAK,EAAW,GAChC,MAAS,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACtC,OAAU,CAAC,EAAW,IAAM,IAAK,IAAM,KAEvC,eAAkB,CAAC,EAAW,IAAM,IAAK,IAAM,KAE/C,WAAc,CAAC,IAAM,IAAK,GAAK,IAAK,IAAM,KAC1C,MAAS,CAAC,IAAM,IAAK,GAAK,IAAK,GAAK,KACpC,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,UAAa,CAAC,GAAK,IAAK,IAAM,IAAK,IAAM,KACzC,WAAc,CAAC,IAAM,IAAK,EAAW,GACrC,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,GAAK,KACzC,MAAS,CAAC,EAAW,IAAM,IAAK,GAAK,KACrC,eAAkB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC/C,SAAY,CAAC,EAAW,IAAM,IAAK,IAAM,KACzC,QAAW,CAAC,IAAM,IAAK,GAAK,IAAK,GAAK,KACtC,KAAQ,CAAC,EAAS,EAAW,GAC7B,SAAY,CAAC,EAAS,EAAS,IAAM,KACrC,SAAY,CAAC,EAAS,IAAM,IAAK,IAAM,KACvC,cAAiB,CAAC,IAAM,IAAK,IAAM,IAAK,GAAK,KAC7C,SAAY,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACzC,UAAa,CAAC,EAAS,IAAM,IAAK,GAClC,SAAY,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACzC,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,YAAe,CAAC,IAAM,IAAK,EAAS,IAAM,KAC1C,eAAkB,CAAC,GAAK,IAAK,IAAM,IAAK,GAAK,KAC7C,WAAc,CAAC,EAAW,IAAM,IAAK,GACrC,WAAc,CAAC,GAAW,GAAK,IAAK,IACpC,QAAW,CAAC,IAAM,IAAK,EAAS,GAChC,WAAc,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC3C,aAAgB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC7C,cAAiB,CAAC,GAAK,IAAK,GAAK,IAAK,IAAM,KAC5C,cAAiB,CAAC,GAAK,IAAK,GAAK,IAAK,GAAK,KAC3C,cAAiB,CAAC,GAAK,IAAK,GAAK,IAAK,GAAK,KAC3C,cAAiB,CAAC,EAAS,IAAM,IAAK,IAAM,KAC5C,WAAc,CAAC,IAAM,IAAK,EAAS,IAAM,KACzC,SAAY,CAAC,EAAW,GAAK,IAAK,IAAM,KACxC,YAAe,CAAC,EAAS,IAAM,IAAK,GACpC,QAAW,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACxC,QAAW,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACxC,WAAc,CAAC,GAAK,IAAK,IAAM,IAAK,GACpC,UAAa,CAAC,IAAM,IAAK,GAAK,IAAK,GAAK,KACxC,YAAe,CAAC,EAAW,IAAM,IAAK,IAAM,KAC5C,YAAe,CAAC,GAAK,IAAK,IAAM,IAAK,GAAK,KAE1C,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,WAAc,CAAC,IAAM,IAAK,IAAM,IAAK,GACrC,KAAQ,CAAC,EAAW,IAAM,IAAK,GAC/B,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,GAAK,KAGzC,YAAe,CAAC,IAAM,IAAK,EAAW,GAAK,KAC3C,KAAQ,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACrC,SAAY,CAAC,IAAM,IAAK,EAAW,IAAM,KACzC,QAAW,CAAC,EAAW,IAAM,IAAK,IAAM,KACxC,UAAa,CAAC,IAAM,IAAK,GAAK,IAAK,GAAK,KACxC,OAAU,CAAC,GAAK,IAAK,EAAS,IAAM,KACpC,MAAS,CAAC,EAAW,EAAW,IAAM,KACtC,MAAS,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACtC,SAAY,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACzC,cAAiB,CAAC,EAAW,IAAM,IAAK,IAAM,KAC9C,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,GACpC,aAAgB,CAAC,EAAW,IAAM,IAAK,IAAM,KAC7C,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,WAAc,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC3C,UAAa,CAAC,IAAM,IAAK,EAAW,GACpC,qBAAwB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACrD,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,WAAc,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC3C,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,UAAa,CAAC,EAAW,IAAM,IAAK,IAAM,KAC1C,YAAe,CAAC,EAAW,IAAM,IAAK,IAAM,KAC5C,cAAiB,CAAC,GAAK,IAAK,IAAM,IAAK,IAAM,KAC7C,aAAgB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC7C,eAAkB,CAAC,IAAM,IAAK,IAAM,IAAK,IACzC,eAAkB,CAAC,IAAM,IAAK,IAAM,IAAK,IACzC,eAAkB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC/C,YAAe,CAAC,EAAW,EAAW,IAAM,KAE5C,UAAa,CAAC,GAAK,IAAK,IAAM,IAAK,GAAK,KACxC,MAAS,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACtC,QAAW,CAAC,EAAW,EAAS,GAEhC,iBAAoB,CAAC,GAAW,IAAM,IAAK,IAAM,KACjD,WAAc,CAAC,EAAS,EAAS,IAAM,KACvC,aAAgB,CAAC,IAAM,IAAK,GAAK,IAAK,IAAM,KAC5C,aAAgB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC7C,eAAkB,CAAC,GAAK,IAAK,IAAM,IAAK,IAAM,KAC9C,gBAAmB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAChD,kBAAqB,CAAC,EAAS,IAAM,IAAK,IAAM,KAChD,gBAAmB,CAAC,GAAK,IAAK,IAAM,IAAK,IACzC,gBAAmB,CAAC,IAAM,IAAK,GAAK,IAAK,IAAM,KAC/C,aAAgB,CAAC,GAAK,IAAK,GAAK,IAAK,IAAM,KAC3C,UAAa,CAAC,IAAM,IAAK,EAAW,IAAM,KAC1C,UAAa,CAAC,EAAW,IAAM,IAAK,IAAM,KAC1C,SAAY,CAAC,EAAW,IAAM,IAAK,IAAM,KACzC,YAAe,CAAC,EAAW,IAAM,IAAK,IAAM,KAE5C,QAAW,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAExC,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,GAAK,KACzC,OAAU,CAAC,EAAW,IAAM,IAAK,GACjC,UAAa,CAAC,EAAW,GAAK,IAAK,GACnC,OAAU,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACvC,cAAiB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC9C,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,cAAiB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC9C,cAAiB,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC9C,WAAc,CAAC,EAAW,IAAM,IAAK,IAAM,KAC3C,UAAa,CAAC,EAAW,IAAM,IAAK,IAAM,KAC1C,KAAQ,CAAC,IAAM,IAAK,IAAM,IAAK,GAAK,KACpC,KAAQ,CAAC,EAAW,IAAM,IAAK,IAAM,KACrC,KAAQ,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACrC,WAAc,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAG3C,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,UAAa,CAAC,GAAK,IAAK,IAAM,IAAK,IAAM,KACzC,YAAe,CAAC,IAAM,IAAK,GAAK,IAAK,GAAK,KAC1C,OAAU,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACvC,WAAc,CAAC,IAAM,IAAK,IAAM,IAAK,GAAK,KAC1C,SAAY,CAAC,GAAK,IAAK,IAAM,IAAK,GAAK,KACvC,SAAY,CAAC,EAAW,IAAM,IAAK,IAAM,KACzC,OAAU,CAAC,IAAM,IAAK,GAAK,IAAK,GAAK,KAErC,QAAW,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACxC,UAAa,CAAC,IAAM,IAAK,GAAK,IAAK,IAAM,KACzC,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,UAAa,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAC1C,KAAQ,CAAC,EAAW,IAAM,IAAK,IAAM,KACrC,YAAe,CAAC,EAAS,EAAW,IAAM,KAC1C,UAAa,CAAC,GAAK,IAAK,IAAM,IAAK,IAAM,KACzC,IAAO,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAEpC,QAAW,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACxC,OAAU,CAAC,EAAW,GAAK,IAAK,GAAK,KACrC,UAAa,CAAC,GAAK,IAAK,IAAM,IAAK,IAAM,KACzC,OAAU,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KACvC,MAAS,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAEtC,WAAc,CAAC,IAAM,IAAK,IAAM,IAAK,IAAM,KAE3C,YAAe,CAAC,IAAM,IAAK,IAAM,IAAK,GAAK,MAS7C,SAASC,EAAQluC,GACf,OAAOiuC,EAAUjuC,EAAEmuC,eAsHrB,SAASC,EAAQruC,EAAGi6B,EAAG76B,GAGrB,OAFIA,EAAI,IAAGA,GAAK,GACZA,EAAI,IAAGA,GAAK,GACZA,EAAI,EAAI,EAAUY,EAAc,GAATi6B,EAAIj6B,GAASZ,EACpCA,EAAI,GAAc66B,EAClB76B,EAAI,EAAI,EAAUY,GAAKi6B,EAAIj6B,IAAM,EAAI,EAAIZ,GAAK,EAC3CY,EAuITrC,EAAOD,QAAU,CACfywC,UACArkC,MAzPF,SAAeA,GACb,IAAIlK,EACA1B,EAAI,EACJwE,EAAIjB,UAiBR,IAbqB,iBAAVqI,IACTA,EAAQqkC,EAAQrkC,IAGdwV,OAAOwX,SAASp0B,EAAExE,MACpB4L,EAAQA,EAAM4S,OAAOha,EAAExE,IACvBA,KAGE+D,MAAM0N,QAAQjN,EAAExE,MAClBwE,EAAIA,EAAExE,GACNA,EAAI,GAED0B,EAAS8C,EAAExE,KAAMA,EAAIwE,EAAEhB,OAAQxD,IAClC0B,EAASA,EAAO2P,MAAM7M,EAAExE,IAE1B,OAAO0B,EAAO8F,SAASoE,IAmOvBwkC,QApNF,SAAiBtvC,EAAGs7B,EAAGlwB,GACjBpL,EAAE0C,SACJ0I,EAAIpL,EAAE,GACNs7B,EAAIt7B,EAAE,GACNA,EAAIA,EAAE,IAER,IAEI2uB,EACA1tB,EAHA8D,EAAM5D,KAAK4D,IAAI/E,EAAGs7B,EAAGlwB,GACrBtG,EAAM3D,KAAK2D,IAAI9E,EAAGs7B,EAAGlwB,GAGrBjM,GAAK4F,EAAMD,GAAO,EAEtB,GAAIC,IAAQD,EACV6pB,EAAI1tB,EAAI,MACH,CACL,IAAIzB,EAAIuF,EAAMD,EAEd,OADA7D,EAAI9B,EAAI,GAAMK,GAAK,EAAIuF,EAAMD,GAAOtF,GAAKuF,EAAMD,GACvCC,GACN,KAAK/E,EACH2uB,GAAK2M,EAAIlwB,GAAK5L,GAAK87B,EAAIlwB,EAAI,EAAI,GAC/B,MACF,KAAKkwB,EACH3M,GAAKvjB,EAAIpL,GAAKR,EAAI,EAClB,MACF,KAAK4L,EACHujB,GAAK3uB,EAAIs7B,GAAK97B,EAAI,EAGtBmvB,GAAK,EAGP,MAAO,CAACA,EAAG1tB,EAAG9B,IAsLdowC,QAxKF,SAAiB5gB,EAAG1tB,EAAG9B,GAMrB,IAAIa,EACAs7B,EACAlwB,EAEJ,GATIujB,EAAEjsB,SAEJzB,GADA0tB,EAAIA,EAAE,IACA,GACNxvB,EAAIwvB,EAAE,IAME,IAAN1tB,EACFjB,EAAIs7B,EAAIlwB,EAAIjM,MACP,CACL,IAAI87B,EAAI97B,EAAI,GAAMA,GAAK,EAAI8B,GAAK9B,EAAI8B,EAAI9B,EAAI8B,EACxCD,EAAI,EAAI7B,EAAI87B,EAChBj7B,EAAIqvC,EAAQruC,EAAGi6B,EAAGtM,EAAI,EAAI,GAC1B2M,EAAI+T,EAAQruC,EAAGi6B,EAAGtM,GAClBvjB,EAAIikC,EAAQruC,EAAGi6B,EAAGtM,EAAI,EAAI,GAG5B,MAAO,CAAC3uB,EAAGs7B,EAAGlwB,IAqJdokC,QA7HF,SAAiBxvC,EAAGs7B,EAAGlwB,GACjBpL,EAAE0C,SAEJ44B,GADAt7B,EAAIA,EAAE,IACA,GACNoL,EAAIpL,EAAE,IAER,IAEI2uB,EACA1tB,EAHA8D,EAAM5D,KAAK4D,IAAI/E,EAAGs7B,EAAGlwB,GACrBtG,EAAM3D,KAAK2D,IAAI9E,EAAGs7B,EAAGlwB,GAGrBlI,EAAI6B,EAEJvF,EAAIuF,EAAMD,EAGd,GAFA7D,EAAY,IAAR8D,EAAY,EAAIvF,EAAIuF,EAEpBA,IAAQD,EACV6pB,EAAI,MACC,CACL,OAAQ5pB,GACN,KAAK/E,EACH2uB,GAAK2M,EAAIlwB,GAAK5L,GAAK87B,EAAIlwB,EAAI,EAAI,GAC/B,MACF,KAAKkwB,EACH3M,GAAKvjB,EAAIpL,GAAKR,EAAI,EAClB,MACF,KAAK4L,EACHujB,GAAK3uB,EAAIs7B,GAAK97B,EAAI,EAGtBmvB,GAAK,EAGP,MAAO,CAACA,EAAG1tB,EAAGiC,IA8FdusC,QAhFF,SAAiB9gB,EAAG1tB,EAAGiC,GAMrB,IAAIlD,EAAGs7B,EAAGlwB,EALNujB,EAAEjsB,SAEJzB,GADA0tB,EAAIA,EAAE,IACA,GACNzrB,EAAIyrB,EAAE,IAIR,IAAIzvB,EAAIiC,KAAKgL,MAAU,EAAJwiB,GACfkM,EAAQ,EAAJlM,EAAQzvB,EACZ8B,EAAIkC,GAAK,EAAIjC,GACbg6B,EAAI/3B,GAAK,EAAI23B,EAAI55B,GACjBb,EAAI8C,GAAK,GAAK,EAAI23B,GAAK55B,GAE3B,OAAQ/B,EAAI,GACV,KAAK,EACHc,EAAIkD,EAAGo4B,EAAIl7B,EAAGgL,EAAIpK,EAClB,MACF,KAAK,EACHhB,EAAIi7B,EAAGK,EAAIp4B,EAAGkI,EAAIpK,EAClB,MACF,KAAK,EACHhB,EAAIgB,EAAGs6B,EAAIp4B,EAAGkI,EAAIhL,EAClB,MACF,KAAK,EACHJ,EAAIgB,EAAGs6B,EAAIL,EAAG7vB,EAAIlI,EAClB,MACF,KAAK,EACHlD,EAAII,EAAGk7B,EAAIt6B,EAAGoK,EAAIlI,EAClB,MACF,KAAK,EACHlD,EAAIkD,EAAGo4B,EAAIt6B,EAAGoK,EAAI6vB,EAItB,MAAO,CAACj7B,EAAGs7B,EAAGlwB,IA8CdskC,SApCF,SAAkBzuC,GAChB,IAAIjB,EAAI,EACJs7B,EAAI,EACJlwB,EAAI,EAMR,OALiB,IAAbnK,EAAEyB,SACJ1C,EAAI2vC,SAAS,KAAO1uC,EAAE8J,MAAM,EAAG,IAAM,IACrCuwB,EAAIqU,SAAS,KAAO1uC,EAAE8J,MAAM,EAAG,IAAM,IACrCK,EAAIukC,SAAS,KAAO1uC,EAAE8J,MAAM,EAAG,IAAM,KAEhC,CAAC/K,EAAGs7B,EAAGlwB,IA4BdwkC,SAnBF,SAAkB5vC,EAAGs7B,EAAGlwB,GAQtB,OAPIpL,EAAE0C,SAEJ44B,GADAt7B,EAAIA,EAAE,IACA,GACNoL,EAAIpL,EAAE,IAEA,IACNsgB,OAAO,SAAgB,IAAJtgB,EAAU,MAAc,IAAJs7B,EAAU,IAAY,IAAJlwB,GAASzG,SAAS,IAAIkrC,UAAU,EAAG,M,cC9YhG,SAAS1jC,EAAMzI,GACb,OAAOvC,KAAKgL,MAAMzI,GAGpB,SAASF,EAAIE,GACX,OAAOvC,KAAKqC,IAAIE,GAgElB/E,EAAOD,QAAU,CACf0C,IAtGF,SAAasC,GACX,OAAOvC,KAAKC,IAAIsC,EAAI,IAAMvC,KAAKkE,GAAK,IAsGpCC,IAnGF,SAAa5B,GACX,OAAOvC,KAAKmE,IAAI5B,EAAI,IAAMvC,KAAKkE,GAAK,IAmGpCyqC,KAhGF,SAAcpsC,GACZ,OAAOvC,KAAK2uC,KAAKpsC,IAAgB,EAAVvC,KAAKkE,IAAU,KAgGtC0qC,KA7FF,SAAcrsC,GACZ,OAAOvC,KAAK4uC,KAAKrsC,IAAgB,EAAVvC,KAAKkE,IAAU,KA6FtC2qC,IA1FF,SAAatsC,GACX,OAAOvC,KAAK6uC,IAAItsC,EAAI,IAAMvC,KAAKkE,GAAK,IA0FpC4qC,KAvFF,SAAcvsC,GACZ,OAAOvC,KAAK8uC,KAAKvsC,IAAgB,EAAVvC,KAAKkE,IAAU,KAuFtCQ,MApFF,SAAenC,EAAG0H,GAChB,OAAOjK,KAAK0E,MAAMnC,EAAG0H,IAAgB,EAAVjK,KAAKkE,IAAU,KAoF1CqkB,KAjFF,SAAchmB,GACZ,OAAOvC,KAAKuoB,KAAKhmB,IAiFjByI,QACA3I,MACAsB,IAxEF,SAAapB,EAAG0H,GACd,OAAO1H,EAAI0H,EAAI1H,EAAI0H,GAwEnBrG,IArEF,SAAarB,EAAG0H,GACd,OAAO1H,EAAI0H,EAAI1H,EAAI0H,GAqEnB8kC,MAlEF,SAAeprC,EAAKC,EAAKorC,EAAIC,GAI3B,IADA,IAAIltC,EAAI,IAAID,MAAMktC,GACTjxC,EAAI,EAAGA,EAAIixC,EAAIjxC,IACtBgE,EAAEhE,GAAKiC,KAAKkvC,UAAYtrC,EAAMD,GAAOA,GA8DvCmrB,IA1DF,SAAavsB,GACX,OAAOvC,KAAK8uB,IAAIvsB,IA0DhB4sC,OAvDF,SAAgBC,EAAIrtC,GAElB,IADA,IAAIlD,EAAI,EACCd,EAAI,EAAGA,EAAIgE,EAAER,OAAQxD,IAAK,CACjC,IAAIsxC,EAAKttC,EAAEhE,GACX,GAAIsxC,EAAG,IAAMD,EAAI,CAEfC,EAAKttC,IADLhE,GAEA,IAAIuxC,EAAKvtC,EAAEhE,EAAI,GACXI,EAAI,EAUR,OATIkxC,EAAG,KAAOC,EAAG,KACfnxC,EAAIkE,GAAK+sC,EAAKC,EAAG,KAAOC,EAAG,GAAKD,EAAG,MAInCxwC,EADEV,EAAI,EACFkxC,EAAG,IAAM,EAAIlxC,GAAKmxC,EAAG,GAAKnxC,EAE1BkxC,EAAG,IAKb,OAAOxwC,GAmCPknB,IAhCF,SAAaxjB,EAAG0H,GACd,OAAOjK,KAAK+lB,IAAIxjB,EAAG0H,IAgCnBslC,KA7BF,SAAchtC,GACZ,OAAOA,EAAI,GAAK,EAAKA,EAAI,EAAI,EAAI,GA6BjCO,KA1BF,SAAcP,GACZ,OAAOvC,KAAK8C,KAAKP,IA0BjBklB,MAvBF,SAAellB,GACb,OAAOyI,EAAMzI,EAAI,O,gBCnGnB,MAEMitC,EAAuB,CAC3BC,QAAS,EACTC,QAAS,EACTlK,MAAO,IACPmK,MAAO,OACPC,KAPkB,EAAQ,IAQ1BhrB,OAAQ,GACRirB,YAAa,kBACbC,cAAe,EACfC,cAAe,GAIjB,SAASC,EAAannC,EAAS28B,GACxBA,GAA4B,iBAAZ38B,IACnBA,EAAU,CAAC28B,MAAO38B,IAEpBA,EAAUA,GAAW,GACrB,IAAImiB,EAASvsB,OAAOoV,OAAO,GAAI27B,EAAsB3mC,GAErD,OADAmiB,EAAOwa,MAAQA,GAASxa,EAAOwa,MACxBxa,EAIT,SAASilB,EAAcpnC,EAAS+Z,GAC9B,MAAM,EAACzhB,EAAC,EAAEC,GAAK3C,OAAOoV,OAAO,CAAC1S,EAAG,EAAGC,EAAG,GAAIyH,GAAW,IACtD,IAAI8iB,EAAW/I,EAAK+I,SAChBukB,EAAU,KACVnoC,EAAQ,KACZ,IAAK,IAAIhK,EAAI,EAAGkxB,EAAKtD,EAASpqB,OAAQxD,EAAIkxB,EAAIlxB,IAAK,CACjDmyC,EAAUvkB,EAAS5tB,GACnB,IAAK,IAAI+X,EAAI,EAAGq6B,EAAKD,EAAQ3uC,OAAQuU,EAAIq6B,EAAIr6B,IAC3C/N,EAAQmoC,EAAQp6B,GAChBo6B,EAAQp6B,GAAK,CAAC/N,EAAM,GAAK5G,EAAG4G,EAAM,GAAK3G,GAG3C,OAAOwhB,EA8BT,SAASwtB,EAAWvnC,EAASwnC,GAC3B,IAAI,QACFZ,EAAO,QAAEC,EAAO,MAAElK,EAAK,KAAEoK,EAAI,OAAEhrB,EAAM,cAAEmrB,GACrCC,EAAannC,EAASwnC,GACtBC,EAAO9K,EAAM+K,WAAW,GACvBD,GAASV,EAAKU,KACjBA,EAAO,IAET,IAAIE,EAAQ,GAAGj0B,OAAOqzB,EAAKU,IACvBG,GAAS7rB,EAASmrB,GAAiBH,EAAKhrB,OACxC8rB,EAAkBX,EAAgB,EAClCprB,EAAQ6rB,EAAMp6B,QAAUq6B,EACxB9kB,EAAW,GACXglB,EAAW,GACf,IAAK,IAAI5yC,EAAI,EAAGkxB,EAAKuhB,EAAMjvC,OAAQxD,EAAIkxB,EAAIlxB,GAAK,EAC9C6yC,GAAKH,EAAQD,EAAMzyC,GAAK0xC,EACxBoB,GAAKJ,EAAQD,EAAMzyC,EAAI,GAAK2xC,EAAUgB,OACrBjhC,IAAb+gC,EAAMzyC,IAIV4tB,EAAStlB,KAAKsqC,GACdA,EAAW,GACX5yC,KALE4yC,EAAStqC,KAAK,CAACuqC,GAAIC,KAUvB,OAHIF,EAASpvC,QACXoqB,EAAStlB,KAAKsqC,GAET,CAAChsB,QAAOC,SAAQ+G,YA0BzB,SAASmlB,EAAWjoC,EAASuwB,GAC3B,IAAI,QACFqW,EAAO,QAAEC,EAAO,MAAElK,EAAK,KAAEoK,EAAI,OAAEhrB,EAAM,MAAE+qB,EAAK,cAAEI,EAAa,YAAEF,EAAW,cAAEC,GACxEE,EAAannC,EAASuwB,IACrBj4B,EAAGC,GAAK,CAACquC,EAASC,IAClB3xC,EAAGkxB,EAAIohB,EAAMU,EAAMpsB,EAAOqsB,GAAQ,GACnCpuB,EAAO,CAAC+B,MAAO,EAAGgH,SAAU,IAC5BslB,EAAQ,GACR7lB,EAAS,GACT8lB,EAAW,EACXC,EAAYhwC,EAChB,MAAMiwC,EAAW,KACfH,EAAM5qC,KAAKuc,GACXsuB,EAAWlxC,KAAK4D,IAAIstC,EAAUtuB,EAAK+B,OACnC/B,EAAO,CAAC+B,MAAO,EAAGgH,SAAU,KAE9B,IAAK5tB,EAAI,EAAGkxB,EAAKuW,EAAMjkC,OAAQxD,EAAIkxB,EAAIlxB,IACrCsyC,EAAO7K,EAAMznC,GACbgzC,EAAOX,EAAW,CAACX,QAAStuC,EAAGuuC,QAAStuC,EAAGwuC,OAAMhrB,SAAQmrB,iBAAgBM,GAC5D,OAATA,GAMJ1rB,EAAQosB,EAAKpsB,MAAQmrB,EACrBltB,EAAK+B,OAASA,EACdxjB,GAAKwjB,EACQ,MAAT0rB,IACFztB,EAAK+I,SAAW/I,EAAK+I,SAASpP,OAAOw0B,EAAKplB,aAT1CxqB,EAAIgwC,EACJ/vC,GAAK2vC,EAAKnsB,OAASirB,EACnBuB,KAaJ,IAHIxuB,EAAK+I,SAASpqB,QAChB6vC,IAEGrzC,EAAI,EAAGkxB,EAAKgiB,EAAM1vC,OAAQxD,EAAIkxB,EAAIlxB,IACrC6kB,EAAOquB,EAAMlzC,GACTmzC,EAAWtuB,EAAK+B,QAClBqsB,EAAOE,EAAWtuB,EAAK+B,MACT,UAAVgrB,EACF/sB,EAAOqtB,EAAc,CAAC9uC,EAAG6vC,GAAOpuB,GACb,WAAV+sB,IACT/sB,EAAOqtB,EAAc,CAAC9uC,EAAG6vC,EAAO,GAAIpuB,KAGxCwI,EAASA,EAAO7O,OAAOqG,EAAK+I,UAE9B,OAAOP,EAiCT5tB,EAAOD,QAAU,CACf8zC,YApBF,SAAqBlwC,EAAGC,EAAGivC,GACzB,OAAOD,EAAW,CAACX,QAAStuC,EAAGuuC,QAAStuC,GAAIivC,IAoB5CiB,YANF,SAAqBnwC,EAAGC,EAAGg4B,GACzB,OAAO0X,EAAW,CAACrB,QAAStuC,EAAGuuC,QAAStuC,GAAIg4B,IAM5CgX,aACAU,e,cC3MFtzC,EAAOD,QAAU,CACfqnB,OAAQ,GACR2sB,GAAI,CAAC,IACLC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnDC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,CAAE,GAAI,GAAI,GAAI,IACrCC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,IAAK,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,CAAE,EAAG,EAAG,GAAI,GACvEC,GAAI,CAAC,GAAI,EAAG,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,IAAK,EAAG,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACrLC,GAAI,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,CAAE,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAC5NC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAC1PC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,IACtDC,GAAI,CAAC,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,GAC5EC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAC5EC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,CAAE,GAAI,GAAI,EAAG,IACpDC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,CAAE,EAAG,EAAG,GAAI,GACpCC,GAAI,CAAC,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GACzDC,GAAI,CAAC,GAAI,EAAG,EAAG,GAAI,GACnBC,GAAI,CAAC,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACpCC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GACrBC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,IAC5HC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GACnCC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAC9GC,GAAI,CAAC,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAChHC,GAAI,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GAC5CC,GAAI,CAAC,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC7HC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAC3KC,GAAI,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,IACpCC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,IAClNC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACxKC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzEC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAC9FC,GAAI,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAC3BC,GAAI,CAAC,GAAI,EAAG,GAAI,GAAI,GAAI,CAAE,EAAG,EAAG,GAAI,GACpCC,GAAI,CAAC,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAC1BC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAC/IC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GACjYC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,EAAG,CAAE,EAAG,EAAG,GAAI,GAClDC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,CAAE,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GACrKC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GACnIC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GAC7GC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,CAAE,EAAG,GAAI,GAAI,GAAI,CAAE,EAAG,EAAG,GAAI,GACpEC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,CAAE,EAAG,GAAI,GAAI,IACpDC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,GAAI,EAAG,GAAI,GAC1JC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,GAAI,EAAG,CAAE,EAAG,GAAI,GAAI,IACpDC,GAAI,CAAC,EAAG,EAAG,GAAI,EAAG,GAClBC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACvEC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GACnDC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,EAAG,GAAI,GAClCC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GACrEC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GACpDC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,IACxJC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,IAClGC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,CAAE,GAAI,EAAG,IAAK,GAC1KC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,CAAE,GAAI,GAAI,GAAI,GACpHC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnJC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,IACnCC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,IACzEC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,EAAG,GACnCC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GACrEC,GAAI,CAAC,GAAI,EAAG,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,EAAG,GACpCC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,EAAG,IAC1CC,GAAI,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,CAAE,EAAG,EAAG,GAAI,GACpDC,GAAI,CAAC,GAAI,EAAG,GAAI,GAAI,EAAG,CAAE,EAAG,GAAI,GAAI,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,CAAE,GAAI,EAAG,IAAK,GACtEC,GAAI,CAAC,GAAI,EAAG,GAAI,IAAK,GACrBC,GAAI,CAAC,GAAI,EAAG,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,IAAK,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,CAAE,GAAI,EAAG,IAAK,GACxEC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,CAAE,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,CAAE,EAAG,GAAI,EAAG,GACnEC,GAAI,CAAC,GAAI,GAAI,EAAG,IAAK,GACrBC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,IACtDC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GACvHC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACvHC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GACtGC,IAAK,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GACxHC,IAAK,CAAC,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAC5HC,IAAK,CAAC,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,EAAG,IACzDC,IAAK,CAAC,GAAI,GAAI,GAAI,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAC/JC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC1EC,IAAK,CAAC,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,CAAE,EAAG,GAAI,EAAG,GACxDC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,CAAE,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAC/EC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,EAAG,EAAG,CAAE,EAAG,EAAG,GAAI,GACnDC,IAAK,CAAC,EAAG,EAAG,GAAI,EAAG,GACnBC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GACnIC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC1EC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,IAC3HC,IAAK,CAAC,GAAI,EAAG,GAAI,GAAI,EAAG,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzHC,IAAK,CAAC,GAAI,GAAI,GAAI,IAAK,EAAG,CAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GACzHC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,IACxDC,IAAK,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC5HC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,CAAE,EAAG,GAAI,EAAG,IACtDC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GACtEC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,EAAG,GACpCC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GACtEC,IAAK,CAAC,GAAI,EAAG,GAAI,GAAI,EAAG,CAAE,GAAI,GAAI,EAAG,GACrCC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAChEC,IAAK,CAAC,GAAI,GAAI,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,CAAE,EAAG,EAAG,GAAI,GACrDC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GACnQC,IAAK,CAAC,EAAG,EAAG,GAAI,GAAI,GACpBC,IAAK,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,CAAE,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GACpQC,IAAK,CAAC,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,CAAE,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI","file":"main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"libcsg\"] = factory();\n\telse\n\t\troot[\"libcsg\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 35);\n","const _CSGDEBUG = false;\n\n/** Number of polygons per 360 degree revolution for 2D objects.\n * @default\n */\nconst defaultResolution2D = 32; // FIXME this seems excessive\n/** Number of polygons per 360 degree revolution for 3D objects.\n * @default\n */\nconst defaultResolution3D = 12;\n\n/** Epsilon used during determination of near zero distances.\n * @default\n */\nconst EPS = 1e-5;\n\n/** Epsilon used during determination of near zero areas.\n * @default\n */\nconst angleEPS = 0.10;\n\n/** Epsilon used during determination of near zero areas.\n *  This is the minimal area of a minimal polygon.\n * @default\n */\nconst areaEPS = 0.50 * EPS * EPS * Math.sin(angleEPS);\n\nconst all = 0;\nconst top = 1;\nconst bottom = 2;\nconst left = 3;\nconst right = 4;\nconst front = 5;\nconst back = 6;\n// Tag factory: we can request a unique tag through CSG.getTag()\nlet staticTag = 1;\nconst getTag = () => staticTag++;\n\nmodule.exports = {\n  _CSGDEBUG,\n  defaultResolution2D,\n  defaultResolution3D,\n  EPS,\n  angleEPS,\n  areaEPS,\n  all,\n  top,\n  bottom,\n  left,\n  right,\n  front,\n  back,\n  staticTag,\n  getTag\n};\n","const {IsFloat} = require('../utils');\nconst Vector2D = require('./Vector2');\n\n/** Class Vector3D\n * Represents a 3D vector with X, Y, Z coordinates.\n * @constructor\n *\n * @example\n * new CSG.Vector3D(1, 2, 3);\n * new CSG.Vector3D([1, 2, 3]);\n * new CSG.Vector3D({ x: 1, y: 2, z: 3 });\n * new CSG.Vector3D(1, 2); // assumes z=0\n * new CSG.Vector3D([1, 2]); // assumes z=0\n */\nconst Vector3D = function (x, y, z) {\n  if (arguments.length === 3) {\n    this._x = parseFloat(x);\n    this._y = parseFloat(y);\n    this._z = parseFloat(z);\n  } else if (arguments.length === 2) {\n    this._x = parseFloat(x);\n    this._y = parseFloat(y);\n    this._z = 0;\n  } else {\n    var ok = true;\n    if (arguments.length === 1) {\n      if (typeof (x) === 'object') {\n        if (x instanceof Vector3D) {\n          this._x = x._x;\n          this._y = x._y;\n          this._z = x._z;\n        } else if (x instanceof Vector2D) {\n          this._x = x._x;\n          this._y = x._y;\n          this._z = 0;\n        } else if (x instanceof Array) {\n          if ((x.length < 2) || (x.length > 3)) {\n            ok = false;\n          } else {\n            this._x = parseFloat(x[0]);\n            this._y = parseFloat(x[1]);\n            if (x.length === 3) {\n              this._z = parseFloat(x[2]);\n            } else {\n              this._z = 0;\n            }\n          }\n        } else if (('x' in x) && ('y' in x)) {\n          this._x = parseFloat(x.x);\n          this._y = parseFloat(x.y);\n          if ('z' in x) {\n            this._z = parseFloat(x.z);\n          } else {\n            this._z = 0;\n          }\n        } else if (('_x' in x) && ('_y' in x)) {\n          this._x = parseFloat(x._x);\n          this._y = parseFloat(x._y);\n          if ('_z' in x) {\n            this._z = parseFloat(x._z);\n          } else {\n            this._z = 0;\n          }\n        } else ok = false;\n      } else {\n        var v = parseFloat(x);\n        this._x = v;\n        this._y = v;\n        this._z = v;\n      }\n    } else ok = false;\n    if (ok) {\n      if ((!IsFloat(this._x)) || (!IsFloat(this._y)) || (!IsFloat(this._z))) ok = false;\n    } else {\n      throw new Error('wrong arguments');\n    }\n  }\n};\n\n// This does the same as new Vector3D(x,y,z) but it doesn't go through the constructor\n// and the parameters are not validated. Is much faster.\nVector3D.Create = function (x, y, z) {\n  var result = Object.create(Vector3D.prototype);\n  result._x = x;\n  result._y = y;\n  result._z = z;\n  return result;\n};\n\nVector3D.prototype = {\n  get x() {\n    return this._x;\n  },\n  get y() {\n    return this._y;\n  },\n  get z() {\n    return this._z;\n  },\n\n  set x(v) {\n    throw new Error('Vector3D is immutable');\n  },\n  set y(v) {\n    throw new Error('Vector3D is immutable');\n  },\n  set z(v) {\n    throw new Error('Vector3D is immutable');\n  },\n\n  clone: function () {\n    return Vector3D.Create(this._x, this._y, this._z);\n  },\n\n  negated: function () {\n    return Vector3D.Create(-this._x, -this._y, -this._z);\n  },\n\n  abs: function () {\n    return Vector3D.Create(Math.abs(this._x), Math.abs(this._y), Math.abs(this._z));\n  },\n\n  plus: function (a) {\n    return Vector3D.Create(this._x + a._x, this._y + a._y, this._z + a._z);\n  },\n\n  minus: function (a) {\n    return Vector3D.Create(this._x - a._x, this._y - a._y, this._z - a._z);\n  },\n\n  times: function (a) {\n    return Vector3D.Create(this._x * a, this._y * a, this._z * a);\n  },\n\n  dividedBy: function (a) {\n    return Vector3D.Create(this._x / a, this._y / a, this._z / a);\n  },\n\n  dot: function (a) {\n    return this._x * a._x + this._y * a._y + this._z * a._z;\n  },\n\n  lerp: function (a, t) {\n    return this.plus(a.minus(this).times(t));\n  },\n\n  lengthSquared: function () {\n    return this.dot(this);\n  },\n\n  length: function () {\n    return Math.sqrt(this.lengthSquared());\n  },\n\n  unit: function () {\n    return this.dividedBy(this.length());\n  },\n\n  cross: function (a) {\n    return Vector3D.Create(\n      this._y * a._z - this._z * a._y, this._z * a._x - this._x * a._z, this._x * a._y - this._y * a._x);\n  },\n\n  distanceTo: function (a) {\n    return this.minus(a).length();\n  },\n\n  distanceToSquared: function (a) {\n    return this.minus(a).lengthSquared();\n  },\n\n  equals: function (a) {\n    return (this._x === a._x) && (this._y === a._y) && (this._z === a._z);\n  },\n\n  // Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)\n  // Returns a new Vector3D\n  multiply4x4: function (matrix4x4) {\n    return matrix4x4.leftMultiply1x3Vector(this);\n  },\n\n  transform: function (matrix4x4) {\n    return matrix4x4.leftMultiply1x3Vector(this);\n  },\n\n  toString: function () {\n    return '(' + this._x.toFixed(5) + ', ' + this._y.toFixed(5) + ', ' + this._z.toFixed(5) + ')';\n  },\n\n  // find a vector that is somewhat perpendicular to this one\n  randomNonParallelVector: function () {\n    var abs = this.abs();\n    if ((abs._x <= abs._y) && (abs._x <= abs._z)) {\n      return Vector3D.Create(1, 0, 0);\n    } else if ((abs._y <= abs._x) && (abs._y <= abs._z)) {\n      return Vector3D.Create(0, 1, 0);\n    } else {\n      return Vector3D.Create(0, 0, 1);\n    }\n  },\n\n  min: function (p) {\n    return Vector3D.Create(\n      Math.min(this._x, p._x), Math.min(this._y, p._y), Math.min(this._z, p._z));\n  },\n\n  max: function (p) {\n    return Vector3D.Create(\n      Math.max(this._x, p._x), Math.max(this._y, p._y), Math.max(this._z, p._z));\n  }\n};\n\nmodule.exports = Vector3D;\n","const {IsFloat} = require('../utils');\n\n/** Class Vector2D\n * Represents a 2D vector with X, Y coordinates\n * @constructor\n *\n * @example\n * new CSG.Vector2D(1, 2);\n * new CSG.Vector2D([1, 2]);\n * new CSG.Vector2D({ x: 1, y: 2});\n */\nconst Vector2D = function (x, y) {\n  if (arguments.length === 2) {\n    this._x = parseFloat(x);\n    this._y = parseFloat(y);\n  } else {\n    var ok = true;\n    if (arguments.length === 1) {\n      if (typeof (x) === 'object') {\n        if (x instanceof Vector2D) {\n          this._x = x._x;\n          this._y = x._y;\n        } else if (x instanceof Array) {\n          this._x = parseFloat(x[0]);\n          this._y = parseFloat(x[1]);\n        } else if (('x' in x) && ('y' in x)) {\n          this._x = parseFloat(x.x);\n          this._y = parseFloat(x.y);\n        } else ok = false;\n      } else {\n        var v = parseFloat(x);\n        this._x = v;\n        this._y = v;\n      }\n    } else ok = false;\n    if (ok) {\n      if ((!IsFloat(this._x)) || (!IsFloat(this._y))) ok = false;\n    }\n    if (!ok) {\n      throw new Error('wrong arguments');\n    }\n  }\n};\n\nVector2D.fromAngle = function (radians) {\n  return Vector2D.fromAngleRadians(radians);\n};\n\nVector2D.fromAngleDegrees = function (degrees) {\n  var radians = Math.PI * degrees / 180;\n  return Vector2D.fromAngleRadians(radians);\n};\n\nVector2D.fromAngleRadians = function (radians) {\n  return Vector2D.Create(Math.cos(radians), Math.sin(radians));\n};\n\n// This does the same as new Vector2D(x,y) but it doesn't go through the constructor\n// and the parameters are not validated. Is much faster.\nVector2D.Create = function (x, y) {\n  var result = Object.create(Vector2D.prototype);\n  result._x = x;\n  result._y = y;\n  return result;\n};\n\nVector2D.prototype = {\n  get x() {\n    return this._x;\n  },\n  get y() {\n    return this._y;\n  },\n\n  set x(v) {\n    throw new Error('Vector2D is immutable');\n  },\n  set y(v) {\n    throw new Error('Vector2D is immutable');\n  },\n\n  // extend to a 3D vector by adding a z coordinate:\n  toVector3D: function (z) {\n    const Vector3D = require('./Vector3'); // FIXME: circular dependencies Vector2 => Vector3 => Vector2\n    return new Vector3D(this._x, this._y, z);\n  },\n\n  equals: function (a) {\n    return (this._x === a._x) && (this._y === a._y);\n  },\n\n  clone: function () {\n    return Vector2D.Create(this._x, this._y);\n  },\n\n  negated: function () {\n    return Vector2D.Create(-this._x, -this._y);\n  },\n\n  plus: function (a) {\n    return Vector2D.Create(this._x + a._x, this._y + a._y);\n  },\n\n  minus: function (a) {\n    return Vector2D.Create(this._x - a._x, this._y - a._y);\n  },\n\n  times: function (a) {\n    return Vector2D.Create(this._x * a, this._y * a);\n  },\n\n  dividedBy: function (a) {\n    return Vector2D.Create(this._x / a, this._y / a);\n  },\n\n  dot: function (a) {\n    return this._x * a._x + this._y * a._y;\n  },\n\n  lerp: function (a, t) {\n    return this.plus(a.minus(this).times(t));\n  },\n\n  length: function () {\n    return Math.sqrt(this.dot(this));\n  },\n\n  distanceTo: function (a) {\n    return this.minus(a).length();\n  },\n\n  distanceToSquared: function (a) {\n    return this.minus(a).lengthSquared();\n  },\n\n  lengthSquared: function () {\n    return this.dot(this);\n  },\n\n  unit: function () {\n    return this.dividedBy(this.length());\n  },\n\n  cross: function (a) {\n    return this._x * a._y - this._y * a._x;\n  },\n\n  // returns the vector rotated by 90 degrees clockwise\n  normal: function () {\n    return Vector2D.Create(this._y, -this._x);\n  },\n\n  // Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)\n  // Returns a new Vector2D\n  multiply4x4: function (matrix4x4) {\n    return matrix4x4.leftMultiply1x2Vector(this);\n  },\n\n  transform: function (matrix4x4) {\n    return matrix4x4.leftMultiply1x2Vector(this);\n  },\n\n  angle: function () {\n    return this.angleRadians();\n  },\n\n  angleDegrees: function () {\n    var radians = this.angleRadians();\n    return 180 * radians / Math.PI;\n  },\n\n  angleRadians: function () {\n    // y=sin, x=cos\n    return Math.atan2(this._y, this._x);\n  },\n\n  min: function (p) {\n    return Vector2D.Create(\n      Math.min(this._x, p._x), Math.min(this._y, p._y));\n  },\n\n  max: function (p) {\n    return Vector2D.Create(\n      Math.max(this._x, p._x), Math.max(this._y, p._y));\n  },\n\n  toString: function () {\n    return '(' + this._x.toFixed(5) + ', ' + this._y.toFixed(5) + ')';\n  },\n\n  abs: function () {\n    return Vector2D.Create(Math.abs(this._x), Math.abs(this._y));\n  }\n};\n\nmodule.exports = Vector2D;\n","const Vector2D = require('./Vector2');\nconst Vector3D = require('./Vector3');\nconst Vertex = require('./Vertex3');\nconst Matrix4x4 = require('./Matrix4');\nconst {_CSGDEBUG, EPS, getTag, areaEPS} = require('../constants');\n\n/** Class Polygon\n * Represents a convex polygon. The vertices used to initialize a polygon must\n *   be coplanar and form a convex loop. They do not have to be `Vertex`\n *   instances but they must behave similarly (duck typing can be used for\n *   customization).\n * <br>\n * Each convex polygon has a `shared` property, which is shared between all\n *   polygons that are clones of each other or were split from the same polygon.\n *   This can be used to define per-polygon properties (such as surface color).\n * <br>\n * The plane of the polygon is calculated from the vertex coordinates if not provided.\n *   The plane can alternatively be passed as the third argument to avoid calculations.\n *\n * @constructor\n * @param {Vertex[]} vertices - list of vertices\n * @param {Polygon.Shared} [shared=defaultShared] - shared property to apply\n * @param {Plane} [plane] - plane of the polygon\n *\n * @example\n * const vertices = [\n *   new CSG.Vertex(new CSG.Vector3D([0, 0, 0])),\n *   new CSG.Vertex(new CSG.Vector3D([0, 10, 0])),\n *   new CSG.Vertex(new CSG.Vector3D([0, 10, 10]))\n * ]\n * let observed = new Polygon(vertices)\n */\nlet Polygon = function (vertices, shared, plane) {\n  this.vertices = vertices;\n  if (!shared) shared = Polygon.defaultShared;\n  this.shared = shared;\n  // let numvertices = vertices.length;\n\n  if (arguments.length >= 3) {\n    this.plane = plane;\n  } else {\n    const Plane = require('./Plane'); // FIXME: circular dependencies\n    this.plane = Plane.fromVector3Ds(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n  }\n\n  if (_CSGDEBUG) {\n    if (!this.checkIfConvex()) {\n      throw new Error('Not convex!');\n    }\n  }\n};\n\nPolygon.prototype = {\n  /** Check whether the polygon is convex. (it should be, otherwise we will get unexpected results)\n   * @returns {boolean}\n   */\n  checkIfConvex: function () {\n    return Polygon.verticesConvex(this.vertices, this.plane.normal);\n  },\n\n  // FIXME what? why does this return this, and not a new polygon?\n  // FIXME is this used?\n  setColor: function (args) {\n    let newshared = Polygon.Shared.fromColor.apply(this, arguments);\n    this.shared = newshared;\n    return this;\n  },\n\n  getSignedVolume: function () {\n    let signedVolume = 0;\n    for (let i = 0; i < this.vertices.length - 2; i++) {\n      signedVolume += this.vertices[0].pos.dot(this.vertices[i + 1].pos\n        .cross(this.vertices[i + 2].pos));\n    }\n    signedVolume /= 6;\n    return signedVolume;\n  },\n\n  // Note: could calculate vectors only once to speed up\n  getArea: function () {\n    let polygonArea = 0;\n    for (let i = 0; i < this.vertices.length - 2; i++) {\n      polygonArea += this.vertices[i + 1].pos.minus(this.vertices[0].pos)\n        .cross(this.vertices[i + 2].pos.minus(this.vertices[i + 1].pos)).length();\n    }\n    polygonArea /= 2;\n    return polygonArea;\n  },\n\n  // accepts array of features to calculate\n  // returns array of results\n  getTetraFeatures: function (features) {\n    let result = [];\n    features.forEach(function (feature) {\n      if (feature === 'volume') {\n        result.push(this.getSignedVolume());\n      } else if (feature === 'area') {\n        result.push(this.getArea());\n      }\n    }, this);\n    return result;\n  },\n\n  // Extrude a polygon into the direction offsetvector\n  // Returns a CSG object\n  extrude: function (offsetvector) {\n    const {fromPolygons} = require('../CSGFactories'); // because of circular dependencies\n\n    let newpolygons = [];\n\n    let polygon1 = this;\n    let direction = polygon1.plane.normal.dot(offsetvector);\n    if (direction > 0) {\n      polygon1 = polygon1.flipped();\n    }\n    newpolygons.push(polygon1);\n    let polygon2 = polygon1.translate(offsetvector);\n    let numvertices = this.vertices.length;\n    let x = 0;\n    let y = offsetvector.length();\n    for (let i = 0; i < numvertices; i++) {\n      let sidefacepoints = [];\n      let nexti = (i < (numvertices - 1)) ? i + 1 : 0;\n      let xn = x + polygon1.vertices[i].pos.distanceTo(polygon1.vertices[nexti].pos);\n      sidefacepoints.push(Vertex.fromPosAndUV(polygon1.vertices[i].pos, new Vector2D(x, 0)));\n      sidefacepoints.push(Vertex.fromPosAndUV(polygon2.vertices[i].pos, new Vector2D(x, y)));\n      sidefacepoints.push(Vertex.fromPosAndUV(polygon2.vertices[nexti].pos, new Vector2D(xn, y)));\n      sidefacepoints.push(Vertex.fromPosAndUV(polygon1.vertices[nexti].pos, new Vector2D(xn, 0)));\n      let sidefacepolygon = new Polygon(sidefacepoints, this.shared);\n      newpolygons.push(sidefacepolygon);\n      x = xn;\n    }\n    polygon2 = polygon2.flipped();\n    newpolygons.push(polygon2);\n    return fromPolygons(newpolygons);\n  },\n\n  translate: function (offset) {\n    return this.transform(Matrix4x4.translation(offset));\n  },\n\n  // returns an array with a Vector3D (center point) and a radius\n  boundingSphere: function () {\n    if (!this.cachedBoundingSphere) {\n      let box = this.boundingBox();\n      let middle = box[0].plus(box[1]).times(0.5);\n      let radius3 = box[1].minus(middle);\n      let radius = radius3.length();\n      this.cachedBoundingSphere = [middle, radius];\n    }\n    return this.cachedBoundingSphere;\n  },\n\n  // returns an array of two Vector3Ds (minimum coordinates and maximum coordinates)\n  boundingBox: function () {\n    if (!this.cachedBoundingBox) {\n      let minpoint, maxpoint;\n      let vertices = this.vertices;\n      let numvertices = vertices.length;\n      if (numvertices === 0) {\n        minpoint = new Vector3D(0, 0, 0);\n      } else {\n        minpoint = vertices[0].pos;\n      }\n      maxpoint = minpoint;\n      for (let i = 1; i < numvertices; i++) {\n        let point = vertices[i].pos;\n        minpoint = minpoint.min(point);\n        maxpoint = maxpoint.max(point);\n      }\n      this.cachedBoundingBox = [minpoint, maxpoint];\n    }\n    return this.cachedBoundingBox;\n  },\n\n  flipped: function () {\n    let newvertices = this.vertices.map(function (v) {\n      return v.flipped();\n    });\n    newvertices.reverse();\n    let newplane = this.plane.flipped();\n    return new Polygon(newvertices, this.shared, newplane);\n  },\n\n  // Affine transformation of polygon. Returns a new Polygon\n  transform: function (matrix4x4) {\n    let newvertices = this.vertices.map(function (v) {\n      return v.transform(matrix4x4);\n    });\n    let newplane = this.plane.transform(matrix4x4);\n    if (matrix4x4.isMirroring()) {\n      // need to reverse the vertex order\n      // in order to preserve the inside/outside orientation:\n      newvertices.reverse();\n    }\n    return new Polygon(newvertices, this.shared, newplane);\n  },\n\n  toString: function () {\n    let result = 'Polygon plane: ' + this.plane.toString() + '\\n';\n    this.vertices.map(function (vertex) {\n      result += '  ' + vertex.toString() + '\\n';\n    });\n    return result;\n  },\n\n  // project the 3D polygon onto a plane\n  projectToOrthoNormalBasis: function (orthobasis) {\n    const CAG = require('../CAG');\n    const {fromPointsNoCheck} = require('../CAGFactories'); // circular dependencies\n    let points2d = this.vertices.map(function (vertex) {\n      return orthobasis.to2D(vertex.pos);\n    });\n\n    let result = fromPointsNoCheck(points2d);\n    let area = result.area();\n    if (Math.abs(area) < areaEPS) {\n      // the polygon was perpendicular to the orthnormal plane. The resulting 2D polygon would be degenerate\n      // return an empty area instead:\n      result = new CAG();\n    } else if (area < 0) {\n      result = result.flipped();\n    }\n    return result;\n  },\n\n  // ALIAS ONLY!!\n  solidFromSlices: function (options) {\n    const solidFromSlices = require('../../api/solidFromSlices');\n    return solidFromSlices(this, options);\n  }\n\n};\n\n// create from an untyped object with identical property names:\nPolygon.fromObject = function (obj) {\n  const Plane = require('./Plane'); // FIXME: circular dependencies\n  let vertices = obj.vertices.map(function (v) {\n    return Vertex.fromObject(v);\n  });\n  let shared = Polygon.Shared.fromObject(obj.shared);\n  let plane = Plane.fromObject(obj.plane);\n  return new Polygon(vertices, shared, plane);\n};\n\n/** Create a polygon from the given points.\n *\n * @param {Array[]} points - list of points\n * @param {Polygon.Shared} [shared=defaultShared] - shared property to apply\n * @param {Plane} [plane] - plane of the polygon\n *\n * @example\n * const points = [\n *   [0,  0, 0],\n *   [0, 10, 0],\n *   [0, 10, 10]\n * ]\n * let observed = CSG.Polygon.createFromPoints(points)\n */\nPolygon.createFromPoints = function (points, shared, plane) {\n  // FIXME : this circular dependency does not work !\n  // const {fromPoints} = require('./polygon3Factories')\n  // return fromPoints(points, shared, plane)\n  let vertices = [];\n  points.map(function (p) {\n    let vec = new Vector3D(p);\n    let vertex = new Vertex(vec);\n    vertices.push(vertex);\n  });\n  let polygon;\n  if (arguments.length < 3) {\n    polygon = new Polygon(vertices, shared);\n  } else {\n    polygon = new Polygon(vertices, shared, plane);\n  }\n  return polygon;\n};\n\nPolygon.verticesConvex = function (vertices, planenormal) {\n  let numvertices = vertices.length;\n  if (numvertices > 2) {\n    let prevprevpos = vertices[numvertices - 2].pos;\n    let prevpos = vertices[numvertices - 1].pos;\n    for (let i = 0; i < numvertices; i++) {\n      let pos = vertices[i].pos;\n      if (!Polygon.isConvexPoint(prevprevpos, prevpos, pos, planenormal)) {\n        return false;\n      }\n      prevprevpos = prevpos;\n      prevpos = pos;\n    }\n  }\n  return true;\n};\n\n// calculate whether three points form a convex corner\n//  prevpoint, point, nextpoint: the 3 coordinates (Vector3D instances)\n//  normal: the normal vector of the plane\nPolygon.isConvexPoint = function (prevpoint, point, nextpoint, normal) {\n  let crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));\n  let crossdotnormal = crossproduct.dot(normal);\n  return (crossdotnormal >= 0);\n};\n\nPolygon.isStrictlyConvexPoint = function (prevpoint, point, nextpoint, normal) {\n  let crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));\n  let crossdotnormal = crossproduct.dot(normal);\n  return (crossdotnormal >= EPS);\n};\n\n/** Class Polygon.Shared\n * Holds the shared properties for each polygon (Currently only color).\n * @constructor\n * @param {Array[]} color - array containing RGBA values, or null\n *\n * @example\n *   let shared = new CSG.Polygon.Shared([0, 0, 0, 1])\n */\nPolygon.Shared = function (color) {\n  if (color !== null && color !== undefined) {\n    if (color.length !== 4) {\n      throw new Error('Expecting 4 element array');\n    }\n  }\n  this.color = color;\n};\n\nPolygon.Shared.fromObject = function (obj) {\n  return new Polygon.Shared(obj.color);\n};\n\n/** Create Polygon.Shared from color values.\n * @param {number} r - value of RED component\n * @param {number} g - value of GREEN component\n * @param {number} b - value of BLUE component\n * @param {number} [a] - value of ALPHA component\n * @param {Array[]} [color] - OR array containing RGB values (optional Alpha)\n *\n * @example\n * let s1 = Polygon.Shared.fromColor(0,0,0)\n * let s2 = Polygon.Shared.fromColor([0,0,0,1])\n */\nPolygon.Shared.fromColor = function (args) {\n  let color;\n  if (arguments.length === 1) {\n    color = arguments[0].slice(); // make deep copy\n  } else {\n    color = [];\n    for (let i = 0; i < arguments.length; i++) {\n      color.push(arguments[i]);\n    }\n  }\n  if (color.length === 3) {\n    color.push(1);\n  } else if (color.length !== 4) {\n    throw new Error('setColor expects either an array with 3 or 4 elements, or 3 or 4 parameters.');\n  }\n  return new Polygon.Shared(color);\n};\n\nPolygon.Shared.prototype = {\n  getTag: function () {\n    let result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  },\n  // get a string uniquely identifying this object\n  getHash: function () {\n    if (!this.color) return 'null';\n    return this.color.join('/');\n  }\n};\n\nPolygon.defaultShared = new Polygon.Shared(null);\n\nmodule.exports = Polygon;\n","function fnNumberSort(a, b) {\n  return a - b;\n}\n\nfunction fnSortByIndex(a, b) {\n  return a.index - b.index;\n}\n\nconst IsFloat = function (n) {\n  return (!isNaN(n)) || (n === Infinity) || (n === -Infinity);\n};\n\nconst solve2Linear = function (a, b, c, d, u, v) {\n  let det = a * d - b * c;\n  let invdet = 1.0 / det;\n  let x = u * d - b * v;\n  let y = -u * c + a * v;\n  x *= invdet;\n  y *= invdet;\n  return [x, y];\n};\n\nfunction insertSorted(array, element, comparefunc) {\n  let leftbound = 0;\n  let rightbound = array.length;\n  while (rightbound > leftbound) {\n    let testindex = Math.floor((leftbound + rightbound) / 2);\n    let testelement = array[testindex];\n    let compareresult = comparefunc(element, testelement);\n    if (compareresult > 0) // element > testelement\n    {\n      leftbound = testindex + 1;\n    } else {\n      rightbound = testindex;\n    }\n  }\n  array.splice(leftbound, 0, element);\n}\n\n// Get the x coordinate of a point with a certain y coordinate, interpolated between two\n// points (CSG.Vector2D).\n// Interpolation is robust even if the points have the same y coordinate\nconst interpolateBetween2DPointsForY = function (point1, point2, y) {\n  let f1 = y - point1.y;\n  let f2 = point2.y - point1.y;\n  if (f2 < 0) {\n    f1 = -f1;\n    f2 = -f2;\n  }\n  let t;\n  if (f1 <= 0) {\n    t = 0.0;\n  } else if (f1 >= f2) {\n    t = 1.0;\n  } else if (f2 < 1e-10) { // FIXME Should this be CSG.EPS?\n    t = 0.5;\n  } else {\n    t = f1 / f2;\n  }\n  let result = point1.x + t * (point2.x - point1.x);\n  return result;\n};\n\nfunction isCAG(object) {\n  // objects[i] instanceof CAG => NOT RELIABLE\n  // 'instanceof' causes huge issues when using objects from\n  // two different versions of CSG.js as they are not reckonized as one and the same\n  // so DO NOT use instanceof to detect matching types for CSG/CAG\n  if (!('sides' in object)) {\n    return false;\n  }\n  if (!('length' in object.sides)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isCSG(object) {\n  // objects[i] instanceof CSG => NOT RELIABLE\n  // 'instanceof' causes huge issues when using objects from\n  // two different versions of CSG.js as they are not reckonized as one and the same\n  // so DO NOT use instanceof to detect matching types for CSG/CAG\n  if (!('polygons' in object)) {\n    return false;\n  }\n  if (!('length' in object.polygons)) {\n    return false;\n  }\n  return true;\n}\n\nmodule.exports = {\n  fnNumberSort,\n  fnSortByIndex,\n  IsFloat,\n  solve2Linear,\n  insertSorted,\n  interpolateBetween2DPointsForY,\n  isCAG,\n  isCSG\n};\n","const Vector3D = require('./Vector3');\nconst Line3D = require('./Line3');\nconst {EPS, getTag} = require('../constants');\n\n// # class Plane\n// Represents a plane in 3D space.\nconst Plane = function (normal, w) {\n  this.normal = normal;\n  this.w = w;\n};\n\n// create from an untyped object with identical property names:\nPlane.fromObject = function (obj) {\n  let normal = new Vector3D(obj.normal);\n  let w = parseFloat(obj.w);\n  return new Plane(normal, w);\n};\n\nPlane.fromVector3Ds = function (a, b, c) {\n  let n = b.minus(a).cross(c.minus(a)).unit();\n  return new Plane(n, n.dot(a));\n};\n\n// like fromVector3Ds, but allow the vectors to be on one point or one line\n// in such a case a random plane through the given points is constructed\nPlane.anyPlaneFromVector3Ds = function (a, b, c) {\n  let v1 = b.minus(a);\n  let v2 = c.minus(a);\n  if (v1.length() < EPS) {\n    v1 = v2.randomNonParallelVector();\n  }\n  if (v2.length() < EPS) {\n    v2 = v1.randomNonParallelVector();\n  }\n  let normal = v1.cross(v2);\n  if (normal.length() < EPS) {\n    // this would mean that v1 == v2.negated()\n    v2 = v1.randomNonParallelVector();\n    normal = v1.cross(v2);\n  }\n  normal = normal.unit();\n  return new Plane(normal, normal.dot(a));\n};\n\nPlane.fromPoints = function (a, b, c) {\n  a = new Vector3D(a);\n  b = new Vector3D(b);\n  c = new Vector3D(c);\n  return Plane.fromVector3Ds(a, b, c);\n};\n\nPlane.fromNormalAndPoint = function (normal, point) {\n  normal = new Vector3D(normal);\n  point = new Vector3D(point);\n  normal = normal.unit();\n  let w = point.dot(normal);\n  return new Plane(normal, w);\n};\n\nPlane.prototype = {\n  flipped: function () {\n    return new Plane(this.normal.negated(), -this.w);\n  },\n\n  getTag: function () {\n    let result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  },\n\n  equals: function (n) {\n    return this.normal.equals(n.normal) && this.w === n.w;\n  },\n\n  transform: function (matrix4x4) {\n    let ismirror = matrix4x4.isMirroring();\n    // get two vectors in the plane:\n    let r = this.normal.randomNonParallelVector();\n    let u = this.normal.cross(r);\n    let v = this.normal.cross(u);\n    // get 3 points in the plane:\n    let point1 = this.normal.times(this.w);\n    let point2 = point1.plus(u);\n    let point3 = point1.plus(v);\n    // transform the points:\n    point1 = point1.multiply4x4(matrix4x4);\n    point2 = point2.multiply4x4(matrix4x4);\n    point3 = point3.multiply4x4(matrix4x4);\n    // and create a new plane from the transformed points:\n    let newplane = Plane.fromVector3Ds(point1, point2, point3);\n    if (ismirror) {\n      // the transform is mirroring\n      // We should mirror the plane:\n      newplane = newplane.flipped();\n    }\n    return newplane;\n  },\n\n  // robust splitting of a line by a plane\n  // will work even if the line is parallel to the plane\n  splitLineBetweenPoints: function (p1, p2) {\n    let direction = p2.minus(p1);\n    let labda = (this.w - this.normal.dot(p1)) / this.normal.dot(direction);\n    if (isNaN(labda)) labda = 0;\n    if (labda > 1) labda = 1;\n    if (labda < 0) labda = 0;\n    let result = p1.plus(direction.times(labda));\n    return result;\n  },\n\n  // returns Vector3D\n  intersectWithLine: function (line3d) {\n    return line3d.intersectWithPlane(this);\n  },\n\n  // intersection of two planes\n  intersectWithPlane: function (plane) {\n    return Line3D.fromPlanes(this, plane);\n  },\n\n  signedDistanceToPoint: function (point) {\n    let t = this.normal.dot(point) - this.w;\n    return t;\n  },\n\n  toString: function () {\n    return '[normal: ' + this.normal.toString() + ', w: ' + this.w + ']';\n  },\n\n  mirrorPoint: function (point3d) {\n    let distance = this.signedDistanceToPoint(point3d);\n    let mirrored = point3d.minus(this.normal.times(distance * 2.0));\n    return mirrored;\n  }\n};\n\nmodule.exports = Plane;\n","const Vector3D = require('./Vector3');\nconst Vector2D = require('./Vector2');\nconst {getTag} = require('../constants');\n\n// # class Vertex\n// Represents a vertex of a polygon. Use your own vertex class instead of this\n// one to provide additional features like texture coordinates and vertex\n// colors. Custom vertex classes need to provide a `pos` property\n// `flipped()`, and `interpolate()` methods that behave analogous to the ones\n// FIXME: And a lot MORE (see plane.fromVector3Ds for ex) ! This is fragile code\n// defined by `Vertex`.\nconst Vertex = function (pos) {\n  this.pos = pos;\n  this.uv = new Vector2D(0, 0);\n};\n\n// create from an untyped object with identical property names:\nVertex.fromObject = function (obj) {\n  var pos = new Vector3D(obj.pos);\n  return new Vertex(pos);\n};\n\n// create with position and uv coordinates\nVertex.fromPosAndUV = function (pos, uv) {\n  var newVertex = new Vertex(pos);\n  newVertex.uv = uv;\n  return newVertex;\n};\n\nVertex.prototype = {\n  // Return a vertex with all orientation-specific data (e.g. vertex normal) flipped. Called when the\n  // orientation of a polygon is flipped.\n  flipped: function () {\n    return this;\n  },\n\n  getTag: function () {\n    var result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  },\n\n  // Create a new vertex between this vertex and `other` by linearly\n  // interpolating all properties using a parameter of `t`. Subclasses should\n  // override this to interpolate additional properties.\n  interpolate: function (other, t) {\n    var newpos = this.pos.lerp(other.pos, t);\n    var newUv = this.uv.lerp(other.uv, t);\n    return Vertex.fromPosAndUV(newpos, newUv);\n  },\n\n  // Affine transformation of vertex. Returns a new Vertex\n  transform: function (matrix4x4) {\n    var newpos = this.pos.multiply4x4(matrix4x4);\n    return Vertex.fromPosAndUV(newpos, this.uv);\n  },\n\n  toString: function () {\n    return this.pos.toString();\n  }\n};\n\nmodule.exports = Vertex;\n","const Vector3D = require('./math/Vector3');\nconst Vertex = require('./math/Vertex3');\nconst Plane = require('./math/Plane');\nconst Polygon2D = require('./math/Polygon2');\nconst Polygon3D = require('./math/Polygon3');\n\n/** Construct a CSG solid from a list of `Polygon` instances.\n * @param {Polygon[]} polygons - list of polygons\n * @returns {CSG} new CSG object\n */\nconst fromPolygons = function (polygons) {\n  const CSG = require('./CSG');\n  let csg = new CSG();\n  csg.polygons = polygons;\n  csg.isCanonicalized = false;\n  csg.isRetesselated = false;\n  return csg;\n};\n\n/** Construct a CSG solid from a list of pre-generated slices.\n * See Polygon.prototype.solidFromSlices() for details.\n * @param {Object} options - options passed to solidFromSlices()\n * @returns {CSG} new CSG object\n */\nfunction fromSlices(options) {\n  return Polygon2D.createFromPoints([\n    [0, 0, 0],\n    [1, 0, 0],\n    [1, 1, 0],\n    [0, 1, 0]\n  ]).solidFromSlices(options);\n}\n\n/** Reconstruct a CSG solid from an object with identical property names.\n * @param {Object} obj - anonymous object, typically from JSON\n * @returns {CSG} new CSG object\n */\nfunction fromObject(obj) {\n  let polygons = obj.polygons.map(function (p) {\n    return Polygon3D.fromObject(p);\n  });\n  let csg = fromPolygons(polygons);\n  csg.isCanonicalized = obj.isCanonicalized;\n  csg.isRetesselated = obj.isRetesselated;\n  return csg;\n}\n\n/** Reconstruct a CSG from the output of toCompactBinary().\n * @param {CompactBinary} bin - see toCompactBinary().\n * @returns {CSG} new CSG object\n */\nfunction fromCompactBinary(bin) {\n  if (bin['class'] !== 'CSG') throw new Error('Not a CSG');\n  let planes = [];\n  let planeData = bin.planeData;\n  let numplanes = planeData.length / 4;\n  let arrayindex = 0;\n  let x, y, z, w, normal, plane;\n  for (let planeindex = 0; planeindex < numplanes; planeindex++) {\n    x = planeData[arrayindex++];\n    y = planeData[arrayindex++];\n    z = planeData[arrayindex++];\n    w = planeData[arrayindex++];\n    normal = Vector3D.Create(x, y, z);\n    plane = new Plane(normal, w);\n    planes.push(plane);\n  }\n\n  let vertices = [];\n  const vertexData = bin.vertexData;\n  const numvertices = vertexData.length / 3;\n  let pos;\n  let vertex;\n  arrayindex = 0;\n  for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n    x = vertexData[arrayindex++];\n    y = vertexData[arrayindex++];\n    z = vertexData[arrayindex++];\n    pos = Vector3D.Create(x, y, z);\n    vertex = new Vertex(pos);\n    vertices.push(vertex);\n  }\n\n  let shareds = bin.shared.map(function (shared) {\n    return Polygon3D.Shared.fromObject(shared);\n  });\n\n  let polygons = [];\n  let numpolygons = bin.numPolygons;\n  let numVerticesPerPolygon = bin.numVerticesPerPolygon;\n  let polygonVertices = bin.polygonVertices;\n  let polygonPlaneIndexes = bin.polygonPlaneIndexes;\n  let polygonSharedIndexes = bin.polygonSharedIndexes;\n  let numpolygonvertices;\n  let polygonvertices;\n  let shared;\n  let polygon; // already defined plane,\n  arrayindex = 0;\n  for (let polygonindex = 0; polygonindex < numpolygons; polygonindex++) {\n    numpolygonvertices = numVerticesPerPolygon[polygonindex];\n    polygonvertices = [];\n    for (let i = 0; i < numpolygonvertices; i++) {\n      polygonvertices.push(vertices[polygonVertices[arrayindex++]]);\n    }\n    plane = planes[polygonPlaneIndexes[polygonindex]];\n    shared = shareds[polygonSharedIndexes[polygonindex]];\n    polygon = new Polygon3D(polygonvertices, shared, plane);\n    polygons.push(polygon);\n  }\n  let csg = fromPolygons(polygons);\n  csg.isCanonicalized = true;\n  csg.isRetesselated = true;\n  return csg;\n}\n\nmodule.exports = {\n  fromPolygons,\n  fromSlices,\n  fromObject,\n  fromCompactBinary\n};\n","const Side = require('./math/Side');\nconst Vector2D = require('./math/Vector2');\nconst Vertex2 = require('./math/Vertex2');\nconst {areaEPS} = require('./constants');\nconst {isSelfIntersecting, contains} = require('./utils/cagValidation');\nconst {union, difference} = require('../modifiers/boolean');\n\n/** Construct a CAG from a list of `Side` instances.\n * @param {Side[]} sides - list of sides\n * @returns {CAG} new CAG object\n */\nconst fromSides = function (sides) {\n  const CAG = require('./CAG'); // circular dependency CAG => fromSides => CAG\n  let cag = new CAG();\n  cag.sides = sides;\n  return cag;\n};\n\n// Converts a CSG to a  The CSG must consist of polygons with only z coordinates +1 and -1\n// as constructed by _toCSGWall(-1, 1). This is so we can use the 3D union(), intersect() etc\nconst fromFakeCSG = function (csg) {\n  let sides = csg.polygons.map(function (p) {\n    return Side._fromFakePolygon(p);\n  })\n    .filter(function (s) {\n      return s !== null;\n    });\n  return fromSides(sides);\n};\n\n/** Construct a CAG from a list of points (a polygon) or an nested array of points.\n * The rotation direction of the points is not relevant.\n * The points can define a convex or a concave polygon.\n * The polygon must not self intersect.\n * Hole detection follows the even/odd rule,\n * which means that the order of the paths is not important.\n * @param {points[]|Array.<points[]>} points - (nested) list of points in 2D space\n * @returns {CAG} new CAG object\n */\nconst fromPoints = function (points) {\n  if (!points) {\n    throw new Error('points parameter must be defined');\n  }\n  if (!Array.isArray(points)) {\n    throw new Error('points parameter must be an array');\n  }\n  if (points[0].x !== undefined || typeof points[0][0] === 'number') {\n    return fromPointsArray(points);\n  }\n  if (typeof points[0][0] === 'object') {\n    return fromNestedPointsArray(points);\n  }\n  throw new Error('Unsupported points list format');\n};\n\n// Do not export the two following function (code splitting for fromPoints())\nconst fromPointsArray = function (points) {\n  if (points.length < 3) {\n    throw new Error('CAG shape needs at least 3 points');\n  }\n  let sides = [];\n  let prevvertex = new Vertex2(new Vector2D(points[points.length - 1]));\n  points.map(function (point) {\n    let vertex = new Vertex2(new Vector2D(point));\n    sides.push(new Side(prevvertex, vertex));\n    prevvertex = vertex;\n  });\n  let result = fromSides(sides);\n  if (isSelfIntersecting(result)) {\n    throw new Error('Polygon is self intersecting!');\n  }\n  let area = result.area();\n  if (Math.abs(area) < areaEPS) {\n    throw new Error('Degenerate polygon!');\n  }\n  if (area < 0) {\n    result = result.flipped();\n  }\n  return result.canonicalized();\n};\n\nconst fromNestedPointsArray = function (points) {\n  if (points.length === 1) {\n    return fromPoints(points[0]);\n  }\n  // First pass: create a collection of CAG paths\n  let paths = [];\n  points.forEach(path => {\n    paths.push(fromPointsArray(path));\n  });\n  // Second pass: make a tree of paths\n  let tree = {};\n  // for each polygon extract parents and childs polygons\n  paths.forEach((p1, i) => {\n    // check for intersection\n    paths.forEach((p2, y) => {\n      if (p1 !== p2) {\n        // create default node\n        tree[i] || (tree[i] = {parents: [], isHole: false});\n        tree[y] || (tree[y] = {parents: [], isHole: false});\n        // check if polygon2 stay in poylgon1\n        if (contains(p2, p1)) {\n          // push parent and child; odd parents number ==> hole\n          tree[i].parents.push(y);\n          tree[i].isHole = !!(tree[i].parents.length % 2);\n          tree[y].isHole = !!(tree[y].parents.length % 2);\n        }\n      }\n    });\n  });\n  // Third pass: subtract holes\n  let path = null;\n  for (key in tree) {\n    path = tree[key];\n    if (path.isHole) {\n      delete tree[key]; // remove holes for final pass\n      path.parents.forEach(parentKey => {\n        paths[parentKey] = difference(paths[parentKey], paths[key]);\n      });\n    }\n  }\n  // Fourth and last pass: create final CAG object\n  let cag = fromSides([]);\n  for (key in tree) {\n    cag = union(cag, paths[key]);\n  }\n  return cag;\n};\n\n/** Reconstruct a CAG from an object with identical property names.\n * @param {Object} obj - anonymous object, typically from JSON\n * @returns {CAG} new CAG object\n */\nconst fromObject = function (obj) {\n  let sides = obj.sides.map(function (s) {\n    return Side.fromObject(s);\n  });\n  let cag = fromSides(sides);\n  cag.isCanonicalized = obj.isCanonicalized;\n  return cag;\n};\n\n/** Construct a CAG from a list of points (a polygon).\n * Like fromPoints() but does not check if the result is a valid polygon.\n * The points MUST rotate counter clockwise.\n * The points can define a convex or a concave polygon.\n * The polygon must not self intersect.\n * @param {points[]} points - list of points in 2D space\n * @returns {CAG} new CAG object\n */\nconst fromPointsNoCheck = function (points) {\n  let sides = [];\n  let prevpoint = new Vector2D(points[points.length - 1]);\n  let prevvertex = new Vertex2(prevpoint);\n  points.map(function (p) {\n    let point = new Vector2D(p);\n    let vertex = new Vertex2(point);\n    let side = new Side(prevvertex, vertex);\n    sides.push(side);\n    prevvertex = vertex;\n  });\n  return fromSides(sides);\n};\n\n/** Construct a CAG from a 2d-path (a closed sequence of points).\n * Like fromPoints() but does not check if the result is a valid polygon.\n * @param {path} Path2 - a Path2 path\n * @returns {CAG} new CAG object\n */\nconst fromPath2 = function (path) {\n  if (!path.isClosed()) throw new Error('The path should be closed!');\n  return fromPoints(path.getPoints());\n};\n\n/** Reconstruct a CAG from the output of toCompactBinary().\n * @param {CompactBinary} bin - see toCompactBinary()\n * @returns {CAG} new CAG object\n */\nconst fromCompactBinary = function (bin) {\n  if (bin['class'] !== 'CAG') throw new Error('Not a CAG');\n  let vertices = [];\n  let vertexData = bin.vertexData;\n  let numvertices = vertexData.length / 2;\n  let arrayindex = 0;\n  for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n    let x = vertexData[arrayindex++];\n    let y = vertexData[arrayindex++];\n    let pos = new Vector2D(x, y);\n    let vertex = new Vertex2(pos);\n    vertices.push(vertex);\n  }\n  let sides = [];\n  let numsides = bin.sideVertexIndices.length / 2;\n  arrayindex = 0;\n  for (let sideindex = 0; sideindex < numsides; sideindex++) {\n    let vertexindex0 = bin.sideVertexIndices[arrayindex++];\n    let vertexindex1 = bin.sideVertexIndices[arrayindex++];\n    let side = new Side(vertices[vertexindex0], vertices[vertexindex1]);\n    sides.push(side);\n  }\n  let cag = fromSides(sides);\n  cag.isCanonicalized = true;\n  return cag;\n};\n\nmodule.exports = {\n  fromSides,\n  fromObject,\n  fromPoints,\n  fromPointsNoCheck,\n  fromPath2,\n  fromFakeCSG,\n  fromCompactBinary\n};\n","const {Connector} = require('./connectors');\nconst Vertex3D = require('./math/Vertex3');\nconst Vector2D = require('./math/Vector2');\nconst Vector3D = require('./math/Vector3');\nconst Polygon = require('./math/Polygon3');\n\nconst {fromPolygons} = require('./CSGFactories');\nconst {fromSides, fromFakeCSG} = require('./CAGFactories');\n\nconst canonicalize = require('./utils/canonicalize');\nconst retesselate = require('./utils/retesellate');\nconst {isCAGValid, isSelfIntersecting, hasPointInside} = require('./utils/cagValidation');\nconst {area, getBounds} = require('./utils/cagMeasurements');\n\n// all of these are good candidates for elimination in this scope, since they are part of a functional api\nconst {overCutInsideCorners} = require('../api/ops-cnc');\nconst {extrudeInOrthonormalBasis, extrudeInPlane, extrude, rotateExtrude} = require('../api/ops-extrusions');\nconst cagoutlinePaths = require('../api/cagOutlinePaths');\nconst center = require('../api/center');\nconst {expand, contract, expandedShellOfCAG} = require('../api/ops-expandContract');\n/**\n * Class CAG\n * Holds a solid area geometry like CSG but 2D.\n * Each area consists of a number of sides.\n * Each side is a line between 2 points.\n * @constructor\n */\nlet CAG = function () {\n  this.sides = [];\n  this.isCanonicalized = false;\n};\n\nCAG.prototype = {\n  union: function (cag) {\n    let cags;\n    if (cag instanceof Array) {\n      cags = cag;\n    } else {\n      cags = [cag];\n    }\n    let r = this._toCSGWall(-1, 1);\n    r = r.union(\n      cags.map(function (cag) {\n        return cag._toCSGWall(-1, 1).reTesselated();\n      }), false, false);\n    return fromFakeCSG(r).canonicalized();\n  },\n\n  subtract: function (cag) {\n    let cags;\n    if (cag instanceof Array) {\n      cags = cag;\n    } else {\n      cags = [cag];\n    }\n    let r = this._toCSGWall(-1, 1);\n    cags.map(function (cag) {\n      r = r.subtractSub(cag._toCSGWall(-1, 1), false, false);\n    });\n    r = r.reTesselated();\n    r = r.canonicalized();\n    r = fromFakeCSG(r);\n    r = r.canonicalized();\n    return r;\n  },\n\n  intersect: function (cag) {\n    let cags;\n    if (cag instanceof Array) {\n      cags = cag;\n    } else {\n      cags = [cag];\n    }\n    let r = this._toCSGWall(-1, 1);\n    cags.map(function (cag) {\n      r = r.intersectSub(cag._toCSGWall(-1, 1), false, false);\n    });\n    r = r.reTesselated();\n    r = r.canonicalized();\n    r = fromFakeCSG(r);\n    r = r.canonicalized();\n    return r;\n  },\n\n  transform: function (matrix4x4) {\n    let ismirror = matrix4x4.isMirroring();\n    let newsides = this.sides.map(function (side) {\n      return side.transform(matrix4x4);\n    });\n    let result = fromSides(newsides);\n    if (ismirror) {\n      result = result.flipped();\n    }\n    return result;\n  },\n\n  flipped: function () {\n    let newsides = this.sides.map(function (side) {\n      return side.flipped();\n    });\n    newsides.reverse();\n    return fromSides(newsides);\n  },\n\n  // ALIAS !\n  center: function (axes) {\n    return center({axes: axes}, [this]);\n  },\n\n  // ALIAS !\n  expandedShell: function (radius, resolution) {\n    return expandedShellOfCAG(this, radius, resolution);\n  },\n\n  // ALIAS !\n  expand: function (radius, resolution) {\n    return expand(this, radius, resolution);\n  },\n\n  contract: function (radius, resolution) {\n    return contract(this, radius, resolution);\n  },\n\n  // ALIAS !\n  area: function () {\n    return area(this);\n  },\n\n  // ALIAS !\n  getBounds: function () {\n    return getBounds(this);\n  },\n  // ALIAS !\n  isSelfIntersecting: function (debug) {\n    return isSelfIntersecting(this, debug);\n  },\n  // extrusion: all aliases to simple functions\n  extrudeInOrthonormalBasis: function (orthonormalbasis, depth, options) {\n    return extrudeInOrthonormalBasis(this, orthonormalbasis, depth, options);\n  },\n\n  // ALIAS !\n  extrudeInPlane: function (axis1, axis2, depth, options) {\n    return extrudeInPlane(this, axis1, axis2, depth, options);\n  },\n\n  // ALIAS !\n  extrude: function (options) {\n    return extrude(this, options);\n  },\n\n  // ALIAS !\n  rotateExtrude: function (options) { // FIXME options should be optional\n    return rotateExtrude(this, options);\n  },\n\n  // ALIAS !\n  check: function () {\n    return isCAGValid(this);\n  },\n\n  // ALIAS !\n  canonicalized: function () {\n    return canonicalize(this);\n  },\n\n  // ALIAS !\n  reTesselated: function () {\n    return retesselate(this);\n  },\n\n  // ALIAS !\n  getOutlinePaths: function () {\n    return cagoutlinePaths(this);\n  },\n\n  // ALIAS !\n  overCutInsideCorners: function (cutterradius) {\n    return overCutInsideCorners(this, cutterradius);\n  },\n\n  // ALIAS !\n  hasPointInside: function (point) {\n    return hasPointInside(this, point);\n  },\n\n  // All the toXXX functions\n  toString: function () {\n    let result = 'CAG (' + this.sides.length + ' sides):\\n';\n    this.sides.map(function (side) {\n      result += '  ' + side.toString() + '\\n';\n    });\n    return result;\n  },\n\n  _toCSGWall: function (z0, z1) {\n    let polygons = this.sides.map(function (side) {\n      return side.toPolygon3D(z0, z1);\n    });\n    return fromPolygons(polygons);\n  },\n\n  _toVector3DPairs: function (m) {\n    // transform m\n    let pairs = this.sides.map(function (side) {\n      let p0 = side.vertex0.pos;\n      let p1 = side.vertex1.pos;\n      return [Vector3D.Create(p0.x, p0.y, 0),\n        Vector3D.Create(p1.x, p1.y, 0)];\n    });\n    if (typeof m !== 'undefined') {\n      pairs = pairs.map(function (pair) {\n        return pair.map(function (v) {\n          return v.transform(m);\n        });\n      });\n    }\n    return pairs;\n  },\n\n  /*\n    * transform a cag into the polygons of a corresponding 3d plane, positioned per options\n    * Accepts a connector for plane positioning, or optionally\n    * single translation, axisVector, normalVector arguments\n    * (toConnector has precedence over single arguments if provided)\n    */\n  _toPlanePolygons: function (options) {\n    const defaults = {\n      flipped: false\n    };\n    options = Object.assign({}, defaults, options);\n    let {flipped} = options;\n    // reference connector for transformation\n    let origin = [0, 0, 0];\n    let defaultAxis = [0, 0, 1];\n    let defaultNormal = [0, 1, 0];\n    let thisConnector = new Connector(origin, defaultAxis, defaultNormal);\n    // translated connector per options\n    let translation = options.translation || origin;\n    let axisVector = options.axisVector || defaultAxis;\n    let normalVector = options.normalVector || defaultNormal;\n    // will override above if options has toConnector\n    let toConnector = options.toConnector ||\n      new Connector(translation, axisVector, normalVector);\n    // resulting transform\n    let m = thisConnector.getTransformationTo(toConnector, false, 0);\n    // create plane as a (partial non-closed) CSG in XY plane\n    let bounds = this.getBounds();\n    bounds[0] = bounds[0].minus(new Vector2D(1, 1));\n    bounds[1] = bounds[1].plus(new Vector2D(1, 1));\n    let csgshell = this._toCSGWall(-1, 1);\n    let csgplane = fromPolygons([new Polygon([\n      new Vertex3D(new Vector3D(bounds[0].x, bounds[0].y, 0)),\n      new Vertex3D(new Vector3D(bounds[1].x, bounds[0].y, 0)),\n      new Vertex3D(new Vector3D(bounds[1].x, bounds[1].y, 0)),\n      new Vertex3D(new Vector3D(bounds[0].x, bounds[1].y, 0))\n    ])]);\n    if (flipped) {\n      csgplane = csgplane.invert();\n    }\n    // intersectSub -> prevent premature retesselate/canonicalize\n    csgplane = csgplane.intersectSub(csgshell);\n    // only keep the polygons in the z plane:\n    let polys = csgplane.polygons.filter(function (polygon) {\n      return Math.abs(polygon.plane.normal.z) > 0.99;\n    });\n    // add uv vectors, corresponding with the x and y coordinates of the\n    // points defining the original CAG\n    polys.forEach(function (poly) {\n      poly.vertices.forEach(function (vertex) {\n        vertex.uv = new Vector2D(vertex.pos.x, vertex.pos.y);\n      });\n    });\n\n    // finally, position the plane per passed transformations\n    return polys.map(function (poly) {\n      return poly.transform(m);\n    });\n  },\n\n  /*\n    * given 2 connectors, this returns all polygons of a \"wall\" between 2\n    * copies of this cag, positioned in 3d space as \"bottom\" and\n    * \"top\" plane per connectors toConnector1, and toConnector2, respectively\n    */\n  _toWallPolygons: function (options, iteration = 0) {\n    // normals are going to be correct as long as toConn2.point - toConn1.point\n    // points into cag normal direction (check in caller)\n    // arguments: options.toConnector1, options.toConnector2, options.cag\n    //     walls go from toConnector1 to toConnector2\n    //     optionally, target cag to point to - cag needs to have same number of sides as this!\n    let origin = [0, 0, 0];\n    let defaultAxis = [0, 0, 1];\n    let defaultNormal = [0, 1, 0];\n    let thisConnector = new Connector(origin, defaultAxis, defaultNormal);\n    // arguments:\n    let toConnector1 = options.toConnector1;\n    // let toConnector2 = new Connector([0, 0, -30], defaultAxis, defaultNormal);\n    let toConnector2 = options.toConnector2;\n    if (!(toConnector1 instanceof Connector && toConnector2 instanceof Connector)) {\n      throw new Error('could not parse Connector arguments toConnector1 or toConnector2');\n    }\n    if (options.cag) {\n      if (options.cag.sides.length !== this.sides.length) {\n        throw new Error('target cag needs same sides count as start cag');\n      }\n    }\n    // target cag is same as this unless specified\n    let toCag = options.cag || this;\n    let m1 = thisConnector.getTransformationTo(toConnector1, toConnector1.axisvector.z < 0, 0);\n    let m2 = thisConnector.getTransformationTo(toConnector2, toConnector2.axisvector.z < 0, 0);\n    let vps1 = this._toVector3DPairs(m1);\n    let vps2 = toCag._toVector3DPairs(m2);\n    let hasMirroredNormals = toConnector1.axisvector.z < 0;\n\n    // group the Vector3DPairs by 2D polygon in case of multi-array cag\n    let vps1List = [];\n    let vps2List = [];\n    let vps1Temp = [vps1[0]];\n    let vps2Temp = [vps2[0]];\n    let i = 0;\n    for (i = 1; i < vps1.length; ++i) {\n      if (!(vps1[i][1].equals(vps1[i - 1][0]) || vps1[i][0].equals(vps1[i - 1][1]))) {\n        vps1List.push(vps1Temp);\n        vps1Temp = [];\n        vps2List.push(vps2Temp);\n        vps2Temp = [];\n      }\n      vps1Temp.push(vps1[i]);\n      vps2Temp.push(vps2[i]);\n    }\n    vps1List.push(vps1Temp);\n    vps2List.push(vps2Temp);\n\n    // calculate UV coordinates for each extruded side\n    let polygons = [];\n    vps1List.forEach(function (vps1, i) {\n      let xbot0 = 0;\n      let xtop0 = 0;\n      vps2 = vps2List[i];\n      vps1.forEach(function (vp1, j) {\n        let xbot1 = xbot0 + vp1[0].distanceTo(vp1[1]);\n        let xtop1 = xtop0 + vps2[j][0].distanceTo(vps2[j][1]);\n        let y0 = vp1[0].distanceTo(vps2[j][0]);\n        let y1 = vp1[1].distanceTo(vps2[j][1]);\n        let polygon1 = new Polygon(\n          [Vertex3D.fromPosAndUV(vps2[j][1], new Vector2D(xtop1, y1 * (1 + iteration))),\n            Vertex3D.fromPosAndUV(vps2[j][0], new Vector2D(xtop0, y0 * (1 + iteration))),\n            Vertex3D.fromPosAndUV(vp1[0], new Vector2D(xbot0, y0 * iteration))]);\n        let polygon2 = new Polygon(\n          [Vertex3D.fromPosAndUV(vps2[j][1], new Vector2D(xtop1, y1 * (1 + iteration))),\n            Vertex3D.fromPosAndUV(vp1[0], new Vector2D(xbot0, y0 * iteration)),\n            Vertex3D.fromPosAndUV(vp1[1], new Vector2D(xbot1, y1 * iteration))]);\n        if (hasMirroredNormals) {\n          polygon1.plane = polygon1.plane.flipped();\n          polygon2.plane = polygon2.plane.flipped();\n        }\n        polygons.push(polygon1);\n        polygons.push(polygon2);\n        xbot0 = xbot1;\n        xtop0 = xtop1;\n      });\n    });\n    return polygons;\n  },\n\n  /**\n   * Convert to a list of points.\n   * @return {points[]} list of points in 2D space\n   */\n  toPoints: function () {\n    let points = this.sides.map(function (side) {\n      let v0 = side.vertex0;\n      // let v1 = side.vertex1\n      return v0.pos;\n    });\n    // due to the logic of fromPoints()\n    // move the first point to the last\n    if (points.length > 0) {\n      points.push(points.shift());\n    }\n    return points;\n  },\n\n  /** Convert to compact binary form.\n   * See fromCompactBinary.\n   * @return {CompactBinary}\n   */\n  toCompactBinary: function () {\n    let cag = this.canonicalized();\n    let numsides = cag.sides.length;\n    let vertexmap = {};\n    let vertices = [];\n    let numvertices = 0;\n    let sideVertexIndices = new Uint32Array(2 * numsides);\n    let sidevertexindicesindex = 0;\n    cag.sides.map(function (side) {\n      [side.vertex0, side.vertex1].map(function (v) {\n        let vertextag = v.getTag();\n        let vertexindex;\n        if (!(vertextag in vertexmap)) {\n          vertexindex = numvertices++;\n          vertexmap[vertextag] = vertexindex;\n          vertices.push(v);\n        } else {\n          vertexindex = vertexmap[vertextag];\n        }\n        sideVertexIndices[sidevertexindicesindex++] = vertexindex;\n      });\n    });\n    let vertexData = new Float64Array(numvertices * 2);\n    let verticesArrayIndex = 0;\n    vertices.map(function (v) {\n      let pos = v.pos;\n      vertexData[verticesArrayIndex++] = pos._x;\n      vertexData[verticesArrayIndex++] = pos._y;\n    });\n    let result = {\n      'class': 'CAG',\n      sideVertexIndices: sideVertexIndices,\n      vertexData: vertexData\n    };\n    return result;\n  }\n};\n\nmodule.exports = CAG;\n","const Vector3D = require('./Vector3');\nconst Vector2D = require('./Vector2');\nconst OrthoNormalBasis = require('./OrthoNormalBasis');\nconst Plane = require('./Plane');\n\n// # class Matrix4x4:\n// Represents a 4x4 matrix. Elements are specified in row order\nconst Matrix4x4 = function (elements) {\n  if (arguments.length >= 1) {\n    this.elements = elements;\n  } else {\n    // if no arguments passed: create unity matrix\n    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n  }\n};\n\nMatrix4x4.prototype = {\n  plus: function (m) {\n    var r = [];\n    for (var i = 0; i < 16; i++) {\n      r[i] = this.elements[i] + m.elements[i];\n    }\n    return new Matrix4x4(r);\n  },\n\n  minus: function (m) {\n    var r = [];\n    for (var i = 0; i < 16; i++) {\n      r[i] = this.elements[i] - m.elements[i];\n    }\n    return new Matrix4x4(r);\n  },\n\n  // right multiply by another 4x4 matrix:\n  multiply: function (m) {\n    // cache elements in local variables, for speedup:\n    var this0 = this.elements[0];\n    var this1 = this.elements[1];\n    var this2 = this.elements[2];\n    var this3 = this.elements[3];\n    var this4 = this.elements[4];\n    var this5 = this.elements[5];\n    var this6 = this.elements[6];\n    var this7 = this.elements[7];\n    var this8 = this.elements[8];\n    var this9 = this.elements[9];\n    var this10 = this.elements[10];\n    var this11 = this.elements[11];\n    var this12 = this.elements[12];\n    var this13 = this.elements[13];\n    var this14 = this.elements[14];\n    var this15 = this.elements[15];\n    var m0 = m.elements[0];\n    var m1 = m.elements[1];\n    var m2 = m.elements[2];\n    var m3 = m.elements[3];\n    var m4 = m.elements[4];\n    var m5 = m.elements[5];\n    var m6 = m.elements[6];\n    var m7 = m.elements[7];\n    var m8 = m.elements[8];\n    var m9 = m.elements[9];\n    var m10 = m.elements[10];\n    var m11 = m.elements[11];\n    var m12 = m.elements[12];\n    var m13 = m.elements[13];\n    var m14 = m.elements[14];\n    var m15 = m.elements[15];\n\n    var result = [];\n    result[0] = this0 * m0 + this1 * m4 + this2 * m8 + this3 * m12;\n    result[1] = this0 * m1 + this1 * m5 + this2 * m9 + this3 * m13;\n    result[2] = this0 * m2 + this1 * m6 + this2 * m10 + this3 * m14;\n    result[3] = this0 * m3 + this1 * m7 + this2 * m11 + this3 * m15;\n    result[4] = this4 * m0 + this5 * m4 + this6 * m8 + this7 * m12;\n    result[5] = this4 * m1 + this5 * m5 + this6 * m9 + this7 * m13;\n    result[6] = this4 * m2 + this5 * m6 + this6 * m10 + this7 * m14;\n    result[7] = this4 * m3 + this5 * m7 + this6 * m11 + this7 * m15;\n    result[8] = this8 * m0 + this9 * m4 + this10 * m8 + this11 * m12;\n    result[9] = this8 * m1 + this9 * m5 + this10 * m9 + this11 * m13;\n    result[10] = this8 * m2 + this9 * m6 + this10 * m10 + this11 * m14;\n    result[11] = this8 * m3 + this9 * m7 + this10 * m11 + this11 * m15;\n    result[12] = this12 * m0 + this13 * m4 + this14 * m8 + this15 * m12;\n    result[13] = this12 * m1 + this13 * m5 + this14 * m9 + this15 * m13;\n    result[14] = this12 * m2 + this13 * m6 + this14 * m10 + this15 * m14;\n    result[15] = this12 * m3 + this13 * m7 + this14 * m11 + this15 * m15;\n    return new Matrix4x4(result);\n  },\n\n  clone: function () {\n    var elements = this.elements.map(function (p) {\n      return p;\n    });\n    return new Matrix4x4(elements);\n  },\n\n  // Right multiply the matrix by a Vector3D (interpreted as 3 row, 1 column)\n  // (result = M*v)\n  // Fourth element is taken as 1\n  rightMultiply1x3Vector: function (v) {\n    var v0 = v._x;\n    var v1 = v._y;\n    var v2 = v._z;\n    var v3 = 1;\n    var x = v0 * this.elements[0] + v1 * this.elements[1] + v2 * this.elements[2] + v3 * this.elements[3];\n    var y = v0 * this.elements[4] + v1 * this.elements[5] + v2 * this.elements[6] + v3 * this.elements[7];\n    var z = v0 * this.elements[8] + v1 * this.elements[9] + v2 * this.elements[10] + v3 * this.elements[11];\n    var w = v0 * this.elements[12] + v1 * this.elements[13] + v2 * this.elements[14] + v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      var invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector3D(x, y, z);\n  },\n\n  // Multiply a Vector3D (interpreted as 3 column, 1 row) by this matrix\n  // (result = v*M)\n  // Fourth element is taken as 1\n  leftMultiply1x3Vector: function (v) {\n    var v0 = v._x;\n    var v1 = v._y;\n    var v2 = v._z;\n    var v3 = 1;\n    var x = v0 * this.elements[0] + v1 * this.elements[4] + v2 * this.elements[8] + v3 * this.elements[12];\n    var y = v0 * this.elements[1] + v1 * this.elements[5] + v2 * this.elements[9] + v3 * this.elements[13];\n    var z = v0 * this.elements[2] + v1 * this.elements[6] + v2 * this.elements[10] + v3 * this.elements[14];\n    var w = v0 * this.elements[3] + v1 * this.elements[7] + v2 * this.elements[11] + v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      var invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector3D(x, y, z);\n  },\n\n  // Right multiply the matrix by a Vector2D (interpreted as 2 row, 1 column)\n  // (result = M*v)\n  // Fourth element is taken as 1\n  rightMultiply1x2Vector: function (v) {\n    var v0 = v.x;\n    var v1 = v.y;\n    var v2 = 0;\n    var v3 = 1;\n    var x = v0 * this.elements[0] + v1 * this.elements[1] + v2 * this.elements[2] + v3 * this.elements[3];\n    var y = v0 * this.elements[4] + v1 * this.elements[5] + v2 * this.elements[6] + v3 * this.elements[7];\n    var z = v0 * this.elements[8] + v1 * this.elements[9] + v2 * this.elements[10] + v3 * this.elements[11];\n    var w = v0 * this.elements[12] + v1 * this.elements[13] + v2 * this.elements[14] + v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      var invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector2D(x, y);\n  },\n\n  // Multiply a Vector2D (interpreted as 2 column, 1 row) by this matrix\n  // (result = v*M)\n  // Fourth element is taken as 1\n  leftMultiply1x2Vector: function (v) {\n    var v0 = v.x;\n    var v1 = v.y;\n    var v2 = 0;\n    var v3 = 1;\n    var x = v0 * this.elements[0] + v1 * this.elements[4] + v2 * this.elements[8] + v3 * this.elements[12];\n    var y = v0 * this.elements[1] + v1 * this.elements[5] + v2 * this.elements[9] + v3 * this.elements[13];\n    var z = v0 * this.elements[2] + v1 * this.elements[6] + v2 * this.elements[10] + v3 * this.elements[14];\n    var w = v0 * this.elements[3] + v1 * this.elements[7] + v2 * this.elements[11] + v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      var invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector2D(x, y);\n  },\n\n  // determine whether this matrix is a mirroring transformation\n  isMirroring: function () {\n    var u = new Vector3D(this.elements[0], this.elements[4], this.elements[8]);\n    var v = new Vector3D(this.elements[1], this.elements[5], this.elements[9]);\n    var w = new Vector3D(this.elements[2], this.elements[6], this.elements[10]);\n\n    // for a true orthogonal, non-mirrored base, u.cross(v) == w\n    // If they have an opposite direction then we are mirroring\n    var mirrorvalue = u.cross(v).dot(w);\n    var ismirror = (mirrorvalue < 0);\n    return ismirror;\n  }\n};\n\n// return the unity matrix\nMatrix4x4.unity = function () {\n  return new Matrix4x4();\n};\n\n// Create a rotation matrix for rotating around the x axis\nMatrix4x4.rotationX = function (degrees) {\n  var radians = degrees * Math.PI * (1.0 / 180.0);\n  var cos = Math.cos(radians);\n  var sin = Math.sin(radians);\n  var els = [\n    1, 0, 0, 0, 0, cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1\n  ];\n  return new Matrix4x4(els);\n};\n\n// Create a rotation matrix for rotating around the y axis\nMatrix4x4.rotationY = function (degrees) {\n  var radians = degrees * Math.PI * (1.0 / 180.0);\n  var cos = Math.cos(radians);\n  var sin = Math.sin(radians);\n  var els = [\n    cos, 0, -sin, 0, 0, 1, 0, 0, sin, 0, cos, 0, 0, 0, 0, 1\n  ];\n  return new Matrix4x4(els);\n};\n\n// Create a rotation matrix for rotating around the z axis\nMatrix4x4.rotationZ = function (degrees) {\n  var radians = degrees * Math.PI * (1.0 / 180.0);\n  var cos = Math.cos(radians);\n  var sin = Math.sin(radians);\n  var els = [\n    cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1\n  ];\n  return new Matrix4x4(els);\n};\n\n// Matrix for rotation about arbitrary point and axis\nMatrix4x4.rotation = function (rotationCenter, rotationAxis, degrees) {\n  rotationCenter = new Vector3D(rotationCenter);\n  rotationAxis = new Vector3D(rotationAxis);\n  var rotationPlane = Plane.fromNormalAndPoint(rotationAxis, rotationCenter);\n  var orthobasis = new OrthoNormalBasis(rotationPlane);\n  var transformation = Matrix4x4.translation(rotationCenter.negated());\n  transformation = transformation.multiply(orthobasis.getProjectionMatrix());\n  transformation = transformation.multiply(Matrix4x4.rotationZ(degrees));\n  transformation = transformation.multiply(orthobasis.getInverseProjectionMatrix());\n  transformation = transformation.multiply(Matrix4x4.translation(rotationCenter));\n  return transformation;\n};\n\n// Create an affine matrix for translation:\nMatrix4x4.translation = function (v) {\n  // parse as Vector3D, so we can pass an array or a Vector3D\n  var vec = new Vector3D(v);\n  var els = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, vec.x, vec.y, vec.z, 1];\n  return new Matrix4x4(els);\n};\n\n// Create an affine matrix for mirroring into an arbitrary plane:\nMatrix4x4.mirroring = function (plane) {\n  var nx = plane.normal.x;\n  var ny = plane.normal.y;\n  var nz = plane.normal.z;\n  var w = plane.w;\n  var els = [\n    (1.0 - 2.0 * nx * nx), (-2.0 * ny * nx), (-2.0 * nz * nx), 0,\n    (-2.0 * nx * ny), (1.0 - 2.0 * ny * ny), (-2.0 * nz * ny), 0,\n    (-2.0 * nx * nz), (-2.0 * ny * nz), (1.0 - 2.0 * nz * nz), 0,\n    (2.0 * nx * w), (2.0 * ny * w), (2.0 * nz * w), 1\n  ];\n  return new Matrix4x4(els);\n};\n\n// Create an affine matrix for scaling:\nMatrix4x4.scaling = function (v) {\n  // parse as Vector3D, so we can pass an array or a Vector3D\n  var vec = new Vector3D(v);\n  var els = [\n    vec.x, 0, 0, 0, 0, vec.y, 0, 0, 0, 0, vec.z, 0, 0, 0, 0, 1\n  ];\n  return new Matrix4x4(els);\n};\n\nmodule.exports = Matrix4x4;\n","const Vector2D = require('./Vector2');\nconst Vector3D = require('./Vector3');\nconst Line2D = require('./Line2');\nconst Line3D = require('./Line3');\nconst Plane = require('./Plane');\n\n/** class OrthoNormalBasis\n * Reprojects points on a 3D plane onto a 2D plane\n * or from a 2D plane back onto the 3D plane\n * @param  {Plane} plane\n * @param  {Vector3D|Vector2D} rightvector\n */\nconst OrthoNormalBasis = function (plane, rightvector) {\n  if (arguments.length < 2) {\n    // choose an arbitrary right hand vector, making sure it is somewhat orthogonal to the plane normal:\n    rightvector = plane.normal.randomNonParallelVector();\n  } else {\n    rightvector = new Vector3D(rightvector);\n  }\n  this.v = plane.normal.cross(rightvector).unit();\n  this.u = this.v.cross(plane.normal);\n  this.plane = plane;\n  this.planeorigin = plane.normal.times(plane.w);\n};\n\n// Get an orthonormal basis for the standard XYZ planes.\n// Parameters: the names of two 3D axes. The 2d x axis will map to the first given 3D axis, the 2d y\n// axis will map to the second.\n// Prepend the axis with a \"-\" to invert the direction of this axis.\n// For example: OrthoNormalBasis.GetCartesian(\"-Y\",\"Z\")\n//   will return an orthonormal basis where the 2d X axis maps to the 3D inverted Y axis, and\n//   the 2d Y axis maps to the 3D Z axis.\nOrthoNormalBasis.GetCartesian = function (xaxisid, yaxisid) {\n  let axisid = xaxisid + '/' + yaxisid;\n  let planenormal, rightvector;\n  if (axisid === 'X/Y') {\n    planenormal = [0, 0, 1];\n    rightvector = [1, 0, 0];\n  } else if (axisid === 'Y/-X') {\n    planenormal = [0, 0, 1];\n    rightvector = [0, 1, 0];\n  } else if (axisid === '-X/-Y') {\n    planenormal = [0, 0, 1];\n    rightvector = [-1, 0, 0];\n  } else if (axisid === '-Y/X') {\n    planenormal = [0, 0, 1];\n    rightvector = [0, -1, 0];\n  } else if (axisid === '-X/Y') {\n    planenormal = [0, 0, -1];\n    rightvector = [-1, 0, 0];\n  } else if (axisid === '-Y/-X') {\n    planenormal = [0, 0, -1];\n    rightvector = [0, -1, 0];\n  } else if (axisid === 'X/-Y') {\n    planenormal = [0, 0, -1];\n    rightvector = [1, 0, 0];\n  } else if (axisid === 'Y/X') {\n    planenormal = [0, 0, -1];\n    rightvector = [0, 1, 0];\n  } else if (axisid === 'X/Z') {\n    planenormal = [0, -1, 0];\n    rightvector = [1, 0, 0];\n  } else if (axisid === 'Z/-X') {\n    planenormal = [0, -1, 0];\n    rightvector = [0, 0, 1];\n  } else if (axisid === '-X/-Z') {\n    planenormal = [0, -1, 0];\n    rightvector = [-1, 0, 0];\n  } else if (axisid === '-Z/X') {\n    planenormal = [0, -1, 0];\n    rightvector = [0, 0, -1];\n  } else if (axisid === '-X/Z') {\n    planenormal = [0, 1, 0];\n    rightvector = [-1, 0, 0];\n  } else if (axisid === '-Z/-X') {\n    planenormal = [0, 1, 0];\n    rightvector = [0, 0, -1];\n  } else if (axisid === 'X/-Z') {\n    planenormal = [0, 1, 0];\n    rightvector = [1, 0, 0];\n  } else if (axisid === 'Z/X') {\n    planenormal = [0, 1, 0];\n    rightvector = [0, 0, 1];\n  } else if (axisid === 'Y/Z') {\n    planenormal = [1, 0, 0];\n    rightvector = [0, 1, 0];\n  } else if (axisid === 'Z/-Y') {\n    planenormal = [1, 0, 0];\n    rightvector = [0, 0, 1];\n  } else if (axisid === '-Y/-Z') {\n    planenormal = [1, 0, 0];\n    rightvector = [0, -1, 0];\n  } else if (axisid === '-Z/Y') {\n    planenormal = [1, 0, 0];\n    rightvector = [0, 0, -1];\n  } else if (axisid === '-Y/Z') {\n    planenormal = [-1, 0, 0];\n    rightvector = [0, -1, 0];\n  } else if (axisid === '-Z/-Y') {\n    planenormal = [-1, 0, 0];\n    rightvector = [0, 0, -1];\n  } else if (axisid === 'Y/-Z') {\n    planenormal = [-1, 0, 0];\n    rightvector = [0, 1, 0];\n  } else if (axisid === 'Z/Y') {\n    planenormal = [-1, 0, 0];\n    rightvector = [0, 0, 1];\n  } else {\n    throw new Error('OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.');\n  }\n  return new OrthoNormalBasis(new Plane(new Vector3D(planenormal), 0), new Vector3D(rightvector));\n};\n\n/*\n// test code for OrthoNormalBasis.GetCartesian()\nOrthoNormalBasis.GetCartesian_Test=function() {\n  let axisnames=[\"X\",\"Y\",\"Z\",\"-X\",\"-Y\",\"-Z\"];\n  let axisvectors=[[1,0,0], [0,1,0], [0,0,1], [-1,0,0], [0,-1,0], [0,0,-1]];\n  for(let axis1=0; axis1 < 3; axis1++) {\n    for(let axis1inverted=0; axis1inverted < 2; axis1inverted++) {\n      let axis1name=axisnames[axis1+3*axis1inverted];\n      let axis1vector=axisvectors[axis1+3*axis1inverted];\n      for(let axis2=0; axis2 < 3; axis2++) {\n        if(axis2 != axis1) {\n          for(let axis2inverted=0; axis2inverted < 2; axis2inverted++) {\n            let axis2name=axisnames[axis2+3*axis2inverted];\n            let axis2vector=axisvectors[axis2+3*axis2inverted];\n            let orthobasis=OrthoNormalBasis.GetCartesian(axis1name, axis2name);\n            let test1=orthobasis.to3D(new Vector2D([1,0]));\n            let test2=orthobasis.to3D(new Vector2D([0,1]));\n            let expected1=new Vector3D(axis1vector);\n            let expected2=new Vector3D(axis2vector);\n            let d1=test1.distanceTo(expected1);\n            let d2=test2.distanceTo(expected2);\n            if( (d1 > 0.01) || (d2 > 0.01) ) {\n              throw new Error(\"Wrong!\");\n  }}}}}}\n  throw new Error(\"OK\");\n};\n*/\n\n// The z=0 plane, with the 3D x and y vectors mapped to the 2D x and y vector\nOrthoNormalBasis.Z0Plane = function () {\n  let plane = new Plane(new Vector3D([0, 0, 1]), 0);\n  return new OrthoNormalBasis(plane, new Vector3D([1, 0, 0]));\n};\n\nOrthoNormalBasis.prototype = {\n  getProjectionMatrix: function () {\n    const Matrix4x4 = require('./Matrix4'); // FIXME: circular dependencies Matrix=>OrthoNormalBasis => Matrix\n    return new Matrix4x4([\n      this.u.x, this.v.x, this.plane.normal.x, 0,\n      this.u.y, this.v.y, this.plane.normal.y, 0,\n      this.u.z, this.v.z, this.plane.normal.z, 0,\n      0, 0, -this.plane.w, 1\n    ]);\n  },\n\n  getInverseProjectionMatrix: function () {\n    const Matrix4x4 = require('./Matrix4'); // FIXME: circular dependencies Matrix=>OrthoNormalBasis => Matrix\n    let p = this.plane.normal.times(this.plane.w);\n    return new Matrix4x4([\n      this.u.x, this.u.y, this.u.z, 0,\n      this.v.x, this.v.y, this.v.z, 0,\n      this.plane.normal.x, this.plane.normal.y, this.plane.normal.z, 0,\n      p.x, p.y, p.z, 1\n    ]);\n  },\n\n  to2D: function (vec3) {\n    return new Vector2D(vec3.dot(this.u), vec3.dot(this.v));\n  },\n\n  to3D: function (vec2) {\n    return this.planeorigin.plus(this.u.times(vec2.x)).plus(this.v.times(vec2.y));\n  },\n\n  line3Dto2D: function (line3d) {\n    let a = line3d.point;\n    let b = line3d.direction.plus(a);\n    let a2d = this.to2D(a);\n    let b2d = this.to2D(b);\n    return Line2D.fromPoints(a2d, b2d);\n  },\n\n  line2Dto3D: function (line2d) {\n    let a = line2d.origin();\n    let b = line2d.direction().plus(a);\n    let a3d = this.to3D(a);\n    let b3d = this.to3D(b);\n    return Line3D.fromPoints(a3d, b3d);\n  },\n\n  transform: function (matrix4x4) {\n    // todo: this may not work properly in case of mirroring\n    let newplane = this.plane.transform(matrix4x4);\n    let rightpointTransformed = this.u.transform(matrix4x4);\n    let originTransformed = new Vector3D(0, 0, 0).transform(matrix4x4);\n    let newrighthandvector = rightpointTransformed.minus(originTransformed);\n    let newbasis = new OrthoNormalBasis(newplane, newrighthandvector);\n    return newbasis;\n  }\n};\n\nmodule.exports = OrthoNormalBasis;\n","const Tree = require('./trees');\nconst Polygon = require('./math/Polygon3');\nconst Plane = require('./math/Plane');\nconst OrthoNormalBasis = require('./math/OrthoNormalBasis');\n\nconst CAG = require('./CAG'); // FIXME: for some weird reason if CAG is imported AFTER frompolygons, a lot of things break???\n\nconst Properties = require('./Properties');\nconst {fromPolygons} = require('./CSGFactories'); // FIXME: circular dependency !\n\nconst fixTJunctions = require('./utils/fixTJunctions');\nconst canonicalize = require('./utils/canonicalize');\nconst retesselate = require('./utils/retesellate');\nconst {bounds} = require('./utils/csgMeasurements');\nconst {projectToOrthoNormalBasis} = require('./utils/csgProjections');\n\nconst {lieFlat, getTransformationToFlatLying, getTransformationAndInverseTransformationToFlatLying} = require('../api/ops-cnc');\nconst {sectionCut, cutByPlane} = require('../api/ops-cuts');\nconst center = require('../api/center');\nconst {expand, contract, expandedShellOfCCSG} = require('../api/ops-expandContract');\n\n/** Class CSG\n * Holds a binary space partition tree representing a 3D solid. Two solids can\n * be combined using the `union()`, `subtract()`, and `intersect()` methods.\n * @constructor\n */\nlet CSG = function () {\n  this.polygons = [];\n  this.properties = new Properties();\n  this.isCanonicalized = true;\n  this.isRetesselated = true;\n};\n\nCSG.prototype = {\n  /**\n   * Return a new CSG solid representing the space in either this solid or\n   * in the given solids. Neither this solid nor the given solids are modified.\n   * @param {CSG[]} csg - list of CSG objects\n   * @returns {CSG} new CSG object\n   * @example\n   * let C = A.union(B)\n   * @example\n   * +-------+            +-------+\n   * |       |            |       |\n   * |   A   |            |       |\n   * |    +--+----+   =   |       +----+\n   * +----+--+    |       +----+       |\n   *      |   B   |            |       |\n   *      |       |            |       |\n   *      +-------+            +-------+\n   */\n  union: function (csg) {\n    let csgs;\n    if (csg instanceof Array) {\n      csgs = csg.slice(0);\n      csgs.push(this);\n    } else {\n      csgs = [this, csg];\n    }\n\n    let i;\n    // combine csg pairs in a way that forms a balanced binary tree pattern\n    for (i = 1; i < csgs.length; i += 2) {\n      csgs.push(csgs[i - 1].unionSub(csgs[i]));\n    }\n    return csgs[i - 1].reTesselated().canonicalized();\n  },\n\n  unionSub: function (csg, retesselate, canonicalize) {\n    if (!this.mayOverlap(csg)) {\n      return this.unionForNonIntersecting(csg);\n    } else {\n      let a = new Tree(this.polygons);\n      let b = new Tree(csg.polygons);\n      a.clipTo(b, false);\n\n      // b.clipTo(a, true); // ERROR: this doesn't work\n      b.clipTo(a);\n      b.invert();\n      b.clipTo(a);\n      b.invert();\n\n      let newpolygons = a.allPolygons().concat(b.allPolygons());\n      let result = fromPolygons(newpolygons);\n      result.properties = this.properties._merge(csg.properties);\n      if (retesselate) result = result.reTesselated();\n      if (canonicalize) result = result.canonicalized();\n      return result;\n    }\n  },\n\n  // Like union, but when we know that the two solids are not intersecting\n  // Do not use if you are not completely sure that the solids do not intersect!\n  unionForNonIntersecting: function (csg) {\n    let newpolygons = this.polygons.concat(csg.polygons);\n    let result = fromPolygons(newpolygons);\n    result.properties = this.properties._merge(csg.properties);\n    result.isCanonicalized = this.isCanonicalized && csg.isCanonicalized;\n    result.isRetesselated = this.isRetesselated && csg.isRetesselated;\n    return result;\n  },\n\n  /**\n   * Return a new CSG solid representing space in this solid but\n   * not in the given solids. Neither this solid nor the given solids are modified.\n   * @param {CSG[]} csg - list of CSG objects\n   * @returns {CSG} new CSG object\n   * @example\n   * let C = A.subtract(B)\n   * @example\n   * +-------+            +-------+\n   * |       |            |       |\n   * |   A   |            |       |\n   * |    +--+----+   =   |    +--+\n   * +----+--+    |       +----+\n   *      |   B   |\n   *      |       |\n   *      +-------+\n   */\n  subtract: function (csg) {\n    let csgs;\n    if (csg instanceof Array) {\n      csgs = csg;\n    } else {\n      csgs = [csg];\n    }\n    let result = this;\n    for (let i = 0; i < csgs.length; i++) {\n      let islast = (i === (csgs.length - 1));\n      result = result.subtractSub(csgs[i], islast, islast);\n    }\n    return result;\n  },\n\n  subtractSub: function (csg, retesselate, canonicalize) {\n    let a = new Tree(this.polygons);\n    let b = new Tree(csg.polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a, true);\n    a.addPolygons(b.allPolygons());\n    a.invert();\n    let result = fromPolygons(a.allPolygons());\n    result.properties = this.properties._merge(csg.properties);\n    if (retesselate) result = result.reTesselated();\n    if (canonicalize) result = result.canonicalized();\n    return result;\n  },\n\n  /**\n   * Return a new CSG solid representing space in both this solid and\n   * in the given solids. Neither this solid nor the given solids are modified.\n   * @param {CSG[]} csg - list of CSG objects\n   * @returns {CSG} new CSG object\n   * @example\n   * let C = A.intersect(B)\n   * @example\n   * +-------+\n   * |       |\n   * |   A   |\n   * |    +--+----+   =   +--+\n   * +----+--+    |       +--+\n   *      |   B   |\n   *      |       |\n   *      +-------+\n   */\n  intersect: function (csg) {\n    let csgs;\n    if (csg instanceof Array) {\n      csgs = csg;\n    } else {\n      csgs = [csg];\n    }\n    let result = this;\n    for (let i = 0; i < csgs.length; i++) {\n      let islast = (i === (csgs.length - 1));\n      result = result.intersectSub(csgs[i], islast, islast);\n    }\n    return result;\n  },\n\n  intersectSub: function (csg, retesselate, canonicalize) {\n    let a = new Tree(this.polygons);\n    let b = new Tree(csg.polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.addPolygons(b.allPolygons());\n    a.invert();\n    let result = fromPolygons(a.allPolygons());\n    result.properties = this.properties._merge(csg.properties);\n    if (retesselate) result = result.reTesselated();\n    if (canonicalize) result = result.canonicalized();\n    return result;\n  },\n\n  /**\n   * Return a new CSG solid with solid and empty space switched.\n   * This solid is not modified.\n   * @returns {CSG} new CSG object\n   * @example\n   * let B = A.invert()\n   */\n  invert: function () {\n    let flippedpolygons = this.polygons.map(function (p) {\n      return p.flipped();\n    });\n    return fromPolygons(flippedpolygons);\n    // TODO: flip properties?\n  },\n\n  // Affine transformation of CSG object. Returns a new CSG object\n  transform1: function (matrix4x4) {\n    let newpolygons = this.polygons.map(function (p) {\n      return p.transform(matrix4x4);\n    });\n    let result = fromPolygons(newpolygons);\n    result.properties = this.properties._transform(matrix4x4);\n    result.isRetesselated = this.isRetesselated;\n    return result;\n  },\n\n  /**\n   * Return a new CSG solid that is transformed using the given Matrix.\n   * Several matrix transformations can be combined before transforming this solid.\n   * @param {CSG.Matrix4x4} matrix4x4 - matrix to be applied\n   * @returns {CSG} new CSG object\n   * @example\n   * var m = new CSG.Matrix4x4()\n   * m = m.multiply(CSG.Matrix4x4.rotationX(40))\n   * m = m.multiply(CSG.Matrix4x4.translation([-.5, 0, 0]))\n   * let B = A.transform(m)\n   */\n  transform: function (matrix4x4) {\n    let ismirror = matrix4x4.isMirroring();\n    let transformedvertices = {};\n    let transformedplanes = {};\n    let newpolygons = this.polygons.map(function (p) {\n      let newplane;\n      let plane = p.plane;\n      let planetag = plane.getTag();\n      if (planetag in transformedplanes) {\n        newplane = transformedplanes[planetag];\n      } else {\n        newplane = plane.transform(matrix4x4);\n        transformedplanes[planetag] = newplane;\n      }\n      let newvertices = p.vertices.map(function (v) {\n        let newvertex;\n        let vertextag = v.getTag();\n        if (vertextag in transformedvertices) {\n          newvertex = transformedvertices[vertextag];\n        } else {\n          newvertex = v.transform(matrix4x4);\n          transformedvertices[vertextag] = newvertex;\n        }\n        return newvertex;\n      });\n      if (ismirror) newvertices.reverse();\n      return new Polygon(newvertices, p.shared, newplane);\n    });\n    let result = fromPolygons(newpolygons);\n    result.properties = this.properties._transform(matrix4x4);\n    result.isRetesselated = this.isRetesselated;\n    result.isCanonicalized = this.isCanonicalized;\n    return result;\n  },\n\n  // ALIAS !\n  center: function (axes) {\n    return center({axes: axes}, [this]);\n  },\n\n  // ALIAS !\n  expand: function (radius, resolution) {\n    return expand(this, radius, resolution);\n  },\n\n  // ALIAS !\n  contract: function (radius, resolution) {\n    return contract(this, radius, resolution);\n  },\n\n  // ALIAS !\n  expandedShell: function (radius, resolution, unionWithThis) {\n    return expandedShellOfCCSG(this, radius, resolution, unionWithThis);\n  },\n\n  // cut the solid at a plane, and stretch the cross-section found along plane normal\n  // note: only used in roundedCube() internally\n  stretchAtPlane: function (normal, point, length) {\n    let plane = Plane.fromNormalAndPoint(normal, point);\n    let onb = new OrthoNormalBasis(plane);\n    let crosssect = this.sectionCut(onb);\n    let midpiece = crosssect.extrudeInOrthonormalBasis(onb, length);\n    let piece1 = this.cutByPlane(plane);\n    let piece2 = this.cutByPlane(plane.flipped());\n    let result = piece1.union([midpiece, piece2.translate(plane.normal.times(length))]);\n    return result;\n  },\n\n  // ALIAS !\n  canonicalized: function () {\n    return canonicalize(this);\n  },\n\n  // ALIAS !\n  reTesselated: function () {\n    return retesselate(this);\n  },\n\n  // ALIAS !\n  fixTJunctions: function () {\n    return fixTJunctions(fromPolygons, this);\n  },\n\n  // ALIAS !\n  getBounds: function () {\n    return bounds(this);\n  },\n\n  /** returns true if there is a possibility that the two solids overlap\n   * returns false if we can be sure that they do not overlap\n   * NOTE: this is critical as it is used in UNIONs\n   * @param  {CSG} csg\n   */\n  mayOverlap: function (csg) {\n    if ((this.polygons.length === 0) || (csg.polygons.length === 0)) {\n      return false;\n    } else {\n      let mybounds = bounds(this);\n      let otherbounds = bounds(csg);\n      if (mybounds[1].x < otherbounds[0].x) return false;\n      if (mybounds[0].x > otherbounds[1].x) return false;\n      if (mybounds[1].y < otherbounds[0].y) return false;\n      if (mybounds[0].y > otherbounds[1].y) return false;\n      if (mybounds[1].z < otherbounds[0].z) return false;\n      if (mybounds[0].z > otherbounds[1].z) return false;\n      return true;\n    }\n  },\n\n  // ALIAS !\n  cutByPlane: function (plane) {\n    return cutByPlane(this, plane);\n  },\n\n  /**\n   * Connect a solid to another solid, such that two Connectors become connected\n   * @param  {Connector} myConnector a Connector of this solid\n   * @param  {Connector} otherConnector a Connector to which myConnector should be connected\n   * @param  {Boolean} mirror false: the 'axis' vectors of the connectors should point in the same direction\n   * true: the 'axis' vectors of the connectors should point in opposite direction\n   * @param  {Float} normalrotation degrees of rotation between the 'normal' vectors of the two\n   * connectors\n   * @returns {CSG} this csg, tranformed accordingly\n   */\n  connectTo: function (myConnector, otherConnector, mirror, normalrotation) {\n    let matrix = myConnector.getTransformationTo(otherConnector, mirror, normalrotation);\n    return this.transform(matrix);\n  },\n\n  /**\n   * set the .shared property of all polygons\n   * @param  {Object} shared\n   * @returns {CSG} Returns a new CSG solid, the original is unmodified!\n   */\n  setShared: function (shared) {\n    let polygons = this.polygons.map(function (p) {\n      return new Polygon(p.vertices, shared, p.plane);\n    });\n    let result = fromPolygons(polygons);\n    result.properties = this.properties; // keep original properties\n    result.isRetesselated = this.isRetesselated;\n    result.isCanonicalized = this.isCanonicalized;\n    return result;\n  },\n\n  /** sets the color of this csg: non mutating, returns a new CSG\n   * @param  {Object} args\n   * @returns {CSG} a copy of this CSG, with the given color\n   */\n  setColor: function (args) {\n    let newshared = Polygon.Shared.fromColor.apply(this, arguments);\n    return this.setShared(newshared);\n  },\n\n  // ALIAS !\n  getTransformationAndInverseTransformationToFlatLying: function () {\n    return getTransformationAndInverseTransformationToFlatLying(this);\n  },\n\n  // ALIAS !\n  getTransformationToFlatLying: function () {\n    return getTransformationToFlatLying(this);\n  },\n\n  // ALIAS !\n  lieFlat: function () {\n    return lieFlat(this);\n  },\n\n  // project the 3D CSG onto a plane\n  // This returns a 2D CAG with the 'shadow' shape of the 3D solid when projected onto the\n  // plane represented by the orthonormal basis\n  projectToOrthoNormalBasis: function (orthobasis) {\n    // FIXME:  DEPENDS ON CAG !!\n    return projectToOrthoNormalBasis(this, orthobasis);\n  },\n\n  // FIXME: not finding any uses within our code ?\n  sectionCut: function (orthobasis) {\n    return sectionCut(this, orthobasis);\n  },\n\n  /**\n   * Returns an array of values for the requested features of this solid.\n   * Supported Features: 'volume', 'area'\n   * @param {String[]} features - list of features to calculate\n   * @returns {Float[]} values\n   * @example\n   * let volume = A.getFeatures('volume')\n   * let values = A.getFeatures('area','volume')\n   */\n  getFeatures: function (features) {\n    if (!(features instanceof Array)) {\n      features = [features];\n    }\n    let result = this.toTriangles().map(function (triPoly) {\n      return triPoly.getTetraFeatures(features);\n    })\n      .reduce(function (pv, v) {\n        return v.map(function (feat, i) {\n          return feat + (pv === 0 ? 0 : pv[i]);\n        });\n      }, 0);\n    return (result.length === 1) ? result[0] : result;\n  },\n  /** @return {Polygon[]} The list of polygons. */\n  toPolygons: function () {\n    return this.polygons;\n  },\n\n  toString: function () {\n    let result = 'CSG solid:\\n';\n    this.polygons.map(function (p) {\n      result += p.toString();\n    });\n    return result;\n  },\n\n  /** returns a compact binary representation of this csg\n   * usually used to transfer CSG objects to/from webworkes\n   * NOTE: very interesting compact format, with a lot of reusable ideas\n   * @returns {Object} compact binary representation of a CSG\n   */\n  toCompactBinary: function () {\n    let csg = this.canonicalized();\n    let numpolygons = csg.polygons.length;\n    let numpolygonvertices = 0;\n\n    let numvertices = 0;\n    let vertexmap = {};\n    let vertices = [];\n\n    let numplanes = 0;\n    let planemap = {};\n    let planes = [];\n\n    let shareds = [];\n    let sharedmap = {};\n    let numshared = 0;\n    // for (let i = 0, iMax = csg.polygons.length; i < iMax; i++) {\n    //  let p = csg.polygons[i];\n    //  for (let j = 0, jMax = p.length; j < jMax; j++) {\n    //      ++numpolygonvertices;\n    //      let vertextag = p[j].getTag();\n    //      if(!(vertextag in vertexmap)) {\n    //          vertexmap[vertextag] = numvertices++;\n    //          vertices.push(p[j]);\n    //      }\n    //  }\n    csg.polygons.map(function (polygon) {\n      // FIXME: why use map if we do not return anything ?\n      // either for... or forEach\n      polygon.vertices.map(function (vertex) {\n        ++numpolygonvertices;\n        let vertextag = vertex.getTag();\n        if (!(vertextag in vertexmap)) {\n          vertexmap[vertextag] = numvertices++;\n          vertices.push(vertex);\n        }\n      });\n\n      let planetag = polygon.plane.getTag();\n      if (!(planetag in planemap)) {\n        planemap[planetag] = numplanes++;\n        planes.push(polygon.plane);\n      }\n      let sharedtag = polygon.shared.getTag();\n      if (!(sharedtag in sharedmap)) {\n        sharedmap[sharedtag] = numshared++;\n        shareds.push(polygon.shared);\n      }\n    });\n\n    let numVerticesPerPolygon = new Uint32Array(numpolygons);\n    let polygonSharedIndexes = new Uint32Array(numpolygons);\n    let polygonVertices = new Uint32Array(numpolygonvertices);\n    let polygonPlaneIndexes = new Uint32Array(numpolygons);\n    let vertexData = new Float64Array(numvertices * 3);\n    let planeData = new Float64Array(numplanes * 4);\n    let polygonVerticesIndex = 0;\n\n    // FIXME: doublecheck : why does it go through the whole polygons again?\n    // can we optimise that ? (perhap due to needing size to init buffers above)\n    for (let polygonindex = 0; polygonindex < numpolygons; ++polygonindex) {\n      let polygon = csg.polygons[polygonindex];\n      numVerticesPerPolygon[polygonindex] = polygon.vertices.length;\n      polygon.vertices.map(function (vertex) {\n        let vertextag = vertex.getTag();\n        let vertexindex = vertexmap[vertextag];\n        polygonVertices[polygonVerticesIndex++] = vertexindex;\n      });\n      let planetag = polygon.plane.getTag();\n      let planeindex = planemap[planetag];\n      polygonPlaneIndexes[polygonindex] = planeindex;\n      let sharedtag = polygon.shared.getTag();\n      let sharedindex = sharedmap[sharedtag];\n      polygonSharedIndexes[polygonindex] = sharedindex;\n    }\n    let verticesArrayIndex = 0;\n    vertices.map(function (vertex) {\n      const pos = vertex.pos;\n      vertexData[verticesArrayIndex++] = pos._x;\n      vertexData[verticesArrayIndex++] = pos._y;\n      vertexData[verticesArrayIndex++] = pos._z;\n    });\n    let planesArrayIndex = 0;\n    planes.map(function (plane) {\n      const normal = plane.normal;\n      planeData[planesArrayIndex++] = normal._x;\n      planeData[planesArrayIndex++] = normal._y;\n      planeData[planesArrayIndex++] = normal._z;\n      planeData[planesArrayIndex++] = plane.w;\n    });\n\n    let result = {\n      'class': 'CSG',\n      numPolygons: numpolygons,\n      numVerticesPerPolygon: numVerticesPerPolygon,\n      polygonPlaneIndexes: polygonPlaneIndexes,\n      polygonSharedIndexes: polygonSharedIndexes,\n      polygonVertices: polygonVertices,\n      vertexData: vertexData,\n      planeData: planeData,\n      shared: shareds\n    };\n    return result;\n  },\n\n  /** returns the triangles of this csg\n   * @returns {Polygons} triangulated polygons\n   */\n  toTriangles: function () {\n    let polygons = [];\n    this.polygons.forEach(function (poly) {\n      let firstVertex = poly.vertices[0];\n      for (let i = poly.vertices.length - 3; i >= 0; i--) {\n        polygons.push(new Polygon(\n          [\n            firstVertex,\n            poly.vertices[i + 1],\n            poly.vertices[i + 2]\n          ],\n          poly.shared,\n          poly.plane));\n      }\n    });\n    return polygons;\n  }\n};\n\nmodule.exports = CSG;\n","const Vector3D = require('./math/Vector3');\nconst Line3D = require('./math/Line3');\nconst Matrix4x4 = require('./math/Matrix4');\nconst OrthoNormalBasis = require('./math/OrthoNormalBasis');\nconst Plane = require('./math/Plane');\n\n// # class Connector\n// A connector allows to attach two objects at predefined positions\n// For example a servo motor and a servo horn:\n// Both can have a Connector called 'shaft'\n// The horn can be moved and rotated such that the two connectors match\n// and the horn is attached to the servo motor at the proper position.\n// Connectors are stored in the properties of a CSG solid so they are\n// ge the same transformations applied as the solid\nconst Connector = function (point, axisvector, normalvector) {\n  this.point = new Vector3D(point);\n  this.axisvector = new Vector3D(axisvector).unit();\n  this.normalvector = new Vector3D(normalvector).unit();\n};\n\nConnector.prototype = {\n  normalized: function () {\n    let axisvector = this.axisvector.unit();\n    // make the normal vector truly normal:\n    let n = this.normalvector.cross(axisvector).unit();\n    let normalvector = axisvector.cross(n);\n    return new Connector(this.point, axisvector, normalvector);\n  },\n\n  transform: function (matrix4x4) {\n    let point = this.point.multiply4x4(matrix4x4);\n    let axisvector = this.point.plus(this.axisvector).multiply4x4(matrix4x4).minus(point);\n    let normalvector = this.point.plus(this.normalvector).multiply4x4(matrix4x4).minus(point);\n    return new Connector(point, axisvector, normalvector);\n  },\n\n  // Get the transformation matrix to connect this Connector to another connector\n  //   other: a Connector to which this connector should be connected\n  //   mirror: false: the 'axis' vectors of the connectors should point in the same direction\n  //           true: the 'axis' vectors of the connectors should point in opposite direction\n  //   normalrotation: degrees of rotation between the 'normal' vectors of the two\n  //                   connectors\n  getTransformationTo: function (other, mirror, normalrotation) {\n    mirror = mirror ? true : false;\n    normalrotation = normalrotation ? Number(normalrotation) : 0;\n    let us = this.normalized();\n    other = other.normalized();\n    // shift to the origin:\n    let transformation = Matrix4x4.translation(this.point.negated());\n    // construct the plane crossing through the origin and the two axes:\n    let axesplane = Plane.anyPlaneFromVector3Ds(\n      new Vector3D(0, 0, 0), us.axisvector, other.axisvector);\n    let axesbasis = new OrthoNormalBasis(axesplane);\n    let angle1 = axesbasis.to2D(us.axisvector).angle();\n    let angle2 = axesbasis.to2D(other.axisvector).angle();\n    let rotation = 180.0 * (angle2 - angle1) / Math.PI;\n    if (mirror) rotation += 180.0;\n    transformation = transformation.multiply(axesbasis.getProjectionMatrix());\n    transformation = transformation.multiply(Matrix4x4.rotationZ(rotation));\n    transformation = transformation.multiply(axesbasis.getInverseProjectionMatrix());\n    let usAxesAligned = us.transform(transformation);\n    // Now we have done the transformation for aligning the axes.\n    // We still need to align the normals:\n    let normalsplane = Plane.fromNormalAndPoint(other.axisvector, new Vector3D(0, 0, 0));\n    let normalsbasis = new OrthoNormalBasis(normalsplane);\n    angle1 = normalsbasis.to2D(usAxesAligned.normalvector).angle();\n    angle2 = normalsbasis.to2D(other.normalvector).angle();\n    rotation = 180.0 * (angle2 - angle1) / Math.PI;\n    rotation += normalrotation;\n    transformation = transformation.multiply(normalsbasis.getProjectionMatrix());\n    transformation = transformation.multiply(Matrix4x4.rotationZ(rotation));\n    transformation = transformation.multiply(normalsbasis.getInverseProjectionMatrix());\n    // and translate to the destination point:\n    transformation = transformation.multiply(Matrix4x4.translation(other.point));\n    // let usAligned = us.transform(transformation);\n    return transformation;\n  },\n\n  axisLine: function () {\n    return new Line3D(this.point, this.axisvector);\n  },\n\n  // creates a new Connector, with the connection point moved in the direction of the axisvector\n  extend: function (distance) {\n    let newpoint = this.point.plus(this.axisvector.unit().times(distance));\n    return new Connector(newpoint, this.axisvector, this.normalvector);\n  }\n};\n\nconst ConnectorList = function (connectors) {\n  this.connectors_ = connectors ? connectors.slice() : [];\n};\n\nConnectorList.defaultNormal = [0, 0, 1];\n\nConnectorList.fromPath2D = function (path2D, arg1, arg2) {\n  if (arguments.length === 3) {\n    return ConnectorList._fromPath2DTangents(path2D, arg1, arg2);\n  } else if (arguments.length === 2) {\n    return ConnectorList._fromPath2DExplicit(path2D, arg1);\n  } else {\n    throw new Error('call with path2D and either 2 direction vectors, or a function returning direction vectors');\n  }\n};\n\n/*\n * calculate the connector axisvectors by calculating the \"tangent\" for path2D.\n * This is undefined for start and end points, so axis for these have to be manually\n * provided.\n */\nConnectorList._fromPath2DTangents = function (path2D, start, end) {\n  // path2D\n  let axis;\n  let pathLen = path2D.points.length;\n  let result = new ConnectorList([new Connector(path2D.points[0],\n    start, ConnectorList.defaultNormal)]);\n  // middle points\n  path2D.points.slice(1, pathLen - 1).forEach(function (p2, i) {\n    axis = path2D.points[i + 2].minus(path2D.points[i]).toVector3D(0);\n    result.appendConnector(new Connector(p2.toVector3D(0), axis,\n      ConnectorList.defaultNormal));\n  }, this);\n  result.appendConnector(new Connector(path2D.points[pathLen - 1], end,\n    ConnectorList.defaultNormal));\n  result.closed = path2D.closed;\n  return result;\n};\n\n/*\n * angleIsh: either a static angle, or a function(point) returning an angle\n */\nConnectorList._fromPath2DExplicit = function (path2D, angleIsh) {\n  function getAngle(angleIsh, pt, i) {\n    if (typeof angleIsh === 'function') {\n      angleIsh = angleIsh(pt, i);\n    }\n    return angleIsh;\n  }\n\n  let result = new ConnectorList(\n    path2D.points.map(function (p2, i) {\n      return new Connector(p2.toVector3D(0),\n        Vector3D.Create(1, 0, 0).rotateZ(getAngle(angleIsh, p2, i)),\n        ConnectorList.defaultNormal);\n    }, this)\n  );\n  result.closed = path2D.closed;\n  return result;\n};\n\nConnectorList.prototype = {\n  setClosed: function (closed) {\n    this.closed = !!closed;\n  },\n  appendConnector: function (conn) {\n    this.connectors_.push(conn);\n  },\n  /*\n   * arguments: cagish: a cag or a function(connector) returning a cag\n   *            closed: whether the 3d path defined by connectors location\n   *              should be closed or stay open\n   *              Note: don't duplicate connectors in the path\n   * TODO: consider an option \"maySelfIntersect\" to close & force union all single segments\n   */\n  followWith: function (cagish) {\n    const CSG = require('./CSG'); // FIXME , circular dependency connectors => CSG => connectors\n\n    this.verify();\n\n    function getCag(cagish, connector) {\n      if (typeof cagish === 'function') {\n        cagish = cagish(connector.point, connector.axisvector, connector.normalvector);\n      }\n      return cagish;\n    }\n\n    let polygons = [];\n    let currCag;\n    let prevConnector = this.connectors_[this.connectors_.length - 1];\n    let prevCag = getCag(cagish, prevConnector);\n    // add walls\n    this.connectors_.forEach(function (connector, notFirst) {\n      currCag = getCag(cagish, connector);\n      if (notFirst || this.closed) {\n        polygons.push.apply(polygons, prevCag._toWallPolygons({\n          toConnector1: prevConnector, toConnector2: connector, cag: currCag\n        }));\n      } else {\n        // it is the first, and shape not closed -> build start wall\n        polygons.push.apply(polygons,\n          currCag._toPlanePolygons({toConnector: connector, flipped: true}));\n      }\n      if (notFirst === this.connectors_.length - 1 && !this.closed) {\n        // build end wall\n        polygons.push.apply(polygons,\n          currCag._toPlanePolygons({toConnector: connector}));\n      }\n      prevCag = currCag;\n      prevConnector = connector;\n    }, this);\n    return CSG.fromPolygons(polygons).reTesselated().canonicalized();\n  },\n  /*\n   * general idea behind these checks: connectors need to have smooth transition from one to another\n   * TODO: add a check that 2 follow-on CAGs are not intersecting\n   */\n  verify: function () {\n    let connI;\n    let connI1;\n    for (let i = 0; i < this.connectors_.length - 1; i++) {\n      connI = this.connectors_[i];\n      connI1 = this.connectors_[i + 1];\n      if (connI1.point.minus(connI.point).dot(connI.axisvector) <= 0) {\n        throw new Error('Invalid ConnectorList. Each connectors position needs to be within a <90deg range of previous connectors axisvector');\n      }\n      if (connI.axisvector.dot(connI1.axisvector) <= 0) {\n        throw new Error('invalid ConnectorList. No neighboring connectors axisvectors may span a >=90deg angle');\n      }\n    }\n  }\n};\n\nmodule.exports = {Connector, ConnectorList};\n","const Vector2D = require('./Vector2');\nconst {getTag} = require('../constants');\n\nconst Vertex = function (pos) {\n  this.pos = pos;\n};\n\nVertex.fromObject = function (obj) {\n  return new Vertex(new Vector2D(obj.pos._x, obj.pos._y));\n};\n\nVertex.prototype = {\n  toString: function () {\n    return '(' + this.pos.x.toFixed(5) + ',' + this.pos.y.toFixed(5) + ')';\n  },\n  getTag: function () {\n    var result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  }\n};\n\nmodule.exports = Vertex;\n","const Vector3D = require('../core/math/Vector3');\nconst Vector2D = require('../core/math/Vector2');\n\n// Parse an option from the options object\n// If the option is not present, return the default value\nconst parseOption = function (options, optionname, defaultvalue) {\n  var result = defaultvalue;\n  if (options && optionname in options) {\n    result = options[optionname];\n  }\n  return result;\n};\n\n// Parse an option and force into a Vector3D. If a scalar is passed it is converted\n// into a vector with equal x,y,z\nconst parseOptionAs3DVector = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  result = new Vector3D(result);\n  return result;\n};\n\nconst parseOptionAs3DVectorList = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  return result.map(function (res) {\n    return new Vector3D(res);\n  });\n};\n\n// Parse an option and force into a Vector2D. If a scalar is passed it is converted\n// into a vector with equal x,y\nconst parseOptionAs2DVector = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  result = new Vector2D(result);\n  return result;\n};\n\nconst parseOptionAsFloat = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  if (typeof (result) === 'string') {\n    result = Number(result);\n  }\n  if (isNaN(result) || typeof (result) !== 'number') {\n    throw new Error('Parameter ' + optionname + ' should be a number');\n  }\n  return result;\n};\n\nconst parseOptionAsInt = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  result = Number(Math.floor(result));\n  if (isNaN(result)) {\n    throw new Error('Parameter ' + optionname + ' should be a number');\n  }\n  return result;\n};\n\nconst parseOptionAsBool = function (options, optionname, defaultvalue) {\n  var result = parseOption(options, optionname, defaultvalue);\n  if (typeof (result) === 'string') {\n    if (result === 'true') result = true;\n    else if (result === 'false') result = false;\n    else if (result === 0) result = false;\n  }\n  result = !!result;\n  return result;\n};\n\nmodule.exports = {\n  parseOption,\n  parseOptionAsInt,\n  parseOptionAsFloat,\n  parseOptionAsBool,\n  parseOptionAs3DVector,\n  parseOptionAs2DVector,\n  parseOptionAs3DVectorList\n};\n","const Vector3D = require('./Vector3');\nconst {EPS} = require('../constants');\nconst {solve2Linear} = require('../utils');\n\n// # class Line3D\n// Represents a line in 3D space\n// direction must be a unit vector\n// point is a random point on the line\nconst Line3D = function (point, direction) {\n  point = new Vector3D(point);\n  direction = new Vector3D(direction);\n  this.point = point;\n  this.direction = direction.unit();\n};\n\nLine3D.fromPoints = function (p1, p2) {\n  p1 = new Vector3D(p1);\n  p2 = new Vector3D(p2);\n  let direction = p2.minus(p1);\n  return new Line3D(p1, direction);\n};\n\nLine3D.fromPlanes = function (p1, p2) {\n  let direction = p1.normal.cross(p2.normal);\n  let l = direction.length();\n  if (l < EPS) {\n    throw new Error('Parallel planes');\n  }\n  direction = direction.times(1.0 / l);\n\n  let mabsx = Math.abs(direction.x);\n  let mabsy = Math.abs(direction.y);\n  let mabsz = Math.abs(direction.z);\n  let origin;\n  if ((mabsx >= mabsy) && (mabsx >= mabsz)) {\n    // direction vector is mostly pointing towards x\n    // find a point p for which x is zero:\n    let r = solve2Linear(p1.normal.y, p1.normal.z, p2.normal.y, p2.normal.z, p1.w, p2.w);\n    origin = new Vector3D(0, r[0], r[1]);\n  } else if ((mabsy >= mabsx) && (mabsy >= mabsz)) {\n    // find a point p for which y is zero:\n    let r = solve2Linear(p1.normal.x, p1.normal.z, p2.normal.x, p2.normal.z, p1.w, p2.w);\n    origin = new Vector3D(r[0], 0, r[1]);\n  } else {\n    // find a point p for which z is zero:\n    let r = solve2Linear(p1.normal.x, p1.normal.y, p2.normal.x, p2.normal.y, p1.w, p2.w);\n    origin = new Vector3D(r[0], r[1], 0);\n  }\n  return new Line3D(origin, direction);\n};\n\nLine3D.prototype = {\n  intersectWithPlane: function (plane) {\n    // plane: plane.normal * p = plane.w\n    // line: p=line.point + labda * line.direction\n    let labda = (plane.w - plane.normal.dot(this.point)) / plane.normal.dot(this.direction);\n    let point = this.point.plus(this.direction.times(labda));\n    return point;\n  },\n\n  clone: function (line) {\n    return new Line3D(this.point.clone(), this.direction.clone());\n  },\n\n  reverse: function () {\n    return new Line3D(this.point.clone(), this.direction.negated());\n  },\n\n  transform: function (matrix4x4) {\n    let newpoint = this.point.multiply4x4(matrix4x4);\n    let pointPlusDirection = this.point.plus(this.direction);\n    let newPointPlusDirection = pointPlusDirection.multiply4x4(matrix4x4);\n    let newdirection = newPointPlusDirection.minus(newpoint);\n    return new Line3D(newpoint, newdirection);\n  },\n\n  closestPointOnLine: function (point) {\n    point = new Vector3D(point);\n    let t = point.minus(this.point).dot(this.direction) / this.direction.dot(this.direction);\n    let closestpoint = this.point.plus(this.direction.times(t));\n    return closestpoint;\n  },\n\n  distanceToPoint: function (point) {\n    point = new Vector3D(point);\n    let closestpoint = this.closestPointOnLine(point);\n    let distancevector = point.minus(closestpoint);\n    let distance = distancevector.length();\n    return distance;\n  },\n\n  equals: function (line3d) {\n    if (!this.direction.equals(line3d.direction)) return false;\n    let distance = this.distanceToPoint(line3d.point);\n    if (distance > EPS) return false;\n    return true;\n  }\n};\n\nmodule.exports = Line3D;\n","const Vector2D = require('./Vector2');\nconst Vertex = require('./Vertex2');\nconst Vertex3 = require('./Vertex3');\nconst Polygon = require('./Polygon3');\nconst {getTag} = require('../constants');\n\nconst Side = function (vertex0, vertex1) {\n  if (!(vertex0 instanceof Vertex)) throw new Error('Assertion failed');\n  if (!(vertex1 instanceof Vertex)) throw new Error('Assertion failed');\n  this.vertex0 = vertex0;\n  this.vertex1 = vertex1;\n};\n\nSide.fromObject = function (obj) {\n  var vertex0 = Vertex.fromObject(obj.vertex0);\n  var vertex1 = Vertex.fromObject(obj.vertex1);\n  return new Side(vertex0, vertex1);\n};\n\nSide._fromFakePolygon = function (polygon) {\n  // this can happen based on union, seems to be residuals -\n  // return null and handle in caller\n  if (polygon.vertices.length < 4) {\n    return null;\n  }\n  var vert1Indices = [];\n  var pts2d = polygon.vertices.filter(function (v, i) {\n    if (v.pos.z > 0) {\n      vert1Indices.push(i);\n      return true;\n    }\n    return false;\n  })\n    .map(function (v) {\n      return new Vector2D(v.pos.x, v.pos.y);\n    });\n  if (pts2d.length !== 2) {\n    throw new Error('Assertion failed: _fromFakePolygon: not enough points found');\n  }\n  var d = vert1Indices[1] - vert1Indices[0];\n  if (d === 1 || d === 3) {\n    if (d === 1) {\n      pts2d.reverse();\n    }\n  } else {\n    throw new Error('Assertion failed: _fromFakePolygon: unknown index ordering');\n  }\n  var result = new Side(new Vertex(pts2d[0]), new Vertex(pts2d[1]));\n  return result;\n};\n\nSide.prototype = {\n  toString: function () {\n    return this.vertex0 + ' -> ' + this.vertex1;\n  },\n\n  toPolygon3D: function (z0, z1) {\n    // console.log(this.vertex0.pos)\n    const vertices = [\n      new Vertex3(this.vertex0.pos.toVector3D(z0)),\n      new Vertex3(this.vertex1.pos.toVector3D(z0)),\n      new Vertex3(this.vertex1.pos.toVector3D(z1)),\n      new Vertex3(this.vertex0.pos.toVector3D(z1))\n    ];\n    return new Polygon(vertices);\n  },\n\n  transform: function (matrix4x4) {\n    var newp1 = this.vertex0.pos.transform(matrix4x4);\n    var newp2 = this.vertex1.pos.transform(matrix4x4);\n    return new Side(new Vertex(newp1), new Vertex(newp2));\n  },\n\n  flipped: function () {\n    return new Side(this.vertex1, this.vertex0);\n  },\n\n  direction: function () {\n    return this.vertex1.pos.minus(this.vertex0.pos);\n  },\n\n  getTag: function () {\n    var result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  },\n\n  lengthSquared: function () {\n    let x = this.vertex1.pos.x - this.vertex0.pos.x;\n    let y = this.vertex1.pos.y - this.vertex0.pos.y;\n    return x * x + y * y;\n  },\n\n  length: function () {\n    return Math.sqrt(this.lengthSquared());\n  }\n};\n\nmodule.exports = Side;\n","const Vector2D = require('./Vector2');\nconst {EPS, angleEPS} = require('../constants');\nconst {parseOptionAs2DVector, parseOptionAsFloat, parseOptionAsInt, parseOptionAsBool} = require('../../api/optionParsers');\nconst {defaultResolution2D} = require('../constants');\nconst Vertex = require('./Vertex2');\nconst Side = require('./Side');\n\n/** Class Path2D\n * Represents a series of points, connected by infinitely thin lines.\n * A path can be open or closed, i.e. additional line between first and last points.\n * The difference between Path2D and CAG is that a path is a 'thin' line, whereas a CAG is an enclosed area.\n * @constructor\n * @param {Vector2D[]} [points=[]] - list of points\n * @param {boolean} [closed=false] - closer of path\n *\n * @example\n * new CSG.Path2D()\n * new CSG.Path2D([[10,10], [-10,10], [-10,-10], [10,-10]], true) // closed\n */\nconst Path2D = function (points, closed) {\n  closed = !!closed;\n  points = points || [];\n  // re-parse the points into Vector2D\n  // and remove any duplicate points\n  let prevpoint = null;\n  if (closed && (points.length > 0)) {\n    prevpoint = new Vector2D(points[points.length - 1]);\n  }\n  let newpoints = [];\n  points.map(function (point) {\n    point = new Vector2D(point);\n    let skip = false;\n    if (prevpoint !== null) {\n      let distance = point.distanceTo(prevpoint);\n      skip = distance < EPS;\n    }\n    if (!skip) newpoints.push(point);\n    prevpoint = point;\n  });\n  this.points = newpoints;\n  this.closed = closed;\n};\n\n/** Construct an arc.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of circle\n * @param {Number} [options.radius=1] - radius of circle\n * @param {Number} [options.startangle=0] - starting angle of the arc, in degrees\n * @param {Number} [options.endangle=360] - ending angle of the arc, in degrees\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @param {Boolean} [options.maketangent=false] - adds line segments at both ends of the arc to ensure that the gradients at the edges are tangent\n * @returns {Path2D} new Path2D object (not closed)\n *\n * @example\n * let path = CSG.Path2D.arc({\n *   center: [5, 5],\n *   radius: 10,\n *   startangle: 90,\n *   endangle: 180,\n *   resolution: 36,\n *   maketangent: true\n * });\n */\nPath2D.arc = function (options) {\n  let center = parseOptionAs2DVector(options, 'center', 0);\n  let radius = parseOptionAsFloat(options, 'radius', 1);\n  let startangle = parseOptionAsFloat(options, 'startangle', 0);\n  let endangle = parseOptionAsFloat(options, 'endangle', 360);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n  let maketangent = parseOptionAsBool(options, 'maketangent', false);\n  // no need to make multiple turns:\n  while (endangle - startangle >= 720) {\n    endangle -= 360;\n  }\n  while (endangle - startangle <= -720) {\n    endangle += 360;\n  }\n  let points = [];\n  let point;\n  let absangledif = Math.abs(endangle - startangle);\n  if (absangledif < angleEPS) {\n    point = Vector2D.fromAngle(startangle / 180.0 * Math.PI).times(radius);\n    points.push(point.plus(center));\n  } else {\n    let numsteps = Math.floor(resolution * absangledif / 360) + 1;\n    let edgestepsize = numsteps * 0.5 / absangledif; // step size for half a degree\n    if (edgestepsize > 0.25) edgestepsize = 0.25;\n    let numstepsMod = maketangent ? (numsteps + 2) : numsteps;\n    for (let i = 0; i <= numstepsMod; i++) {\n      let step = i;\n      if (maketangent) {\n        step = (i - 1) * (numsteps - 2 * edgestepsize) / numsteps + edgestepsize;\n        if (step < 0) step = 0;\n        if (step > numsteps) step = numsteps;\n      }\n      let angle = startangle + step * (endangle - startangle) / numsteps;\n      point = Vector2D.fromAngle(angle / 180.0 * Math.PI).times(radius);\n      points.push(point.plus(center));\n    }\n  }\n  return new Path2D(points, false);\n};\n\nPath2D.prototype = {\n  concat: function (otherpath) {\n    if (this.closed || otherpath.closed) {\n      throw new Error('Paths must not be closed');\n    }\n    let newpoints = this.points.concat(otherpath.points);\n    return new Path2D(newpoints);\n  },\n\n  /**\n   * Get the points that make up the path.\n   * note that this is current internal list of points, not an immutable copy.\n   * @returns {Vector2[]} array of points the make up the path\n   */\n  getPoints: function () {\n    return this.points;\n  },\n\n  /**\n   * Append an point to the end of the path.\n   * @param {Vector2D} point - point to append\n   * @returns {Path2D} new Path2D object (not closed)\n   */\n  appendPoint: function (point) {\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    point = new Vector2D(point); // cast to Vector2D\n    let newpoints = this.points.concat([point]);\n    return new Path2D(newpoints);\n  },\n\n  /**\n   * Append a list of points to the end of the path.\n   * @param {Vector2D[]} points - points to append\n   * @returns {Path2D} new Path2D object (not closed)\n   */\n  appendPoints: function (points) {\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    let newpoints = this.points;\n    points.forEach(function (point) {\n      newpoints.push(new Vector2D(point)); // cast to Vector2D\n    });\n    return new Path2D(newpoints);\n  },\n\n  close: function () {\n    return new Path2D(this.points, true);\n  },\n\n  /**\n   * Determine if the path is a closed or not.\n   * @returns {Boolean} true when the path is closed, otherwise false\n   */\n  isClosed: function () {\n    return this.closed;\n  },\n\n  /**\n   * Determine the overall clockwise or anti-clockwise turn of a path.\n   * See: http://mathworld.wolfram.com/PolygonArea.html\n   * @returns {String} One of ['clockwise', 'counter-clockwise', 'straight'].\n   */\n  getTurn: function () {\n    const points = this.points;\n    let twice_area = 0;\n    let last = points.length - 1;\n    for (let current = 0; current < points.length; last = current++) {\n      twice_area += points[last].x * points[current].y - points[last].y * points[current].x;\n    }\n    if (twice_area > 0) {\n      return 'clockwise';\n    } else if (twice_area < 0) {\n      return 'counter-clockwise';\n    } else {\n      return 'straight';\n    }\n  },\n\n  // Extrude the path by following it with a rectangle (upright, perpendicular to the path direction)\n  // Returns a CSG solid\n  //   width: width of the extrusion, in the z=0 plane\n  //   height: height of the extrusion in the z direction\n  //   resolution: number of segments per 360 degrees for the curve in a corner\n  rectangularExtrude: function (width, height, resolution) {\n    let cag = this.expandToCAG(width / 2, resolution);\n    let result = cag.extrude({\n      offset: [0, 0, height]\n    });\n    return result;\n  },\n\n  // Expand the path to a CAG\n  // This traces the path with a circle with radius pathradius\n  expandToCAG: function (pathradius, resolution) {\n    const CAG = require('../CAG'); // FIXME: cyclic dependencies CAG => PATH2 => CAG\n    let sides = [];\n    let numpoints = this.points.length;\n    let startindex = 0;\n    if (this.closed && (numpoints > 2)) startindex = -1;\n    let prevvertex;\n    for (let i = startindex; i < numpoints; i++) {\n      let pointindex = i;\n      if (pointindex < 0) pointindex = numpoints - 1;\n      let point = this.points[pointindex];\n      let vertex = new Vertex(point);\n      if (i > startindex) {\n        let side = new Side(prevvertex, vertex);\n        sides.push(side);\n      }\n      prevvertex = vertex;\n    }\n    let shellcag = CAG.fromSides(sides);\n    let expanded = shellcag.expandedShell(pathradius, resolution);\n    return expanded;\n  },\n\n  innerToCAG: function () {\n    const CAG = require('../CAG'); // FIXME: cyclic dependencies CAG => PATH2 => CAG\n    if (!this.closed) throw new Error('The path should be closed!');\n    return CAG.fromPoints(this.points);\n  },\n\n  transform: function (matrix4x4) {\n    let newpoints = this.points.map(function (point) {\n      return point.multiply4x4(matrix4x4);\n    });\n    return new Path2D(newpoints, this.closed);\n  },\n\n  /**\n   * Append a Bezier curve to the end of the path, using the control points to transition the curve through start and end points.\n   * <br>\n   * The Bézier curve starts at the last point in the path,\n   * and ends at the last given control point. Other control points are intermediate control points.\n   * <br>\n   * The first control point may be null to ensure a smooth transition occurs. In this case,\n   * the second to last control point of the path is mirrored into the control points of the Bezier curve.\n   * In other words, the trailing gradient of the path matches the new gradient of the curve.\n   * @param {Vector2D[]} controlpoints - list of control points\n   * @param {Object} [options] - options for construction\n   * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n   * @returns {Path2D} new Path2D object (not closed)\n   *\n   * @example\n   * let p5 = new CSG.Path2D([[10,-20]],false);\n   * p5 = p5.appendBezier([[10,-10],[25,-10],[25,-20]]);\n   * p5 = p5.appendBezier([[25,-30],[40,-30],[40,-20]]);\n   */\n  appendBezier: function (controlpoints, options) {\n    if (arguments.length < 2) {\n      options = {};\n    }\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    if (!(controlpoints instanceof Array)) {\n      throw new Error('appendBezier: should pass an array of control points');\n    }\n    if (controlpoints.length < 1) {\n      throw new Error('appendBezier: need at least 1 control point');\n    }\n    if (this.points.length < 1) {\n      throw new Error('appendBezier: path must already contain a point (the endpoint of the path is used as the starting point for the bezier curve)');\n    }\n    let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n    if (resolution < 4) resolution = 4;\n    let factorials = [];\n    let controlpointsParsed = [];\n    controlpointsParsed.push(this.points[this.points.length - 1]); // start at the previous end point\n    for (let i = 0; i < controlpoints.length; ++i) {\n      let p = controlpoints[i];\n      if (p === null) {\n        // we can pass null as the first control point. In that case a smooth gradient is ensured:\n        if (i !== 0) {\n          throw new Error('appendBezier: null can only be passed as the first control point');\n        }\n        if (controlpoints.length < 2) {\n          throw new Error('appendBezier: null can only be passed if there is at least one more control point');\n        }\n        let lastBezierControlPoint;\n        if ('lastBezierControlPoint' in this) {\n          lastBezierControlPoint = this.lastBezierControlPoint;\n        } else {\n          if (this.points.length < 2) {\n            throw new Error('appendBezier: null is passed as a control point but this requires a previous bezier curve or at least two points in the existing path');\n          }\n          lastBezierControlPoint = this.points[this.points.length - 2];\n        }\n        // mirror the last bezier control point:\n        p = this.points[this.points.length - 1].times(2).minus(lastBezierControlPoint);\n      } else {\n        p = new Vector2D(p); // cast to Vector2D\n      }\n      controlpointsParsed.push(p);\n    }\n    let bezierOrder = controlpointsParsed.length - 1;\n    let fact = 1;\n    for (let i = 0; i <= bezierOrder; ++i) {\n      if (i > 0) fact *= i;\n      factorials.push(fact);\n    }\n    let binomials = [];\n    for (let i = 0; i <= bezierOrder; ++i) {\n      let binomial = factorials[bezierOrder] / (factorials[i] * factorials[bezierOrder - i]);\n      binomials.push(binomial);\n    }\n    let getPointForT = function (t) {\n      let t_k = 1; // = pow(t,k)\n      let one_minus_t_n_minus_k = Math.pow(1 - t, bezierOrder); // = pow( 1-t, bezierOrder - k)\n      let inv_1_minus_t = (t !== 1) ? (1 / (1 - t)) : 1;\n      let point = new Vector2D(0, 0);\n      for (let k = 0; k <= bezierOrder; ++k) {\n        if (k === bezierOrder) one_minus_t_n_minus_k = 1;\n        let bernstein_coefficient = binomials[k] * t_k * one_minus_t_n_minus_k;\n        point = point.plus(controlpointsParsed[k].times(bernstein_coefficient));\n        t_k *= t;\n        one_minus_t_n_minus_k *= inv_1_minus_t;\n      }\n      return point;\n    };\n    let newpoints = [];\n    let newpoints_t = [];\n    let numsteps = bezierOrder + 1;\n    for (let i = 0; i < numsteps; ++i) {\n      let t = i / (numsteps - 1);\n      let point = getPointForT(t);\n      newpoints.push(point);\n      newpoints_t.push(t);\n    }\n    // subdivide each segment until the angle at each vertex becomes small enough:\n    let subdivideBase = 1;\n    let maxangle = Math.PI * 2 / resolution; // segments may have differ no more in angle than this\n    let maxsinangle = Math.sin(maxangle);\n    while (subdivideBase < newpoints.length - 1) {\n      let dir1 = newpoints[subdivideBase].minus(newpoints[subdivideBase - 1]).unit();\n      let dir2 = newpoints[subdivideBase + 1].minus(newpoints[subdivideBase]).unit();\n      let sinangle = dir1.cross(dir2); // this is the sine of the angle\n      if (Math.abs(sinangle) > maxsinangle) {\n        // angle is too big, we need to subdivide\n        let t0 = newpoints_t[subdivideBase - 1];\n        let t1 = newpoints_t[subdivideBase + 1];\n        let t0_new = t0 + (t1 - t0) * 1 / 3;\n        let t1_new = t0 + (t1 - t0) * 2 / 3;\n        let point0_new = getPointForT(t0_new);\n        let point1_new = getPointForT(t1_new);\n        // remove the point at subdivideBase and replace with 2 new points:\n        newpoints.splice(subdivideBase, 1, point0_new, point1_new);\n        newpoints_t.splice(subdivideBase, 1, t0_new, t1_new);\n        // re - evaluate the angles, starting at the previous junction since it has changed:\n        subdivideBase--;\n        if (subdivideBase < 1) subdivideBase = 1;\n      } else {\n        ++subdivideBase;\n      }\n    }\n    // append to the previous points, but skip the first new point because it is identical to the last point:\n    newpoints = this.points.concat(newpoints.slice(1));\n    let result = new Path2D(newpoints);\n    result.lastBezierControlPoint = controlpointsParsed[controlpointsParsed.length - 2];\n    return result;\n  },\n\n  /**\n   * Append an arc to the end of the path.\n   * This implementation follows the SVG arc specs. For the details see\n   * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n   * @param {Vector2D} endpoint - end point of arc\n   * @param {Object} [options] - options for construction\n   * @param {Number} [options.radius=0] - radius of arc (X and Y), see also xradius and yradius\n   * @param {Number} [options.xradius=0] - X radius of arc, see also radius\n   * @param {Number} [options.yradius=0] - Y radius of arc, see also radius\n   * @param {Number} [options.xaxisrotation=0] -  rotation (in degrees) of the X axis of the arc with respect to the X axis of the coordinate system\n   * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n   * @param {Boolean} [options.clockwise=false] - draw an arc clockwise with respect to the center point\n   * @param {Boolean} [options.large=false] - draw an arc longer than 180 degrees\n   * @returns {Path2D} new Path2D object (not closed)\n   *\n   * @example\n   * let p1 = new CSG.Path2D([[27.5,-22.96875]],false);\n   * p1 = p1.appendPoint([27.5,-3.28125]);\n   * p1 = p1.appendArc([12.5,-22.96875],{xradius: 15,yradius: -19.6875,xaxisrotation: 0,clockwise: false,large: false});\n   * p1 = p1.close();\n   */\n  appendArc: function (endpoint, options) {\n    let decimals = 100000;\n    if (arguments.length < 2) {\n      options = {};\n    }\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    if (this.points.length < 1) {\n      throw new Error('appendArc: path must already contain a point (the endpoint of the path is used as the starting point for the arc)');\n    }\n    let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n    if (resolution < 4) resolution = 4;\n    let xradius, yradius;\n    if (('xradius' in options) || ('yradius' in options)) {\n      if ('radius' in options) {\n        throw new Error('Should either give an xradius and yradius parameter, or a radius parameter');\n      }\n      xradius = parseOptionAsFloat(options, 'xradius', 0);\n      yradius = parseOptionAsFloat(options, 'yradius', 0);\n    } else {\n      xradius = parseOptionAsFloat(options, 'radius', 0);\n      yradius = xradius;\n    }\n    let xaxisrotation = parseOptionAsFloat(options, 'xaxisrotation', 0);\n    let clockwise = parseOptionAsBool(options, 'clockwise', false);\n    let largearc = parseOptionAsBool(options, 'large', false);\n    let startpoint = this.points[this.points.length - 1];\n    endpoint = new Vector2D(endpoint);\n    // round to precision in order to have determinate calculations\n    xradius = Math.round(xradius * decimals) / decimals;\n    yradius = Math.round(yradius * decimals) / decimals;\n    endpoint = new Vector2D(Math.round(endpoint.x * decimals) / decimals, Math.round(endpoint.y * decimals) / decimals);\n\n    let sweepFlag = !clockwise;\n    let newpoints = [];\n    if ((xradius === 0) || (yradius === 0)) {\n      // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes:\n      // If rx = 0 or ry = 0, then treat this as a straight line from (x1, y1) to (x2, y2) and stop\n      newpoints.push(endpoint);\n    } else {\n      xradius = Math.abs(xradius);\n      yradius = Math.abs(yradius);\n\n      // see http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes :\n      let phi = xaxisrotation * Math.PI / 180.0;\n      let cosphi = Math.cos(phi);\n      let sinphi = Math.sin(phi);\n      let minushalfdistance = startpoint.minus(endpoint).times(0.5);\n      // F.6.5.1:\n      // round to precision in order to have determinate calculations\n      let x = Math.round((cosphi * minushalfdistance.x + sinphi * minushalfdistance.y) * decimals) / decimals;\n      let y = Math.round((-sinphi * minushalfdistance.x + cosphi * minushalfdistance.y) * decimals) / decimals;\n      let startTranslated = new Vector2D(x, y);\n      // F.6.6.2:\n      let biglambda = (startTranslated.x * startTranslated.x) / (xradius * xradius) + (startTranslated.y * startTranslated.y) / (yradius * yradius);\n      if (biglambda > 1.0) {\n        // F.6.6.3:\n        let sqrtbiglambda = Math.sqrt(biglambda);\n        xradius *= sqrtbiglambda;\n        yradius *= sqrtbiglambda;\n        // round to precision in order to have determinate calculations\n        xradius = Math.round(xradius * decimals) / decimals;\n        yradius = Math.round(yradius * decimals) / decimals;\n      }\n      // F.6.5.2:\n      let multiplier1 = Math.sqrt((xradius * xradius * yradius * yradius - xradius * xradius * startTranslated.y * startTranslated.y - yradius * yradius * startTranslated.x * startTranslated.x) / (xradius * xradius * startTranslated.y * startTranslated.y + yradius * yradius * startTranslated.x * startTranslated.x));\n      if (sweepFlag === largearc) multiplier1 = -multiplier1;\n      let centerTranslated = new Vector2D(xradius * startTranslated.y / yradius, -yradius * startTranslated.x / xradius).times(multiplier1);\n      // F.6.5.3:\n      let center = new Vector2D(cosphi * centerTranslated.x - sinphi * centerTranslated.y, sinphi * centerTranslated.x + cosphi * centerTranslated.y).plus((startpoint.plus(endpoint)).times(0.5));\n      // F.6.5.5:\n      let vec1 = new Vector2D((startTranslated.x - centerTranslated.x) / xradius, (startTranslated.y - centerTranslated.y) / yradius);\n      let vec2 = new Vector2D((-startTranslated.x - centerTranslated.x) / xradius, (-startTranslated.y - centerTranslated.y) / yradius);\n      let theta1 = vec1.angleRadians();\n      let theta2 = vec2.angleRadians();\n      let deltatheta = theta2 - theta1;\n      deltatheta = deltatheta % (2 * Math.PI);\n      if ((!sweepFlag) && (deltatheta > 0)) {\n        deltatheta -= 2 * Math.PI;\n      } else if ((sweepFlag) && (deltatheta < 0)) {\n        deltatheta += 2 * Math.PI;\n      }\n\n      // Ok, we have the center point and angle range (from theta1, deltatheta radians) so we can create the ellipse\n      let numsteps = Math.ceil(Math.abs(deltatheta) / (2 * Math.PI) * resolution) + 1;\n      if (numsteps < 1) numsteps = 1;\n      for (let step = 1; step <= numsteps; step++) {\n        let theta = theta1 + step / numsteps * deltatheta;\n        let costheta = Math.cos(theta);\n        let sintheta = Math.sin(theta);\n        // F.6.3.1:\n        let point = new Vector2D(cosphi * xradius * costheta - sinphi * yradius * sintheta, sinphi * xradius * costheta + cosphi * yradius * sintheta).plus(center);\n        newpoints.push(point);\n      }\n    }\n    newpoints = this.points.concat(newpoints);\n    let result = new Path2D(newpoints);\n    return result;\n  }\n};\n\nmodule.exports = Path2D;\n","/*\n## License\n\nCopyright (c) 2014 bebbi (elghatta@gmail.com)\nCopyright (c) 2013 Eduard Bespalov (edwbes@gmail.com)\nCopyright (c) 2012 Joost Nieuwenhuijse (joost@newhouse.nl)\nCopyright (c) 2011 Evan Wallace (http://evanw.github.com/csg.js/)\nCopyright (c) 2012 Alexandre Girard (https://github.com/alx)\n\nAll code released under MIT license\n\n## Overview\n\nFor an overview of the CSG process see the original csg.js code:\nhttp://evanw.github.com/csg.js/\n\nCSG operations through BSP trees suffer from one problem: heavy fragmentation\nof polygons. If two CSG solids of n polygons are unified, the resulting solid may have\nin the order of n*n polygons, because each polygon is split by the planes of all other\npolygons. After a few operations the number of polygons explodes.\n\nThis version of CSG.js solves the problem in 3 ways:\n\n1. Every polygon split is recorded in a tree (CSG.PolygonTreeNode). This is a separate\ntree, not to be confused with the CSG tree. If a polygon is split into two parts but in\nthe end both fragments have not been discarded by the CSG operation, we can retrieve\nthe original unsplit polygon from the tree, instead of the two fragments.\n\nThis does not completely solve the issue though: if a polygon is split multiple times\nthe number of fragments depends on the order of subsequent splits, and we might still\nend up with unncessary splits:\nSuppose a polygon is first split into A and B, and then into A1, B1, A2, B2. Suppose B2 is\ndiscarded. We will end up with 2 polygons: A and B1. Depending on the actual split boundaries\nwe could still have joined A and B1 into one polygon. Therefore a second approach is used as well:\n\n2. After CSG operations all coplanar polygon fragments are joined by a retesselating\noperation. See CSG.reTesselated(). Retesselation is done through a\nlinear sweep over the polygon surface. The sweep line passes over the y coordinates\nof all vertices in the polygon. Polygons are split at each sweep line, and the fragments\nare joined horizontally and vertically into larger polygons (making sure that we\nwill end up with convex polygons).\nThis still doesn't solve the problem completely: due to floating point imprecisions\nwe may end up with small gaps between polygons, and polygons may not be exactly coplanar\nanymore, and as a result the retesselation algorithm may fail to join those polygons.\nTherefore:\n\n3. A canonicalization algorithm is implemented: it looks for vertices that have\napproximately the same coordinates (with a certain tolerance, say 1e-5) and replaces\nthem with the same vertex. If polygons share a vertex they will actually point to the\nsame CSG.Vertex instance. The same is done for polygon planes. See CSG.canonicalized().\n\nPerformance improvements to the original CSG.js:\n\nReplaced the flip() and invert() methods by flipped() and inverted() which don't\nmodify the source object. This allows to get rid of all clone() calls, so that\nmultiple polygons can refer to the same CSG.Plane instance etc.\n\nThe original union() used an extra invert(), clipTo(), invert() sequence just to remove the\ncoplanar front faces from b; this is now combined in a single b.clipTo(a, true) call.\n\nDetection whether a polygon is in front or in back of a plane: for each polygon\nwe are caching the coordinates of the bounding sphere. If the bounding sphere is\nin front or in back of the plane we don't have to check the individual vertices\nanymore.\n\nOther additions to the original CSG.js:\n\nCSG.Vector class has been renamed into CSG.Vector3D\n\nClasses for 3D lines, 2D vectors, 2D lines, and methods to find the intersection of\na line and a plane etc.\n\nTransformations: CSG.transform(), CSG.translate(), CSG.rotate(), CSG.scale()\n\nExpanding or contracting a solid: CSG.expand() and CSG.contract(). Creates nice\nsmooth corners.\n\nThe vertex normal has been removed since it complicates retesselation. It's not needed\nfor solid CAD anyway.\n\n*/\n\nconst {addTransformationMethodsToPrototype, addCenteringToPrototype} = require('./core/mutators');\nlet CSG = require('./core/CSG');\nlet CAG = require('./core/CAG');\n\n// FIXME: how many are actual usefull to be exposed as API ?? looks like a code smell\nconst {\n  _CSGDEBUG,\n  defaultResolution2D,\n  defaultResolution3D,\n  EPS,\n  angleEPS,\n  areaEPS,\n  all,\n  top,\n  bottom,\n  left,\n  right,\n  front,\n  back,\n  staticTag,\n  getTag\n} = require('./core/constants');\n\nCSG._CSGDEBUG = _CSGDEBUG;\nCSG.defaultResolution2D = defaultResolution2D;\nCSG.defaultResolution3D = defaultResolution3D;\nCSG.EPS = EPS;\nCSG.angleEPS = angleEPS;\nCSG.areaEPS = areaEPS;\nCSG.all = all;\nCSG.top = top;\nCSG.bottom = bottom;\nCSG.left = left;\nCSG.right = right;\nCSG.front = front;\nCSG.back = back;\nCSG.staticTag = staticTag;\nCSG.getTag = getTag;\n\n// eek ! all this is kept for backwards compatibility...for now\nCSG.Vector2D = require('./core/math/Vector2');\nCSG.Vector3D = require('./core/math/Vector3');\nCSG.Vertex = require('./core/math/Vertex3');\nCAG.Vertex = require('./core/math/Vertex2');\nCSG.Plane = require('./core/math/Plane');\nCSG.Polygon = require('./core/math/Polygon3');\nCSG.Polygon2D = require('./core/math/Polygon2');\nCSG.Line2D = require('./core/math/Line2');\nCSG.Line3D = require('./core/math/Line3');\nCSG.Path2D = require('./core/math/Path2');\nCSG.OrthoNormalBasis = require('./core/math/OrthoNormalBasis');\nCSG.Matrix4x4 = require('./core/math/Matrix4');\n\nCAG.Side = require('./core/math/Side');\n\nCSG.Connector = require('./core/connectors').Connector;\nCSG.ConnectorList = require('./core/connectors').ConnectorList;\nCSG.Properties = require('./core/Properties');\n\nconst {circle, ellipse, rectangle, roundedRectangle} = require('./api/primitives2d');\nconst {sphere, cube, roundedCube, cylinder, roundedCylinder, cylinderElliptic, polyhedron} = require('./api/primitives3d');\n\nCSG.sphere = sphere;\nCSG.cube = cube;\nCSG.roundedCube = roundedCube;\nCSG.cylinder = cylinder;\nCSG.roundedCylinder = roundedCylinder;\nCSG.cylinderElliptic = cylinderElliptic;\nCSG.polyhedron = polyhedron;\n\nCAG.circle = circle;\nCAG.ellipse = ellipse;\nCAG.rectangle = rectangle;\nCAG.roundedRectangle = roundedRectangle;\n\n// injecting factories\nconst {fromPolygons, fromCompactBinary, fromObject, fromSlices} = require('./core/CSGFactories');\nCSG.fromCompactBinary = fromCompactBinary;\nCSG.fromObject = fromObject;\nCSG.fromSlices = fromSlices;\nCSG.fromPolygons = fromPolygons;\n\nconst CAGFactories = require('./core/CAGFactories');\nCAG.fromSides = CAGFactories.fromSides;\nCAG.fromObject = CAGFactories.fromObject;\nCAG.fromPoints = CAGFactories.fromPoints;\nCAG.fromPointsNoCheck = CAGFactories.fromPointsNoCheck;\nCAG.fromPath2 = CAGFactories.fromPath2;\nCAG.fromFakeCSG = CAGFactories.fromFakeCSG;\nCAG.fromCompactBinary = CAGFactories.fromCompactBinary;\n\n/// ////////////////////////////////////\n// option parsers\nconst optionsParsers = require('./api/optionParsers');\n\n// ////////////////////////////////////\naddTransformationMethodsToPrototype(CSG.prototype);\naddTransformationMethodsToPrototype(CSG.Vector2D.prototype);\naddTransformationMethodsToPrototype(CSG.Vector3D.prototype);\naddTransformationMethodsToPrototype(CSG.Vertex.prototype);\naddTransformationMethodsToPrototype(CSG.Plane.prototype);\naddTransformationMethodsToPrototype(CSG.Polygon.prototype);\naddTransformationMethodsToPrototype(CSG.Line2D.prototype);\naddTransformationMethodsToPrototype(CSG.Line3D.prototype);\naddTransformationMethodsToPrototype(CSG.Path2D.prototype);\naddTransformationMethodsToPrototype(CSG.OrthoNormalBasis.prototype);\naddTransformationMethodsToPrototype(CSG.Connector.prototype);\n\naddTransformationMethodsToPrototype(CAG.prototype);\naddTransformationMethodsToPrototype(CAG.Side.prototype);\naddTransformationMethodsToPrototype(CAG.Vertex.prototype);\n\nCSG.parseOptionAs2DVector = optionsParsers.parseOptionAs3DVector;\nCSG.parseOptionAs3DVector = optionsParsers.parseOptionAs3DVector;\nCSG.parseOptionAs3DVectorList = optionsParsers.parseOptionAs3DVectorList;\nCSG.parseOptionAsBool = optionsParsers.parseOptionAsBool;\nCSG.parseOptionAsFloat = optionsParsers.parseOptionAsFloat;\nCSG.parseOptionAsInt = optionsParsers.parseOptionAsInt;\n// this is needed for now, otherwise there are missing features in Polygon2D\nCSG.Polygon2D.prototype = CAG.prototype;\n\n// utilities\nconst {isCAG, isCSG} = require('./core/utils');\n\nconst globalApi = Object.assign({}, {CSG, CAG}, optionsParsers, {isCAG, isCSG});\n\nmodule.exports = globalApi;\n","const Vector2D = require('./Vector2');\nconst {solve2Linear} = require('../utils');\n\n/**  class Line2D\n * Represents a directional line in 2D space\n * A line is parametrized by its normal vector (perpendicular to the line, rotated 90 degrees counter clockwise)\n * and w. The line passes through the point <normal>.times(w).\n * Equation: p is on line if normal.dot(p)==w\n * @param {Vector2D} normal normal must be a unit vector!\n * @returns {Line2D}\n */\nconst Line2D = function (normal, w) {\n  normal = new Vector2D(normal);\n  w = parseFloat(w);\n  let l = normal.length();\n  // normalize:\n  w *= l;\n  normal = normal.times(1.0 / l);\n  this.normal = normal;\n  this.w = w;\n};\n\nLine2D.fromPoints = function (p1, p2) {\n  p1 = new Vector2D(p1);\n  p2 = new Vector2D(p2);\n  let direction = p2.minus(p1);\n  let normal = direction.normal().negated().unit();\n  let w = p1.dot(normal);\n  return new Line2D(normal, w);\n};\n\nLine2D.prototype = {\n  // same line but opposite direction:\n  reverse: function () {\n    return new Line2D(this.normal.negated(), -this.w);\n  },\n\n  equals: function (l) {\n    return (l.normal.equals(this.normal) && (l.w === this.w));\n  },\n\n  origin: function () {\n    return this.normal.times(this.w);\n  },\n\n  direction: function () {\n    return this.normal.normal();\n  },\n\n  xAtY: function (y) {\n    // (py == y) && (normal * p == w)\n    // -> px = (w - normal._y * y) / normal.x\n    let x = (this.w - this.normal._y * y) / this.normal.x;\n    return x;\n  },\n\n  absDistanceToPoint: function (point) {\n    point = new Vector2D(point);\n    let pointProjected = point.dot(this.normal);\n    let distance = Math.abs(pointProjected - this.w);\n    return distance;\n  },\n  /* FIXME: has error - origin is not defined, the method is never used\n   closestPoint: function(point) {\n       point = new Vector2D(point);\n       let vector = point.dot(this.direction());\n       return origin.plus(vector);\n   },\n   */\n\n  // intersection between two lines, returns point as Vector2D\n  intersectWithLine: function (line2d) {\n    let point = solve2Linear(this.normal.x, this.normal.y, line2d.normal.x, line2d.normal.y, this.w, line2d.w);\n    point = new Vector2D(point); // make  vector2d\n    return point;\n  },\n\n  transform: function (matrix4x4) {\n    let origin = new Vector2D(0, 0);\n    let pointOnPlane = this.normal.times(this.w);\n    let neworigin = origin.multiply4x4(matrix4x4);\n    let neworiginPlusNormal = this.normal.multiply4x4(matrix4x4);\n    let newnormal = neworiginPlusNormal.minus(neworigin);\n    let newpointOnPlane = pointOnPlane.multiply4x4(matrix4x4);\n    let neww = newnormal.dot(newpointOnPlane);\n    return new Line2D(newnormal, neww);\n  }\n};\n\nmodule.exports = Line2D;\n","// boolean operations\n\n// FIXME should this be lazy ? in which case, how do we deal with 2D/3D combined\n// TODO we should have an option to set behaviour as first parameter\n\nexport {union} from './union';\nexport {difference} from './difference';\nexport {intersection} from './intersection';\n","const {EPS, defaultResolution3D} = require('../core/constants');\nconst OrthoNormalBasis = require('../core/math/OrthoNormalBasis');\nconst {parseOptionAs3DVector, parseOptionAsBool, parseOptionAsFloat, parseOptionAsInt} = require('./optionParsers');\nconst Vector3D = require('../core/math/Vector3');\nconst Vector2D = require('../core/math/Vector2');\nconst Matrix4 = require('../core/math/Matrix4');\nconst Path2D = require('../core/math/Path2');\nconst {Connector} = require('../core/connectors');\nconst {fromPolygons} = require('../core/CSGFactories');\nconst {cagToPointsArray, clamp, rightMultiply1x3VectorToArray, polygonFromPoints} = require('./helpers');\nconst {fromPoints} = require('../core/CAGFactories');\n\n/** extrude the CAG in a certain plane.\n * Giving just a plane is not enough, multiple different extrusions in the same plane would be possible\n * by rotating around the plane's origin. An additional right-hand vector should be specified as well,\n * and this is exactly a OrthoNormalBasis.\n * @param  {CAG} cag the cag to extrude\n * @param  {Orthonormalbasis} orthonormalbasis characterizes the plane in which to extrude\n * @param  {Float} depth thickness of the extruded shape. Extrusion is done upwards from the plane\n *  (unless symmetrical option is set, see below)\n * @param  {Object} [options] - options for construction\n * @param {Boolean} [options.symmetrical=true] - extrude symmetrically in two directions about the plane\n */\nconst extrudeInOrthonormalBasis = function (cag, orthonormalbasis, depth, options) {\n  // first extrude in the regular Z plane:\n  if (!(orthonormalbasis instanceof OrthoNormalBasis)) {\n    throw new Error('extrudeInPlane: the first parameter should be a OrthoNormalBasis');\n  }\n  let extruded = cag.extrude({\n    offset: [0, 0, depth]\n  });\n  if (parseOptionAsBool(options, 'symmetrical', false)) {\n    extruded = extruded.translate([0, 0, -depth / 2]);\n  }\n  let matrix = orthonormalbasis.getInverseProjectionMatrix();\n  extruded = extruded.transform(matrix);\n  return extruded;\n};\n\n/** Extrude in a standard cartesian plane, specified by two axis identifiers. Each identifier can be\n * one of [\"X\",\"Y\",\"Z\",\"-X\",\"-Y\",\"-Z\"]\n * The 2d x axis will map to the first given 3D axis, the 2d y axis will map to the second.\n * See OrthoNormalBasis.GetCartesian for details.\n * @param  {CAG} cag the cag to extrude\n * @param  {String} axis1 the first axis\n * @param  {String} axis2 the second axis\n * @param  {Float} depth thickness of the extruded shape. Extrusion is done upwards from the plane\n * @param  {Object} [options] - options for construction\n * @param {Boolean} [options.symmetrical=true] - extrude symmetrically in two directions about the plane\n */\nconst extrudeInPlane = function (cag, axis1, axis2, depth, options) {\n  return extrudeInOrthonormalBasis(cag, OrthoNormalBasis.GetCartesian(axis1, axis2), depth, options);\n};\n\n/** linear extrusion of 2D shape, with optional twist\n * @param  {CAG} cag the cag to extrude\n * @param  {Object} [options] - options for construction\n * @param {Array} [options.offset=[0,0,1]] - The 2d shape is placed in in z=0 plane and extruded into direction <offset>\n * (a 3D vector as a 3 component array)\n * @param {Boolean} [options.twiststeps=defaultResolution3D] - twiststeps determines the resolution of the twist (should be >= 1)\n * @param {Boolean} [options.twistangle=0] - twistangle The final face is rotated <twistangle> degrees. Rotation is done around the origin of the 2d shape (i.e. x=0, y=0)\n * @returns {CSG} the extrude shape, as a CSG object\n * @example extruded=cag.extrude({offset: [0,0,10], twistangle: 360, twiststeps: 100});\n */\nconst extrude = function (cag, options) {\n  const CSG = require('../core/CSG'); // FIXME: circular dependencies CAG=>CSG=>CAG\n  if (cag.sides.length === 0) {\n    // empty! : FIXME: should this throw ?\n    return new CSG();\n  }\n  let offsetVector = parseOptionAs3DVector(options, 'offset', [0, 0, 1]);\n  let twistangle = parseOptionAsFloat(options, 'twistangle', 0);\n  let twiststeps = parseOptionAsInt(options, 'twiststeps', defaultResolution3D);\n  if (offsetVector.z === 0) {\n    throw new Error('offset cannot be orthogonal to Z axis');\n  }\n  if (twistangle === 0 || twiststeps < 1) {\n    twiststeps = 1;\n  }\n  let normalVector = Vector3D.Create(0, 1, 0);\n\n  let polygons = [];\n  // bottom and top\n  polygons = polygons.concat(cag._toPlanePolygons({\n      translation: [0, 0, 0],\n      normalVector: normalVector,\n      flipped: !(offsetVector.z < 0)\n    }\n  ));\n  polygons = polygons.concat(cag._toPlanePolygons({\n    translation: offsetVector,\n    normalVector: normalVector.rotateZ(twistangle),\n    flipped: offsetVector.z < 0\n  }));\n  // walls\n  for (let i = 0; i < twiststeps; i++) {\n    let c1 = new Connector(offsetVector.times(i / twiststeps), [0, 0, offsetVector.z],\n      normalVector.rotateZ(i * twistangle / twiststeps));\n    let c2 = new Connector(offsetVector.times((i + 1) / twiststeps), [0, 0, offsetVector.z],\n      normalVector.rotateZ((i + 1) * twistangle / twiststeps));\n    polygons = polygons.concat(cag._toWallPolygons({toConnector1: c1, toConnector2: c2}, i));\n  }\n\n  return fromPolygons(polygons);\n};\n\n// THIS IS AN OLD untested !!! version of rotate extrude\n/** Extrude to into a 3D solid by rotating the origin around the Y axis.\n * (and turning everything into XY plane)\n * @param {Object} options - options for construction\n * @param {Number} [options.angle=360] - angle of rotation\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n */\nconst rotateExtrude = function (cag, options) {\n  if (options === undefined) {\n    options = {};\n  }\n  let alpha = parseOptionAsFloat(options, 'angle', 360);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n\n  alpha = alpha > 360 ? alpha % 360 : alpha;\n  let origin = [0, 0, 0];\n  let axisV = Vector3D.Create(0, 1, 0);\n  let normalV = [0, 0, 1];\n  let polygons = [];\n  // planes only needed if alpha > 0\n  let connS = new Connector(origin, axisV, normalV);\n  if (alpha > 0 && alpha < 360) {\n    // we need to rotate negative to satisfy wall function condition of\n    // building in the direction of axis vector\n    let connE = new Connector(origin, axisV.rotateZ(-alpha), normalV);\n    polygons = polygons.concat(\n      cag._toPlanePolygons({toConnector: connS, flipped: true}));\n    polygons = polygons.concat(\n      cag._toPlanePolygons({toConnector: connE}));\n  }\n  let connT1 = connS;\n  let connT2;\n  let step = alpha / resolution;\n  let iteration = 0;\n  for (let a = step; a <= alpha + EPS; a += step) { // FIXME Should this be angelEPS?\n    connT2 = new Connector(origin, axisV.rotateZ(-a), normalV);\n    polygons = polygons.concat(cag._toWallPolygons(\n      {toConnector1: connT1, toConnector2: connT2}, iteration));\n    connT1 = connT2;\n  }\n  return fromPolygons(polygons).reTesselated();\n};\n\n// FIXME: right now linear & rotate extrude take params first, while rectangular_extrude\n// takes params second ! confusing and incoherent ! needs to be changed (BREAKING CHANGE !)\n\n/** linear extrusion of the input 2d shape\n * @param {Object} [options] - options for construction\n * @param {Float} [options.height=1] - height of the extruded shape\n * @param {Integer} [options.slices=10] - number of intermediary steps/slices\n * @param {Integer} [options.twist=0] - angle (in degrees to twist the extusion by)\n * @param {Boolean} [options.center=false] - whether to center extrusion or not\n * @param {CAG} baseShape input 2d shape\n * @returns {CSG} new extruded shape\n *\n * @example\n * let revolved = linear_extrude({height: 10}, square())\n */\nfunction linear_extrude(params, baseShape) {\n  const defaults = {\n    height: 1,\n    slices: 10,\n    twist: 0,\n    center: false\n  };\n  /* convexity = 10, */\n  const {height, twist, slices, center} = Object.assign({}, defaults, params);\n\n  // if(params.convexity) convexity = params.convexity      // abandoned\n  let output = baseShape.extrude({offset: [0, 0, height], twistangle: twist, twiststeps: slices});\n  if (center === true) {\n    const b = output.getBounds(); // b[0] = min, b[1] = max\n    const offset = (b[1].plus(b[0])).times(-0.5);\n    output = output.translate(offset);\n  }\n  return output;\n}\n\n/** rotate extrusion / revolve of the given 2d shape\n * @param {Object} [options] - options for construction\n * @param {Integer} [options.fn=1] - resolution/number of segments of the extrusion\n * @param {Float} [options.startAngle=1] - start angle of the extrusion, in degrees\n * @param {Float} [options.angle=1] - angle of the extrusion, in degrees\n * @param {Float} [options.overflow='cap'] - what to do with points outside of bounds (+ / - x) :\n * defaults to capping those points to 0 (only supported behaviour for now)\n * @param {CAG} baseShape input 2d shape\n * @returns {CSG} new extruded shape\n *\n * @example\n * let revolved = rotate_extrude({fn: 10}, square())\n */\nfunction rotate_extrude(params, baseShape) {\n  // note, we should perhaps alias this to revolve() as well\n  const defaults = {\n    fn: 32,\n    startAngle: 0,\n    angle: 360,\n    overflow: 'cap'\n  };\n  params = Object.assign({}, defaults, params);\n  let {fn, startAngle, angle, overflow} = params;\n  if (overflow !== 'cap') {\n    throw new Error('only capping of overflowing points is supported !');\n  }\n\n  if (arguments.length < 2) { // FIXME: what the hell ??? just put params second !\n    baseShape = params;\n  }\n  // are we dealing with a positive or negative angle (for normals flipping)\n  const flipped = angle > 0;\n  // limit actual angle between 0 & 360, regardless of direction\n  const totalAngle = flipped ? clamp((startAngle + angle), 0, 360) : clamp((startAngle + angle), -360, 0);\n  // adapt to the totalAngle : 1 extra segment per 45 degs if not 360 deg extrusion\n  // needs to be at least one and higher then the input resolution\n  const segments = Math.max(\n    Math.floor(Math.abs(totalAngle) / 45),\n    1,\n    fn\n  );\n  // maximum distance per axis between two points before considering them to be the same\n  const overlapTolerance = 0.00001;\n  // convert baseshape to just an array of points, easier to deal with\n  let shapePoints = cagToPointsArray(baseShape);\n\n  // determine if the rotate_extrude can be computed in the first place\n  // ie all the points have to be either x > 0 or x < 0\n\n  // generic solution to always have a valid solid, even if points go beyond x/ -x\n  // 1. split points up between all those on the 'left' side of the axis (x<0) & those on the 'righ' (x>0)\n  // 2. for each set of points do the extrusion operation IN OPOSITE DIRECTIONS\n  // 3. union the two resulting solids\n\n  // 1. alt : OR : just cap of points at the axis ?\n\n  // console.log('shapePoints BEFORE', shapePoints, baseShape.sides)\n\n  const pointsWithNegativeX = shapePoints.filter(x => x[0] < 0);\n  const pointsWithPositiveX = shapePoints.filter(x => x[0] >= 0);\n  const arePointsWithNegAndPosX = pointsWithNegativeX.length > 0 && pointsWithPositiveX.length > 0;\n\n  if (arePointsWithNegAndPosX && overflow === 'cap') {\n    if (pointsWithNegativeX.length > pointsWithPositiveX.length) {\n      shapePoints = shapePoints.map(function (point) {\n        return [Math.min(point[0], 0), point[1]];\n      });\n    } else if (pointsWithPositiveX.length >= pointsWithNegativeX.length) {\n      shapePoints = shapePoints.map(function (point) {\n        return [Math.max(point[0], 0), point[1]];\n      });\n    }\n  }\n\n  // console.log('negXs', pointsWithNegativeX, 'pointsWithPositiveX', pointsWithPositiveX, 'arePointsWithNegAndPosX', arePointsWithNegAndPosX)\n  //  console.log('shapePoints AFTER', shapePoints, baseShape.sides)\n\n  let polygons = [];\n\n  // for each of the intermediary steps in the extrusion\n  for (let i = 1; i < segments + 1; i++) {\n    // for each side of the 2d shape\n    for (let j = 0; j < shapePoints.length - 1; j++) {\n      // 2 points of a side\n      const curPoint = shapePoints[j];\n      const nextPoint = shapePoints[j + 1];\n\n      // compute matrix for current and next segment angle\n      let prevMatrix = Matrix4.rotationZ((i - 1) / segments * angle + startAngle);\n      let curMatrix = Matrix4.rotationZ(i / segments * angle + startAngle);\n\n      const pointA = rightMultiply1x3VectorToArray(prevMatrix, [curPoint[0], 0, curPoint[1]]);\n      const pointAP = rightMultiply1x3VectorToArray(curMatrix, [curPoint[0], 0, curPoint[1]]);\n      const pointB = rightMultiply1x3VectorToArray(prevMatrix, [nextPoint[0], 0, nextPoint[1]]);\n      const pointBP = rightMultiply1x3VectorToArray(curMatrix, [nextPoint[0], 0, nextPoint[1]]);\n\n      // console.log(`point ${j} edge connecting ${j} to ${j + 1}`)\n      let overlappingPoints = false;\n      if (Math.abs(pointA[0] - pointAP[0]) < overlapTolerance && Math.abs(pointB[1] - pointBP[1]) < overlapTolerance) {\n        // console.log('identical / overlapping points (from current angle and next one), what now ?')\n        overlappingPoints = true;\n      }\n\n      // we do not generate a single quad because:\n      // 1. it does not allow eliminating unneeded triangles in case of overlapping points\n      // 2. the current cleanup routines of csg.js create degenerate shapes from those quads\n      // let polyPoints = [pointA, pointB, pointBP, pointAP]\n      // polygons.push(polygonFromPoints(polyPoints))\n\n      if (flipped) {\n        // CW\n        polygons.push(polygonFromPoints([pointA, pointB, pointBP]));\n        if (!overlappingPoints) {\n          polygons.push(polygonFromPoints([pointBP, pointAP, pointA]));\n        }\n      } else {\n        // CCW\n        if (!overlappingPoints) {\n          polygons.push(polygonFromPoints([pointA, pointAP, pointBP]));\n        }\n        polygons.push(polygonFromPoints([pointBP, pointB, pointA]));\n      }\n    }\n    // if we do not do a full extrusion, we want caps at both ends (closed volume)\n    if (Math.abs(angle) < 360) {\n      // we need to recreate the side with capped points where applicable\n      const sideShape = fromPoints(shapePoints);\n      const endMatrix = Matrix4.rotationX(90).multiply(\n        Matrix4.rotationZ(-startAngle)\n      );\n      const endCap = sideShape._toPlanePolygons({flipped: flipped})\n        .map(x => x.transform(endMatrix));\n\n      const startMatrix = Matrix4.rotationX(90).multiply(\n        Matrix4.rotationZ(-angle - startAngle)\n      );\n      const startCap = sideShape._toPlanePolygons({flipped: !flipped})\n        .map(x => x.transform(startMatrix));\n      polygons = polygons.concat(endCap).concat(startCap);\n    }\n  }\n  return fromPolygons(polygons).reTesselated().canonicalized();\n}\n\n/** rectangular extrusion of the given array of points\n * @param {Array} basePoints array of points (nested) to extrude from\n * layed out like [ [0,0], [10,0], [5,10], [0,10] ]\n * @param {Object} [options] - options for construction\n * @param {Float} [options.h=1] - height of the extruded shape\n * @param {Float} [options.w=10] - width of the extruded shape\n * @param {Integer} [options.fn=1] - resolution/number of segments of the extrusion\n * @param {Boolean} [options.closed=false] - whether to close the input path for the extrusion or not\n * @param {Boolean} [options.round=true] - whether to round the extrusion or not\n * @returns {CSG} new extruded shape\n *\n * @example\n * let revolved = rectangular_extrude({height: 10}, square())\n */\nfunction rectangular_extrude(basePoints, params) {\n  const defaults = {\n    w: 1,\n    h: 1,\n    fn: 8,\n    closed: false,\n    round: true\n  };\n  const {w, h, fn, closed, round} = Object.assign({}, defaults, params);\n  return new Path2D(basePoints, closed).rectangularExtrude(w, h, fn, round);\n}\n\nmodule.exports = {\n  extrudeInOrthonormalBasis,\n  extrudeInPlane,\n  extrude,\n  linear_extrude,\n  rotate_extrude,\n  rotateExtrude,\n  rectangular_extrude\n};\n","// ////////////////////////////////////\n// # Class Properties\n// This class is used to store properties of a solid\n// A property can for example be a Vertex, a Plane or a Line3D\n// Whenever an affine transform is applied to the CSG solid, all its properties are\n// transformed as well.\n// The properties can be stored in a complex nested structure (using arrays and objects)\nconst Properties = function () {\n};\n\nProperties.prototype = {\n  _transform: function (matrix4x4) {\n    let result = new Properties();\n    Properties.transformObj(this, result, matrix4x4);\n    return result;\n  },\n  _merge: function (otherproperties) {\n    let result = new Properties();\n    Properties.cloneObj(this, result);\n    Properties.addFrom(result, otherproperties);\n    return result;\n  }\n};\n\nProperties.transformObj = function (source, result, matrix4x4) {\n  for (let propertyname in source) {\n    if (propertyname === '_transform') continue;\n    if (propertyname === '_merge') continue;\n    let propertyvalue = source[propertyname];\n    let transformed = propertyvalue;\n    if (typeof (propertyvalue) === 'object') {\n      if (('transform' in propertyvalue) && (typeof (propertyvalue.transform) === 'function')) {\n        transformed = propertyvalue.transform(matrix4x4);\n      } else if (propertyvalue instanceof Array) {\n        transformed = [];\n        Properties.transformObj(propertyvalue, transformed, matrix4x4);\n      } else if (propertyvalue instanceof Properties) {\n        transformed = new Properties();\n        Properties.transformObj(propertyvalue, transformed, matrix4x4);\n      }\n    }\n    result[propertyname] = transformed;\n  }\n};\n\nProperties.cloneObj = function (source, result) {\n  for (let propertyname in source) {\n    if (propertyname === '_transform') continue;\n    if (propertyname === '_merge') continue;\n    let propertyvalue = source[propertyname];\n    let cloned = propertyvalue;\n    if (typeof (propertyvalue) === 'object') {\n      if (propertyvalue instanceof Array) {\n        cloned = [];\n        for (let i = 0; i < propertyvalue.length; i++) {\n          cloned.push(propertyvalue[i]);\n        }\n      } else if (propertyvalue instanceof Properties) {\n        cloned = new Properties();\n        Properties.cloneObj(propertyvalue, cloned);\n      }\n    }\n    result[propertyname] = cloned;\n  }\n};\n\nProperties.addFrom = function (result, otherproperties) {\n  for (let propertyname in otherproperties) {\n    if (propertyname === '_transform') continue;\n    if (propertyname === '_merge') continue;\n    if ((propertyname in result) &&\n      (typeof (result[propertyname]) === 'object') &&\n      (result[propertyname] instanceof Properties) &&\n      (typeof (otherproperties[propertyname]) === 'object') &&\n      (otherproperties[propertyname] instanceof Properties)) {\n      Properties.addFrom(result[propertyname], otherproperties[propertyname]);\n    } else if (!(propertyname in result)) {\n      result[propertyname] = otherproperties[propertyname];\n    }\n  }\n};\n\nmodule.exports = Properties;\n","const CAG = require('../CAG');\nconst {fromPoints} = require('../CAGFactories');\n\n/*\n2D polygons are now supported through the CAG class.\nWith many improvements (see documentation):\n  - shapes do no longer have to be convex\n  - union/intersect/subtract is supported\n  - expand / contract are supported\n\nBut we'll keep CSG.Polygon2D as a stub for backwards compatibility\n*/\nfunction Polygon2D(points) {\n  const cag = fromPoints(points);\n  this.sides = cag.sides;\n}\n\nPolygon2D.prototype = CAG.prototype;\n\nmodule.exports = Polygon2D;\n","const {areaEPS} = require('../constants');\nconst {linesIntersect} = require('../math/lineUtils');\n\n// check if we are a valid CAG (for debugging)\n// NOTE(bebbi) uneven side count doesn't work because rounding with EPS isn't taken into account\nconst isCAGValid = function (CAG) {\n  let errors = [];\n  if (CAG.isSelfIntersecting(true)) {\n    errors.push('Self intersects');\n  }\n  let pointcount = {};\n  CAG.sides.map(function (side) {\n    function mappoint(p) {\n      let tag = p.x + ' ' + p.y;\n      if (!(tag in pointcount)) pointcount[tag] = 0;\n      pointcount[tag]++;\n    }\n\n    mappoint(side.vertex0.pos);\n    mappoint(side.vertex1.pos);\n  });\n  for (let tag in pointcount) {\n    let count = pointcount[tag];\n    if (count & 1) {\n      errors.push('Uneven number of sides (' + count + ') for point ' + tag);\n    }\n  }\n  let area = CAG.area();\n  if (area < areaEPS) {\n    errors.push('Area is ' + area);\n  }\n  if (errors.length > 0) {\n    let ertxt = '';\n    errors.map(function (err) {\n      ertxt += err + '\\n';\n    });\n    throw new Error(ertxt);\n  }\n};\n\nconst isSelfIntersecting = function (cag, debug) {\n  let numsides = cag.sides.length;\n  for (let i = 0; i < numsides; i++) {\n    let side0 = cag.sides[i];\n    for (let ii = i + 1; ii < numsides; ii++) {\n      let side1 = cag.sides[ii];\n      if (linesIntersect(side0.vertex0.pos, side0.vertex1.pos, side1.vertex0.pos, side1.vertex1.pos)) {\n        if (debug) {\n          console.log('side ' + i + ': ' + side0);\n          console.log('side ' + ii + ': ' + side1);\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/** Check if the point stay inside the CAG shape\n * ray-casting algorithm based on :\n * https://github.com/substack/point-in-polygon/blob/master/index.js\n * http://www.ecse.rp1.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n * originaly writed for https://github.com/lautr3k/SLAcer.js/blob/dev/js/slacer/slicer.js#L82\n * @param {CAG} cag - CAG object\n * @param {Object} p0 - Vertex2 like object\n * @returns {Boolean}\n */\nconst hasPointInside = function (cag, p0) {\n  let p1 = null;\n  let p2 = null;\n  let inside = false;\n  cag.sides.forEach(side => {\n    p1 = side.vertex0.pos;\n    p2 = side.vertex1.pos;\n    if (hasPointInside.c1(p0, p1, p2) && hasPointInside.c2(p0, p1, p2)) {\n      inside = !inside;\n    }\n  });\n  return inside;\n};\n\nhasPointInside.c1 = (p0, p1, p2) => (p1.y > p0.y) !== (p2.y > p0.y);\nhasPointInside.c2 = (p0, p1, p2) => (p0.x < (p2.x - p1.x) * (p0.y - p1.y) / (p2.y - p1.y) + p1.x);\n\n/** Check if all points from one CAG stay inside another CAG\n * @param {CAG} cag1 - CAG object\n * @param {Object} cag2 - CAG object\n * @returns {Boolean}\n */\nconst contains = function (cag1, cag2) {\n  for (let i = 0, il = cag2.sides.length; i < il; i++) {\n    if (!hasPointInside(cag1, cag2.sides[i].vertex0.pos)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = {\n  isCAGValid,\n  isSelfIntersecting,\n  hasPointInside,\n  contains\n};\n","const {EPS} = require('../constants');\nconst FuzzyCSGFactory = require('../FuzzyFactory3d');\nconst FuzzyCAGFactory = require('../FuzzyFactory2d');\nconst {fromPolygons} = require('../CSGFactories');\nconst {fromSides} = require('../CAGFactories');\n\n/**\n * Returns a cannoicalized version of the input csg/cag : ie every very close\n * points get deduplicated\n * @returns {CSG|CAG}\n * @example\n * let rawInput = someCSGORCAGMakingFunction()\n * let canonicalized= canonicalize(rawInput)\n */\nconst canonicalize = function (csgOrCAG, options) {\n  if (csgOrCAG.isCanonicalized) {\n    return csgOrCAG;\n  } else {\n    if ('sides' in csgOrCAG) {\n      return canonicalizeCAG(csgOrCAG, options);\n    } else {\n      return canonicalizeCSG(csgOrCAG, options);\n    }\n  }\n};\n\n/**\n * Returns a cannoicalized version of the input csg : ie every very close\n * points get deduplicated\n * @returns {CSG}\n * @example\n * let rawCSG = someCSGMakingFunction()\n * let canonicalizedCSG = canonicalize(rawCSG)\n */\nconst canonicalizeCSG = function (csg, options) {\n  if (csg.isCanonicalized) {\n    return csg;\n  } else {\n    const factory = new FuzzyCSGFactory();\n    let result = CSGFromCSGFuzzyFactory(factory, csg);\n    result.isCanonicalized = true;\n    result.isRetesselated = csg.isRetesselated;\n    result.properties = csg.properties; // keep original properties\n    return result;\n  }\n};\n\nconst canonicalizeCAG = function (cag, options) {\n  if (cag.isCanonicalized) {\n    return cag;\n  } else {\n    let factory = new FuzzyCAGFactory();\n    let result = CAGFromCAGFuzzyFactory(factory, cag);\n    result.isCanonicalized = true;\n    return result;\n  }\n};\n\nconst CSGFromCSGFuzzyFactory = function (factory, sourcecsg) {\n  let _this = factory;\n  let newpolygons = [];\n  sourcecsg.polygons.forEach(function (polygon) {\n    let newpolygon = _this.getPolygon(polygon);\n    // see getPolygon above: we may get a polygon with no vertices, discard it:\n    if (newpolygon.vertices.length >= 3) {\n      newpolygons.push(newpolygon);\n    }\n  });\n  return fromPolygons(newpolygons);\n};\n\nconst CAGFromCAGFuzzyFactory = function (factory, sourcecag) {\n  let _this = factory;\n  let newsides = sourcecag.sides.map(function (side) {\n    return _this.getSide(side);\n  })\n    // remove bad sides (mostly a user input issue)\n    .filter(function (side) {\n      return side.length() > EPS;\n    });\n  return fromSides(newsides);\n};\n\nmodule.exports = canonicalize;\n","const {EPS} = require('./constants');\nconst Polygon = require('./math/Polygon3');\nconst FuzzyFactory = require('./FuzzyFactory');\n\n// ////////////////////////////////////\nconst FuzzyCSGFactory = function () {\n  this.vertexfactory = new FuzzyFactory(5, EPS);\n  this.planefactory = new FuzzyFactory(4, EPS);\n  this.polygonsharedfactory = {};\n};\n\nFuzzyCSGFactory.prototype = {\n  getPolygonShared: function (sourceshared) {\n    let hash = sourceshared.getHash();\n    if (hash in this.polygonsharedfactory) {\n      return this.polygonsharedfactory[hash];\n    } else {\n      this.polygonsharedfactory[hash] = sourceshared;\n      return sourceshared;\n    }\n  },\n\n  getVertex: function (sourcevertex) {\n    let elements = [sourcevertex.pos._x, sourcevertex.pos._y, sourcevertex.pos._z,\n      sourcevertex.uv._x, sourcevertex.uv._y];\n    let result = this.vertexfactory.lookupOrCreate(elements, function (els) {\n      return sourcevertex;\n    });\n    return result;\n  },\n\n  getPlane: function (sourceplane) {\n    let elements = [sourceplane.normal._x, sourceplane.normal._y, sourceplane.normal._z, sourceplane.w];\n    let result = this.planefactory.lookupOrCreate(elements, function (els) {\n      return sourceplane;\n    });\n    return result;\n  },\n\n  getPolygon: function (sourcepolygon) {\n    let newplane = this.getPlane(sourcepolygon.plane);\n    let newshared = this.getPolygonShared(sourcepolygon.shared);\n    let _this = this;\n    let newvertices = sourcepolygon.vertices.map(function (vertex) {\n      return _this.getVertex(vertex);\n    });\n    // two vertices that were originally very close may now have become\n    // truly identical (referring to the same Vertex object).\n    // Remove duplicate vertices:\n    let newverticesDedup = [];\n    if (newvertices.length > 0) {\n      let prevvertextag = newvertices[newvertices.length - 1].getTag();\n      newvertices.forEach(function (vertex) {\n        let vertextag = vertex.getTag();\n        if (vertextag !== prevvertextag) {\n          newverticesDedup.push(vertex);\n        }\n        prevvertextag = vertextag;\n      });\n    }\n    // If it's degenerate, remove all vertices:\n    if (newverticesDedup.length < 3) {\n      newverticesDedup = [];\n    }\n    return new Polygon(newverticesDedup, newshared, newplane);\n  }\n};\n\nmodule.exports = FuzzyCSGFactory;\n","// //////////////////////////////\n// ## class fuzzyFactory\n// This class acts as a factory for objects. We can search for an object with approximately\n// the desired properties (say a rectangle with width 2 and height 1)\n// The lookupOrCreate() method looks for an existing object (for example it may find an existing rectangle\n// with width 2.0001 and height 0.999. If no object is found, the user supplied callback is\n// called, which should generate a new object. The new object is inserted into the database\n// so it can be found by future lookupOrCreate() calls.\n// Constructor:\n//   numdimensions: the number of parameters for each object\n//     for example for a 2D rectangle this would be 2\n//   tolerance: The maximum difference for each parameter allowed to be considered a match\nconst FuzzyFactory = function (numdimensions, tolerance) {\n  this.lookuptable = {};\n  this.multiplier = 1.0 / tolerance;\n};\n\nFuzzyFactory.prototype = {\n  // let obj = f.lookupOrCreate([el1, el2, el3], function(elements) {/* create the new object */});\n  // Performs a fuzzy lookup of the object with the specified elements.\n  // If found, returns the existing object\n  // If not found, calls the supplied callback function which should create a new object with\n  // the specified properties. This object is inserted in the lookup database.\n  lookupOrCreate: function (els, creatorCallback) {\n    let hash = '';\n    let multiplier = this.multiplier;\n    els.forEach(function (el) {\n      let valueQuantized = Math.round(el * multiplier);\n      hash += valueQuantized + '/';\n    });\n    if (hash in this.lookuptable) {\n      return this.lookuptable[hash];\n    } else {\n      let object = creatorCallback(els);\n      let hashparts = els.map(function (el) {\n        let q0 = Math.floor(el * multiplier);\n        let q1 = q0 + 1;\n        return ['' + q0 + '/', '' + q1 + '/'];\n      });\n      let numelements = els.length;\n      let numhashes = 1 << numelements;\n      for (let hashmask = 0; hashmask < numhashes; ++hashmask) {\n        let hashmaskShifted = hashmask;\n        hash = '';\n        hashparts.forEach(function (hashpart) {\n          hash += hashpart[hashmaskShifted & 1];\n          hashmaskShifted >>= 1;\n        });\n        this.lookuptable[hash] = object;\n      }\n      return object;\n    }\n  }\n};\n\nmodule.exports = FuzzyFactory;\n","const FuzzyCSGFactory = require('../FuzzyFactory3d');\nconst reTesselateCoplanarPolygons = require('../math/reTesselateCoplanarPolygons');\nconst {fromPolygons} = require('../CSGFactories');\n\nconst reTesselate = function (csg) {\n  if (csg.isRetesselated) {\n    return csg;\n  } else {\n    let polygonsPerPlane = {};\n    let isCanonicalized = csg.isCanonicalized;\n    let fuzzyfactory = new FuzzyCSGFactory();\n    csg.polygons.map(function (polygon) {\n      let plane = polygon.plane;\n      let shared = polygon.shared;\n      if (!isCanonicalized) {\n        // in order to identify polygons having the same plane, we need to canonicalize the planes\n        // We don't have to do a full canonizalization (including vertices), to save time only do the planes and the shared data:\n        plane = fuzzyfactory.getPlane(plane);\n        shared = fuzzyfactory.getPolygonShared(shared);\n      }\n      let tag = plane.getTag() + '/' + shared.getTag();\n      if (!(tag in polygonsPerPlane)) {\n        polygonsPerPlane[tag] = [polygon];\n      } else {\n        polygonsPerPlane[tag].push(polygon);\n      }\n    });\n    let destpolygons = [];\n    for (let planetag in polygonsPerPlane) {\n      let sourcepolygons = polygonsPerPlane[planetag];\n      if (sourcepolygons.length < 2) {\n        destpolygons = destpolygons.concat(sourcepolygons);\n      } else {\n        let retesselayedpolygons = [];\n        reTesselateCoplanarPolygons(sourcepolygons, retesselayedpolygons);\n        destpolygons = destpolygons.concat(retesselayedpolygons);\n      }\n    }\n    let result = fromPolygons(destpolygons);\n    result.isRetesselated = true;\n    // result = result.canonicalized();\n    result.properties = csg.properties; // keep original properties\n    return result;\n  }\n};\n\nmodule.exports = reTesselate;\n","const Matrix4x4 = require('../core/math/Matrix4.js');\nconst Vector3D = require('../core/math/Vector3.js');\nconst {Connector} = require('../core/connectors.js');\nconst {fromPoints} = require('../core/CAGFactories');\nconst Vector2D = require('../core/math/Vector2');\n\n// Get the transformation that transforms this CSG such that it is lying on the z=0 plane,\n// as flat as possible (i.e. the least z-height).\n// So that it is in an orientation suitable for CNC milling\nconst getTransformationAndInverseTransformationToFlatLying = function (_csg) {\n  if (_csg.polygons.length === 0) {\n    let m = new Matrix4x4(); // unity\n    return [m, m];\n  } else {\n    // get a list of unique planes in the CSG:\n    let csg = _csg.canonicalized();\n    let planemap = {};\n    csg.polygons.map(function (polygon) {\n      planemap[polygon.plane.getTag()] = polygon.plane;\n    });\n    // try each plane in the CSG and find the plane that, when we align it flat onto z=0,\n    // gives the least height in z-direction.\n    // If two planes give the same height, pick the plane that originally had a normal closest\n    // to [0,0,-1].\n    let xvector = new Vector3D(1, 0, 0);\n    let yvector = new Vector3D(0, 1, 0);\n    let zvector = new Vector3D(0, 0, 1);\n    let z0connectorx = new Connector([0, 0, 0], [0, 0, -1], xvector);\n    let z0connectory = new Connector([0, 0, 0], [0, 0, -1], yvector);\n    let isfirst = true;\n    let minheight = 0;\n    let maxdotz = 0;\n    let besttransformation, bestinversetransformation;\n    for (let planetag in planemap) {\n      let plane = planemap[planetag];\n      let pointonplane = plane.normal.times(plane.w);\n      let transformation, inversetransformation;\n      // We need a normal vecrtor for the transformation\n      // determine which is more perpendicular to the plane normal: x or y?\n      // we will align this as much as possible to the x or y axis vector\n      let xorthogonality = plane.normal.cross(xvector).length();\n      let yorthogonality = plane.normal.cross(yvector).length();\n      if (xorthogonality > yorthogonality) {\n        // x is better:\n        let planeconnector = new Connector(pointonplane, plane.normal, xvector);\n        transformation = planeconnector.getTransformationTo(z0connectorx, false, 0);\n        inversetransformation = z0connectorx.getTransformationTo(planeconnector, false, 0);\n      } else {\n        // y is better:\n        let planeconnector = new Connector(pointonplane, plane.normal, yvector);\n        transformation = planeconnector.getTransformationTo(z0connectory, false, 0);\n        inversetransformation = z0connectory.getTransformationTo(planeconnector, false, 0);\n      }\n      let transformedcsg = csg.transform(transformation);\n      let dotz = -plane.normal.dot(zvector);\n      let bounds = transformedcsg.getBounds();\n      let zheight = bounds[1].z - bounds[0].z;\n      let isbetter = isfirst;\n      if (!isbetter) {\n        if (zheight < minheight) {\n          isbetter = true;\n        } else if (zheight === minheight) {\n          if (dotz > maxdotz) isbetter = true;\n        }\n      }\n      if (isbetter) {\n        // translate the transformation around the z-axis and onto the z plane:\n        let translation = new Vector3D([-0.5 * (bounds[1].x + bounds[0].x), -0.5 * (bounds[1].y + bounds[0].y), -bounds[0].z]);\n        transformation = transformation.multiply(Matrix4x4.translation(translation));\n        inversetransformation = Matrix4x4.translation(translation.negated()).multiply(inversetransformation);\n        minheight = zheight;\n        maxdotz = dotz;\n        besttransformation = transformation;\n        bestinversetransformation = inversetransformation;\n      }\n      isfirst = false;\n    }\n    return [besttransformation, bestinversetransformation];\n  }\n};\n\nconst getTransformationToFlatLying = function (csg) {\n  let result = csg.getTransformationAndInverseTransformationToFlatLying();\n  return result[0];\n};\n\nconst lieFlat = function (csg) {\n  let transformation = csg.getTransformationToFlatLying();\n  return csg.transform(transformation);\n};\n\n/** cag = cag.overCutInsideCorners(cutterradius);\n * Using a CNC router it's impossible to cut out a true sharp inside corner. The inside corner\n * will be rounded due to the radius of the cutter. This function compensates for this by creating\n * an extra cutout at each inner corner so that the actual cut out shape will be at least as large\n * as needed.\n * @param {Object} _cag - input cag\n * @param {Float} cutterradius - radius to cut inside corners by\n * @returns {CAG} cag with overcutInsideCorners\n */\nconst overCutInsideCorners = function (_cag, cutterradius) {\n  let cag = _cag.canonicalized();\n  // for each vertex determine the 'incoming' side and 'outgoing' side:\n  let pointmap = {}; // tag => {pos: coord, from: [], to: []}\n  cag.sides.map(function (side) {\n    if (!(side.vertex0.getTag() in pointmap)) {\n      pointmap[side.vertex0.getTag()] = {\n        pos: side.vertex0.pos,\n        from: [],\n        to: []\n      };\n    }\n    pointmap[side.vertex0.getTag()].to.push(side.vertex1.pos);\n    if (!(side.vertex1.getTag() in pointmap)) {\n      pointmap[side.vertex1.getTag()] = {\n        pos: side.vertex1.pos,\n        from: [],\n        to: []\n      };\n    }\n    pointmap[side.vertex1.getTag()].from.push(side.vertex0.pos);\n  });\n  // overcut all sharp corners:\n  let cutouts = [];\n  for (let pointtag in pointmap) {\n    let pointobj = pointmap[pointtag];\n    if ((pointobj.from.length === 1) && (pointobj.to.length === 1)) {\n      // ok, 1 incoming side and 1 outgoing side:\n      let fromcoord = pointobj.from[0];\n      let pointcoord = pointobj.pos;\n      let tocoord = pointobj.to[0];\n      let v1 = pointcoord.minus(fromcoord).unit();\n      let v2 = tocoord.minus(pointcoord).unit();\n      let crossproduct = v1.cross(v2);\n      let isInnerCorner = (crossproduct < 0.001);\n      if (isInnerCorner) {\n        // yes it's a sharp corner:\n        let alpha = v2.angleRadians() - v1.angleRadians() + Math.PI;\n        if (alpha < 0) {\n          alpha += 2 * Math.PI;\n        } else if (alpha >= 2 * Math.PI) {\n          alpha -= 2 * Math.PI;\n        }\n        let midvector = v2.minus(v1).unit();\n        let circlesegmentangle = 30 / 180 * Math.PI; // resolution of the circle: segments of 30 degrees\n        // we need to increase the radius slightly so that our imperfect circle will contain a perfect circle of cutterradius\n        let radiuscorrected = cutterradius / Math.cos(circlesegmentangle / 2);\n        let circlecenter = pointcoord.plus(midvector.times(radiuscorrected));\n        // we don't need to create a full circle; a pie is enough. Find the angles for the pie:\n        let startangle = alpha + midvector.angleRadians();\n        let deltaangle = 2 * (Math.PI - alpha);\n        let numsteps = 2 * Math.ceil(deltaangle / circlesegmentangle / 2); // should be even\n        // build the pie:\n        let points = [circlecenter];\n        for (let i = 0; i <= numsteps; i++) {\n          let angle = startangle + i / numsteps * deltaangle;\n          let p = Vector2D.fromAngleRadians(angle).times(radiuscorrected).plus(circlecenter);\n          points.push(p);\n        }\n        cutouts.push(fromPoints(points));\n      }\n    }\n  }\n  return cag.subtract(cutouts);\n};\n\nmodule.exports = {lieFlat, getTransformationToFlatLying, getTransformationAndInverseTransformationToFlatLying, overCutInsideCorners};\n","const toArray = require('../core/utils/toArray');\n\n/**\n * Centers the given object(s) using the given options (if any)\n * @param {Object} [options] - options for centering\n * @param {Array} [options.axes=[true,true,true]] - axis of which to center, true or false\n * @param {Array} [options.center=[0,0,0]] - point of which to center the object upon\n * @param {Object|Array} objects - the shape(s) to center\n * @return {Object|Array} objects\n *\n * @example\n * let csg = center({axes: [true,false,false]}, sphere()) // center about the X axis\n */\nconst center = function (options, objects) {\n  const defaults = {\n    axes: [true, true, true],\n    center: [0, 0, 0]\n    // TODO : Add addition 'methods' of centering; midpoint, centeriod\n  };\n  options = Object.assign({}, defaults, options);\n  const {axes, center} = options;\n  objects = toArray(objects);\n\n  const results = objects.map(function (object) {\n    let bounds = object.getBounds();\n    let offset = [0, 0, 0];\n    if (axes[0]) offset[0] = center[0] - (bounds[0].x + ((bounds[1].x - bounds[0].x) / 2));\n    if (axes[1]) offset[1] = center[1] - (bounds[0].y + ((bounds[1].y - bounds[0].y) / 2));\n    if (axes[2]) offset[2] = center[2] - (bounds[0].z + ((bounds[1].z - bounds[0].z) / 2));\n    return object.translate(offset);\n  });\n  // if there is more than one result, return them all , otherwise a single one\n  return results.length === 1 ? results[0] : results;\n};\n\nmodule.exports = center;\n","const {EPS, angleEPS} = require('../core/constants');\nconst Vertex = require('../core/math/Vertex3');\nconst Vector2D = require('../core/math/Vector2');\nconst Polygon = require('../core/math/Polygon3');\nconst {fnNumberSort, isCSG} = require('../core/utils');\nconst {fromPoints, fromPointsNoCheck} = require('../core/CAGFactories');\n\nconst expand = function (shape, radius, resolution) {\n  let result;\n  if (isCSG(shape)) {\n    result = shape.union(expandedShellOfCCSG(shape, radius, resolution));\n    result = result.reTesselated();\n    result.properties = shape.properties; // keep original properties\n  } else {\n    result = shape.union(expandedShellOfCAG(shape, radius, resolution));\n  }\n  return result;\n};\n\nconst contract = function (shape, radius, resolution) {\n  let result;\n  if (isCSG(shape)) {\n    result = shape.subtract(expandedShellOfCCSG(shape, radius, resolution));\n    result = result.reTesselated();\n    result.properties = shape.properties; // keep original properties\n  } else {\n    result = shape.subtract(expandedShellOfCAG(shape, radius, resolution));\n  }\n  return result;\n};\n\nconst expandedShellOfCAG = function (_cag, radius, resolution) {\n  const CAG = require('../core/CAG'); // FIXME, circular dependency !!\n  resolution = resolution || 8;\n  if (resolution < 4) resolution = 4;\n  let cags = [];\n  let pointmap = {};\n  let cag = _cag.canonicalized();\n  cag.sides.map(function (side) {\n    let d = side.vertex1.pos.minus(side.vertex0.pos);\n    let dl = d.length();\n    if (dl > EPS) {\n      d = d.times(1.0 / dl);\n      let normal = d.normal().times(radius);\n      let shellpoints = [\n        side.vertex1.pos.plus(normal),\n        side.vertex1.pos.minus(normal),\n        side.vertex0.pos.minus(normal),\n        side.vertex0.pos.plus(normal)\n      ];\n      //      let newcag = fromPointsNoCheck(shellpoints);\n      let newcag = fromPoints(shellpoints);\n      cags.push(newcag);\n      for (let step = 0; step < 2; step++) {\n        let p1 = (step === 0) ? side.vertex0.pos : side.vertex1.pos;\n        let p2 = (step === 0) ? side.vertex1.pos : side.vertex0.pos;\n        let tag = p1.x + ' ' + p1.y;\n        if (!(tag in pointmap)) {\n          pointmap[tag] = [];\n        }\n        pointmap[tag].push({\n          'p1': p1,\n          'p2': p2\n        });\n      }\n    }\n  });\n  for (let tag in pointmap) {\n    let m = pointmap[tag];\n    let angle1, angle2;\n    let pcenter = m[0].p1;\n    if (m.length === 2) {\n      let end1 = m[0].p2;\n      let end2 = m[1].p2;\n      angle1 = end1.minus(pcenter).angleDegrees();\n      angle2 = end2.minus(pcenter).angleDegrees();\n      if (angle2 < angle1) angle2 += 360;\n      if (angle2 >= (angle1 + 360)) angle2 -= 360;\n      if (angle2 < angle1 + 180) {\n        let t = angle2;\n        angle2 = angle1 + 360;\n        angle1 = t;\n      }\n      angle1 += 90;\n      angle2 -= 90;\n    } else {\n      angle1 = 0;\n      angle2 = 360;\n    }\n    let fullcircle = (angle2 > angle1 + 359.999);\n    if (fullcircle) {\n      angle1 = 0;\n      angle2 = 360;\n    }\n    if (angle2 > (angle1 + angleEPS)) {\n      let points = [];\n      if (!fullcircle) {\n        points.push(pcenter);\n      }\n      let numsteps = Math.round(resolution * (angle2 - angle1) / 360);\n      if (numsteps < 1) numsteps = 1;\n      for (let step = 0; step <= numsteps; step++) {\n        let angle = angle1 + step / numsteps * (angle2 - angle1);\n        if (step === numsteps) angle = angle2; // prevent rounding errors\n        let point = pcenter.plus(Vector2D.fromAngleDegrees(angle).times(radius));\n        if ((!fullcircle) || (step > 0)) {\n          points.push(point);\n        }\n      }\n      let newcag = fromPointsNoCheck(points);\n      cags.push(newcag);\n    }\n  }\n  let result = new CAG();\n  result = result.union(cags);\n  return result;\n};\n\n/**\n * Create the expanded shell of the solid:\n * All faces are extruded to get a thickness of 2*radius\n * Cylinders are constructed around every side\n * Spheres are placed on every vertex\n * unionWithThis: if true, the resulting solid will be united with 'this' solid;\n * the result is a true expansion of the solid\n * If false, returns only the shell\n * @param  {Float} radius\n * @param  {Integer} resolution\n * @param  {Boolean} unionWithThis\n */\nconst expandedShellOfCCSG = function (_csg, radius, resolution, unionWithThis) {\n  const CSG = require('../core/CSG'); // FIXME: circular dependency ! CSG => this => CSG\n  const {fromPolygons} = require('../core/CSGFactories'); // FIXME: circular dependency !\n  // const {sphere} = require('./primitives3d') // FIXME: circular dependency !\n  let csg = _csg.reTesselated();\n  let result;\n  if (unionWithThis) {\n    result = csg;\n  } else {\n    result = new CSG();\n  }\n\n  // first extrude all polygons:\n  csg.polygons.map(function (polygon) {\n    let extrudevector = polygon.plane.normal.unit().times(2 * radius);\n    let translatedpolygon = polygon.translate(extrudevector.times(-0.5));\n    let extrudedface = translatedpolygon.extrude(extrudevector);\n    result = result.unionSub(extrudedface, false, false);\n  });\n\n  // Make a list of all unique vertex pairs (i.e. all sides of the solid)\n  // For each vertex pair we collect the following:\n  //   v1: first coordinate\n  //   v2: second coordinate\n  //   planenormals: array of normal vectors of all planes touching this side\n  let vertexpairs = {}; // map of 'vertex pair tag' to {v1, v2, planenormals}\n  csg.polygons.map(function (polygon) {\n    let numvertices = polygon.vertices.length;\n    let prevvertex = polygon.vertices[numvertices - 1];\n    let prevvertextag = prevvertex.getTag();\n    for (let i = 0; i < numvertices; i++) {\n      let vertex = polygon.vertices[i];\n      let vertextag = vertex.getTag();\n      let vertextagpair;\n      if (vertextag < prevvertextag) {\n        vertextagpair = vertextag + '-' + prevvertextag;\n      } else {\n        vertextagpair = prevvertextag + '-' + vertextag;\n      }\n      let obj;\n      if (vertextagpair in vertexpairs) {\n        obj = vertexpairs[vertextagpair];\n      } else {\n        obj = {\n          v1: prevvertex,\n          v2: vertex,\n          planenormals: []\n        };\n        vertexpairs[vertextagpair] = obj;\n      }\n      obj.planenormals.push(polygon.plane.normal);\n\n      prevvertextag = vertextag;\n      prevvertex = vertex;\n    }\n  });\n\n  // now construct a cylinder on every side\n  // The cylinder is always an approximation of a true cylinder: it will have <resolution> polygons\n  // around the sides. We will make sure though that the cylinder will have an edge at every\n  // face that touches this side. This ensures that we will get a smooth fill even\n  // if two edges are at, say, 10 degrees and the resolution is low.\n  // Note: the result is not retesselated yet but it really should be!\n  for (let vertextagpair in vertexpairs) {\n    let vertexpair = vertexpairs[vertextagpair];\n    let startpoint = vertexpair.v1.pos;\n    let endpoint = vertexpair.v2.pos;\n    // our x,y and z vectors:\n    let zbase = endpoint.minus(startpoint).unit();\n    let xbase = vertexpair.planenormals[0].unit();\n    let ybase = xbase.cross(zbase);\n\n    // make a list of angles that the cylinder should traverse:\n    let angles = [];\n\n    // first of all equally spaced around the cylinder:\n    for (let i = 0; i < resolution; i++) {\n      angles.push(i * Math.PI * 2 / resolution);\n    }\n\n    // and also at every normal of all touching planes:\n    for (let i = 0, iMax = vertexpair.planenormals.length; i < iMax; i++) {\n      let planenormal = vertexpair.planenormals[i];\n      let si = ybase.dot(planenormal);\n      let co = xbase.dot(planenormal);\n      let angle = Math.atan2(si, co);\n\n      if (angle < 0) angle += Math.PI * 2;\n      angles.push(angle);\n      angle = Math.atan2(-si, -co);\n      if (angle < 0) angle += Math.PI * 2;\n      angles.push(angle);\n    }\n\n    // this will result in some duplicate angles but we will get rid of those later.\n    // Sort:\n    angles = angles.sort(fnNumberSort);\n\n    // Now construct the cylinder by traversing all angles:\n    let numangles = angles.length;\n    let prevp1;\n    let prevp2;\n    let startfacevertices = [];\n    let endfacevertices = [];\n    let polygons = [];\n    for (let i = -1; i < numangles; i++) {\n      let angle = angles[(i < 0) ? (i + numangles) : i];\n      let si = Math.sin(angle);\n      let co = Math.cos(angle);\n      let p = xbase.times(co * radius).plus(ybase.times(si * radius));\n      let p1 = startpoint.plus(p);\n      let p2 = endpoint.plus(p);\n      let skip = false;\n      if (i >= 0) {\n        if (p1.distanceTo(prevp1) < EPS) {\n          skip = true;\n        }\n      }\n      if (!skip) {\n        if (i >= 0) {\n          startfacevertices.push(new Vertex(p1));\n          endfacevertices.push(new Vertex(p2));\n          let polygonvertices = [\n            new Vertex(prevp2),\n            new Vertex(p2),\n            new Vertex(p1),\n            new Vertex(prevp1)\n          ];\n          let polygon = new Polygon(polygonvertices);\n          polygons.push(polygon);\n        }\n        prevp1 = p1;\n        prevp2 = p2;\n      }\n    }\n    endfacevertices.reverse();\n    polygons.push(new Polygon(startfacevertices));\n    polygons.push(new Polygon(endfacevertices));\n    let cylinder = fromPolygons(polygons);\n    result = result.unionSub(cylinder, false, false);\n  }\n\n  // make a list of all unique vertices\n  // For each vertex we also collect the list of normals of the planes touching the vertices\n  let vertexmap = {};\n  csg.polygons.map(function (polygon) {\n    polygon.vertices.map(function (vertex) {\n      let vertextag = vertex.getTag();\n      let obj;\n      if (vertextag in vertexmap) {\n        obj = vertexmap[vertextag];\n      } else {\n        obj = {\n          pos: vertex.pos,\n          normals: []\n        };\n        vertexmap[vertextag] = obj;\n      }\n      obj.normals.push(polygon.plane.normal);\n    });\n  });\n\n  // and build spheres at each vertex\n  // We will try to set the x and z axis to the normals of 2 planes\n  // This will ensure that our sphere tesselation somewhat matches 2 planes\n  for (let vertextag in vertexmap) {\n    let vertexobj = vertexmap[vertextag];\n    // use the first normal to be the x axis of our sphere:\n    let xaxis = vertexobj.normals[0].unit();\n    // and find a suitable z axis. We will use the normal which is most perpendicular to the x axis:\n    let bestzaxis = null;\n    let bestzaxisorthogonality = 0;\n    for (let i = 1; i < vertexobj.normals.length; i++) {\n      let normal = vertexobj.normals[i].unit();\n      let cross = xaxis.cross(normal);\n      let crosslength = cross.length();\n      if (crosslength > 0.05) {\n        if (crosslength > bestzaxisorthogonality) {\n          bestzaxisorthogonality = crosslength;\n          bestzaxis = normal;\n        }\n      }\n    }\n    if (!bestzaxis) {\n      bestzaxis = xaxis.randomNonParallelVector();\n    }\n    let yaxis = xaxis.cross(bestzaxis).unit();\n    let zaxis = yaxis.cross(xaxis);\n    let _sphere = CSG.sphere({\n      center: vertexobj.pos,\n      radius: radius,\n      resolution: resolution,\n      axes: [xaxis, yaxis, zaxis]\n    });\n    result = result.unionSub(_sphere, false, false);\n  }\n\n  return result;\n};\n\nmodule.exports = {\n  expand,\n  contract,\n  expandedShellOfCAG,\n  expandedShellOfCCSG\n};\n","const {CAG} = require('../csg');// we have to import from top level otherwise prototypes are not complete..\nconst {fromPoints} = require('../core/CAGFactories');\n\n/** Construct a square/rectangle\n * @param {Object} [options] - options for construction\n * @param {Float} [options.size=1] - size of the square, either as array or scalar\n * @param {Boolean} [options.center=true] - wether to center the square/rectangle or not\n * @returns {CAG} new square\n *\n * @example\n * let square1 = square({\n *   size: 10\n * })\n */\nfunction square() {\n  let v = [1, 1];\n  let off;\n  let a = arguments;\n  let params = a[0];\n\n  if (params && Number.isFinite(params)) v = [params, params];\n  if (params && params.length) {\n    v = a[0];\n    params = a[1];\n  }\n  if (params && params.size && params.size.length) v = params.size;\n\n  off = [v[0] / 2, v[1] / 2];\n  if (params && params.center === true) off = [0, 0];\n\n  return CAG.rectangle({center: off, radius: [v[0] / 2, v[1] / 2]});\n}\n\n/** Construct a circle\n * @param {Object} [options] - options for construction\n * @param {Float} [options.r=1] - radius of the circle\n * @param {Integer} [options.fn=32] - segments of circle (ie quality/ resolution)\n * @param {Boolean} [options.center=true] - wether to center the circle or not\n * @returns {CAG} new circle\n *\n * @example\n * let circle1 = circle({\n *   r: 10\n * })\n */\nfunction circle(params) {\n  const defaults = {\n    r: 1,\n    fn: 32,\n    center: false\n  };\n  let {r, fn, center} = Object.assign({}, defaults, params);\n  if (params && !params.r && !params.fn && !params.center) r = params;\n  let offset = center === true ? [0, 0] : [r, r];\n  return CAG.circle({center: offset, radius: r, resolution: fn});\n}\n\n/** Construct a polygon either from arrays of paths and points,\n * or just arrays of points nested paths (multiple paths) and flat paths are supported\n * @param {Object} [options] - options for construction or either flat or nested array of points\n * @param {Array} [options.points] - points of the polygon : either flat or nested array of points\n * @param {Array} [options.paths] - paths of the polygon : either flat or nested array of points index\n * @returns {CAG} new polygon\n *\n * @example\n * let roof = [[10,11], [0,11], [5,20]]\n * let wall = [[0,0], [10,0], [10,10], [0,10]]\n *\n * let poly = polygon(roof)\n * or\n * let poly = polygon([roof, wall])\n * or\n * let poly = polygon({ points: roof })\n * or\n * let poly = polygon({ points: [roof, wall] })\n * or\n * let poly = polygon({ points: roof, path: [0, 1, 2] })\n * or\n * let poly = polygon({ points: [roof, wall], path: [[0, 1, 2], [3, 4, 5, 6]] })\n * or\n * let poly = polygon({ points: roof.concat(wall), paths: [[0, 1, 2], [3, 4, 5], [3, 6, 5]] })\n */\nfunction polygon(params) { // array of po(ints) and pa(ths)\n  let points = [];\n  if (params.paths && params.paths.length && params.paths[0].length) { // pa(th): [[0,1,2],[2,3,1]] (two paths)\n    if (typeof params.points[0][0] !== 'number') { // flatten points array\n      params.points = params.points.reduce((a, b) => a.concat(b));\n    }\n    params.paths.forEach((path, i) => {\n      points.push([]);\n      path.forEach(j => points[i].push(params.points[j]));\n    });\n  } else if (params.paths && params.paths.length) { // pa(th): [0,1,2,3,4] (single path)\n    params.paths.forEach(i => points.push(params.points[i]));\n  } else { // pa(th) = po(ints)\n    if (params.length) {\n      points = params;\n    } else {\n      points = params.points;\n    }\n  }\n  return fromPoints(points);\n}\n\n// FIXME: errr this is kinda just a special case of a polygon , why do we need it ?\n/** Construct a triangle\n * @returns {CAG} new triangle\n *\n * @example\n * let triangle = trangle({\n *   length: 10\n * })\n */\nfunction triangle() {\n  let a = arguments;\n  if (a[0] && a[0].length) a = a[0];\n  return fromPoints(a);\n}\n\nmodule.exports = {\n  circle,\n  square,\n  polygon,\n  triangle\n};\n","const Matrix4 = require('../../core/math/Matrix4');\nconst Plane = require('../../core/math/Plane');\nconst Vector3 = require('../../core/math/Vector3');\nconst {union} = require('../boolean');\nconst {fromPoints} = require('../../core/CAGFactories');\nconst {isCAG} = require('../../core/utils');\n\n// -- 3D transformations (OpenSCAD like notion)\n\n/** translate an object in 2D/3D space\n * @param {Object} vector - 3D vector to translate the given object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to translate\n * @returns {CSG} new CSG object , translated by the given amount\n *\n * @example\n * let movedSphere = translate([10,2,0], sphere())\n */\nfunction translate(vector, ...objects) {      // v, obj or array\n  // workaround needed to determine if we are dealing with an array of objects\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  return object.translate(vector);\n}\n\n/** scale an object in 2D/3D space\n * @param {Float|Array} scale - either an array or simple number to scale object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to scale\n * @returns {CSG} new CSG object , scaled by the given amount\n *\n * @example\n * let scaledSphere = scale([0.2,15,1], sphere())\n */\nfunction scale(scale, ...objects) {         // v, obj or array\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  return object.scale(scale);\n}\n\n/** rotate an object in 2D/3D space\n * @param {Float|Array} rotation - either an array or simple number to rotate object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to rotate\n * @returns {CSG} new CSG object , rotated by the given amount\n *\n * @example\n * let rotatedSphere = rotate([0.2,15,1], sphere())\n */\nfunction rotate() {\n  let o;\n  let i;\n  let v;\n  let r = 1;\n  let a = arguments;\n  if (!a[0].length) {        // rotate(r,[x,y,z],o)\n    r = a[0];\n    v = a[1];\n    i = 2;\n    if (a[2].length) {\n      a = a[2];\n      i = 0;\n    }\n  } else {                   // rotate([x,y,z],o)\n    v = a[0];\n    i = 1;\n    if (a[1].length) {\n      a = a[1];\n      i = 0;\n    }\n  }\n  for (o = a[i++]; i < a.length; i++) {\n    o = o.union(a[i]);\n  }\n  if (r !== 1) {\n    return o.rotate([0, 0, 0], v, r);\n  } else {\n    return o.rotateX(v[0]).rotateY(v[1]).rotateZ(v[2]);\n  }\n}\n\n/** apply the given matrix transform to the given objects\n * @param {Array} matrix - the 4x4 matrix to apply, as a simple 1d array of 16 elements\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to transform\n * @returns {CSG} new CSG object , transformed\n *\n * @example\n * const angle = 45\n * let transformedShape = transform([\n * cos(angle), -sin(angle), 0, 10,\n * sin(angle),  cos(angle), 0, 20,\n * 0         ,           0, 1, 30,\n * 0,           0, 0,  1\n * ], sphere())\n */\nfunction transform(matrix, ...objects) { // v, obj or array\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n\n  let transformationMatrix;\n  if (!Array.isArray(matrix)) {\n    throw new Error('Matrix needs to be an array');\n  }\n  matrix.forEach(element => {\n    if (!Number.isFinite(element)) {\n      throw new Error('you can only use a flat array of valid, finite numbers (float and integers)');\n    }\n  });\n  transformationMatrix = new Matrix4(matrix);\n  return object.transform(transformationMatrix);\n}\n\n\n/**\n * Center the given object(s) about the given axes\n * @param {Array|Boolean} axes=[true,true,true]|true  - an array of boolean values that indicate the axes (X,Y,Z) to center upon. A single boolean is also allowed.\n * @param {...Object} object one or more objects to center, i.e. objects are CSG or CAG\n * @returns {CSG} new CSG object , translated by the given amount\n *\n * @example\n * let csg = center([true,false,false], sphere()) // center about the X axis\n */\nfunction center(axes, ...objects) {\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  if (!Array.isArray(axes)) {\n    axes = [axes, axes, axes];\n  }\n  return object.center(axes);\n}\n\n/** mirror an object in 2D/3D space\n * @param {Array} vector - the axes to mirror the object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to mirror\n * @returns {CSG} new CSG object , mirrored\n *\n * @example\n * let rotatedSphere = mirror([0.2,15,1], sphere())\n */\nfunction mirror(vector, ...objects) {\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  const plane = new Plane(new Vector3(vector[0], vector[1], vector[2]).unit(), 0);\n  return object.mirrored(plane);\n}\n\n/** expand an object in 2D/3D space\n * @param {float} radius - the radius to expand by\n * @param {Object} object a CSG/CAG objects to expand\n * @returns {CSG/CAG} new CSG/CAG object , expanded\n *\n * @example\n * let expanededShape = expand([0.2,15,1], sphere())\n */\nfunction expand(radius, n, object) {\n  return object.expand(radius, n);\n}\n\n/** contract an object(s) in 2D/3D space\n * @param {float} radius - the radius to contract by\n * @param {Object} object a CSG/CAG objects to contract\n * @returns {CSG/CAG} new CSG/CAG object , contracted\n *\n * @example\n * let contractedShape = contract([0.2,15,1], sphere())\n */\nfunction contract(radius, n, object) {\n  return object.contract(radius, n);\n}\n\n/** create a minkowski sum of the given shapes\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to create a hull around\n * @returns {CSG} new CSG object , mirrored\n *\n * @example\n * let hulled = hull(rect(), circle())\n */\nfunction minkowski() {\n  console.log('minkowski() not yet implemented');\n}\n\n/** create a convex hull of the given shapes\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to create a hull around\n * @returns {CSG} new CSG object , a hull around the given shapes\n *\n * @example\n * let hulled = hull(rect(), circle())\n */\nfunction hull() {\n  let pts = [];\n\n  let a = arguments;\n  if (a[0].length) a = a[0];\n  let done = [];\n\n  for (let i = 0; i < a.length; i++) {              // extract all points of the CAG in the argument list\n    let cag = a[i];\n    if (!isCAG(cag)) {\n      throw new Error('ERROR: hull() accepts only 2D forms / CAG');\n    }\n    for (let j = 0; j < cag.sides.length; j++) {\n      let x = cag.sides[j].vertex0.pos.x;\n      let y = cag.sides[j].vertex0.pos.y;\n      // avoid some coord to appear multiple times\n      if (done['' + x + ',' + y]) {\n        continue;\n      }\n      pts.push({x: x, y: y});\n      done['' + x + ',' + y]++;\n      // echo(x,y);\n    }\n  }\n  // echo(pts.length+\" points in\",pts);\n\n  // from http://www.psychedelicdevelopment.com/grahamscan/\n  //    see also at https://github.com/bkiers/GrahamScan/blob/master/src/main/cg/GrahamScan.java\n  let ConvexHullPoint = function (i, a, d) {\n    this.index = i;\n    this.angle = a;\n    this.distance = d;\n\n    this.compare = function (p) {\n      if (this.angle < p.angle) {\n        return -1;\n      } else if (this.angle > p.angle) {\n        return 1;\n      } else {\n        if (this.distance < p.distance) {\n          return -1;\n        } else if (this.distance > p.distance) {\n          return 1;\n        }\n      }\n      return 0;\n    };\n  };\n\n  let ConvexHull = function () {\n    this.points = null;\n    this.indices = null;\n\n    this.getIndices = function () {\n      return this.indices;\n    };\n\n    this.clear = function () {\n      this.indices = null;\n      this.points = null;\n    };\n\n    this.ccw = function (p1, p2, p3) {\n      let ccw = (this.points[p2].x - this.points[p1].x) * (this.points[p3].y - this.points[p1].y) -\n        (this.points[p2].y - this.points[p1].y) * (this.points[p3].x - this.points[p1].x);\n      // we need this, otherwise sorting never ends, see https://github.com/Spiritdude/OpenJSCAD.org/issues/18\n      if (ccw < 1e-5) {\n        return 0;\n      }\n      return ccw;\n    };\n\n    this.angle = function (o, a) {\n      // return Math.atan((this.points[a].y-this.points[o].y) / (this.points[a].x - this.points[o].x));\n      return Math.atan2((this.points[a].y - this.points[o].y), (this.points[a].x - this.points[o].x));\n    };\n\n    this.distance = function (a, b) {\n      return ((this.points[b].x - this.points[a].x) * (this.points[b].x - this.points[a].x) +\n        (this.points[b].y - this.points[a].y) * (this.points[b].y - this.points[a].y));\n    };\n\n    this.compute = function (_points) {\n      this.indices = null;\n      if (_points.length < 3) {\n        return;\n      }\n      this.points = _points;\n\n      // Find the lowest point\n      let min = 0;\n      for (let i = 1; i < this.points.length; i++) {\n        if (this.points[i].y === this.points[min].y) {\n          if (this.points[i].x < this.points[min].x) {\n            min = i;\n          }\n        } else if (this.points[i].y < this.points[min].y) {\n          min = i;\n        }\n      }\n\n      // Calculate angle and distance from base\n      let al = [];\n      let ang = 0.0;\n      let dist = 0.0;\n      for (let i = 0; i < this.points.length; i++) {\n        if (i === min) {\n          continue;\n        }\n        ang = this.angle(min, i);\n        if (ang < 0) {\n          ang += Math.PI;\n        }\n        dist = this.distance(min, i);\n        al.push(new ConvexHullPoint(i, ang, dist));\n      }\n\n      al.sort(function (a, b) {\n        return a.compare(b);\n      });\n\n      // Create stack\n      let stack = new Array(this.points.length + 1);\n      let j = 2;\n      for (let i = 0; i < this.points.length; i++) {\n        if (i === min) {\n          continue;\n        }\n        stack[j] = al[j - 2].index;\n        j++;\n      }\n      stack[0] = stack[this.points.length];\n      stack[1] = min;\n\n      let tmp;\n      let M = 2;\n      for (let i = 3; i <= this.points.length; i++) {\n        while (this.ccw(stack[M - 1], stack[M], stack[i]) <= 0) {\n          M--;\n        }\n        M++;\n        tmp = stack[i];\n        stack[i] = stack[M];\n        stack[M] = tmp;\n      }\n\n      this.indices = new Array(M);\n      for (let i = 0; i < M; i++) {\n        this.indices[i] = stack[i + 1];\n      }\n    };\n  };\n\n  let hull = new ConvexHull();\n\n  hull.compute(pts);\n  let indices = hull.getIndices();\n\n  if (indices && indices.length > 0) {\n    let ch = [];\n    for (let i = 0; i < indices.length; i++) {\n      ch.push(pts[indices[i]]);\n    }\n    return fromPoints(ch);\n  }\n}\n\n/** create a chain hull of the given shapes\n * Originally \"Whosa whatsis\" suggested \"Chain Hull\" ,\n * as described at https://plus.google.com/u/0/105535247347788377245/posts/aZGXKFX1ACN\n * essentially hull A+B, B+C, C+D and then union those\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to create a chain hull around\n * @returns {CSG} new CSG object ,which a chain hull of the inputs\n *\n * @example\n * let hulled = chain_hull(rect(), circle())\n */\nfunction chain_hull(params, objects) {\n  /*\n  const defaults = {\n    closed: false\n  }\n  const closed = Object.assign({}, defaults, params) */\n  let a = arguments;\n  let closed = false;\n  let j = 0;\n\n  if (a[j].closed !== undefined) {\n    closed = a[j++].closed;\n  }\n\n  if (a[j].length) {\n    a = a[j];\n  }\n\n  let hulls = [];\n  let hullsAmount = a.length - (closed ? 0 : 1);\n  for (let i = 0; i < hullsAmount; i++) {\n    hulls.push(hull(a[i], a[(i + 1) % a.length]));\n  }\n  return union(hulls);\n}\n\nmodule.exports = {\n  translate,\n  center,\n  scale,\n  rotate,\n  transform,\n  mirror,\n  expand,\n  contract,\n  minkowski,\n  hull,\n  chain_hull\n};\n","export * from './api/index';\n","export const primitives3d = require('./primitives3d-api');\nexport const primitives2d = require('./primitives2d-api');\nexport * as booleanOps from '../modifiers/boolean';\nexport const transformations = require('../modifiers/transforms/ops-transformations');\nexport const extrusions = require('./ops-extrusions');\nexport const color = require('./color');\nexport const maths = require('./maths');\nexport const text = require('./text');\n\n// these are 'external' to this api and we basically just re-export for old api compatibility\n// ...needs to be reviewed\nexport const {CAG, CSG, isCAG, isCSG} = require('../csg');\n","/// //////////FUNCTIONAL API\nconst {CSG} = require('../csg');\nconst {circle} = require('./primitives2d-api');\nconst {rotate_extrude} = require('./ops-extrusions');\nconst {translate, scale} = require('../modifiers/transforms/ops-transformations');\nconst Polygon3 = require('../core/math/Polygon3');\nconst Vector3 = require('../core/math/Vector3');\nconst Vertex3 = require('../core/math/Vertex3');\n\n/** Construct a cuboid\n * @param {Object} [options] - options for construction\n * @param {Float} [options.size=1] - size of the side of the cuboid : can be either:\n * - a scalar : ie a single float, in which case all dimensions will be the same\n * - or an array: to specify different dimensions along x/y/z\n * @param {Integer} [options.fn=32] - segments of the sphere (ie quality/resolution)\n * @param {Integer} [options.fno=32] - segments of extrusion (ie quality)\n * @param {String} [options.type='normal'] - type of sphere : either 'normal' or 'geodesic'\n * @returns {CSG} new sphere\n *\n * @example\n * let cube1 = cube({\n *   r: 10,\n *   fn: 20\n * })\n */\nfunction cube(params) {\n  const defaults = {\n    size: 1,\n    offset: [0, 0, 0],\n    round: false,\n    radius: 0,\n    fn: 8\n  };\n\n  let {round, radius, fn, size} = Object.assign({}, defaults, params);\n  let offset = [0, 0, 0];\n  let v = null;\n  if (params && params.length) v = params;\n  if (params && params.size && params.size.length) v = params.size; // { size: [1,2,3] }\n  if (params && params.size && !params.size.length) size = params.size; // { size: 1 }\n  if (params && (typeof params !== 'object')) size = params;// (2)\n  if (params && params.round === true) {\n    round = true;\n    radius = v && v.length ? (v[0] + v[1] + v[2]) / 30 : size / 10;\n  }\n  if (params && params.radius) {\n    round = true;\n    radius = params.radius;\n  }\n\n  let x = size;\n  let y = size;\n  let z = size;\n  if (v && v.length) {\n    [x, y, z] = v;\n  }\n  offset = [x / 2, y / 2, z / 2]; // center: false default\n  let object = round\n    ? CSG.roundedCube({radius: [x / 2, y / 2, z / 2], roundradius: radius, resolution: fn})\n    : CSG.cube({radius: [x / 2, y / 2, z / 2]});\n  if (params && params.center && params.center.length) {\n    offset = [params.center[0] ? 0 : x / 2, params.center[1] ? 0 : y / 2, params.center[2] ? 0 : z / 2];\n  } else if (params && params.center === true) {\n    offset = [0, 0, 0];\n  } else if (params && params.center === false) {\n    offset = [x / 2, y / 2, z / 2];\n  }\n  return (offset[0] || offset[1] || offset[2]) ? translate(offset, object) : object;\n}\n\n/** Construct a sphere\n * @param {Object} [options] - options for construction\n * @param {Float} [options.r=1] - radius of the sphere\n * @param {Integer} [options.fn=32] - segments of the sphere (ie quality/resolution)\n * @param {Integer} [options.fno=32] - segments of extrusion (ie quality)\n * @param {String} [options.type='normal'] - type of sphere : either 'normal' or 'geodesic'\n * @returns {CSG} new sphere\n *\n * @example\n * let sphere1 = sphere({\n *   r: 10,\n *   fn: 20\n * })\n */\nfunction sphere(params) {\n  const defaults = {\n    r: 1,\n    fn: 32,\n    type: 'normal'\n  };\n\n  let {r, fn, type} = Object.assign({}, defaults, params);\n  let offset = [0, 0, 0]; // center: false (default)\n  if (params && (typeof params !== 'object')) {\n    r = params;\n  }\n  // let zoffset = 0 // sphere() in openscad has no center:true|false\n\n  let output = type === 'geodesic' ? geodesicSphere(params) : CSG.sphere({radius: r, resolution: fn});\n\n  // preparing individual x,y,z center\n  if (params && params.center && params.center.length) {\n    offset = [params.center[0] ? 0 : r, params.center[1] ? 0 : r, params.center[2] ? 0 : r];\n  } else if (params && params.center === true) {\n    offset = [0, 0, 0];\n  } else if (params && params.center === false) {\n    offset = [r, r, r];\n  }\n  return (offset[0] || offset[1] || offset[2]) ? translate(offset, output) : output;\n}\n\nfunction geodesicSphere(params) {\n  const defaults = {\n    r: 1,\n    fn: 5\n  };\n  let {r, fn} = Object.assign({}, defaults, params);\n\n  let ci = [ // hard-coded data of icosahedron (20 faces, all triangles)\n    [0.850651, 0.000000, -0.525731],\n    [0.850651, -0.000000, 0.525731],\n    [-0.850651, -0.000000, 0.525731],\n    [-0.850651, 0.000000, -0.525731],\n    [0.000000, -0.525731, 0.850651],\n    [0.000000, 0.525731, 0.850651],\n    [0.000000, 0.525731, -0.850651],\n    [0.000000, -0.525731, -0.850651],\n    [-0.525731, -0.850651, -0.000000],\n    [0.525731, -0.850651, -0.000000],\n    [0.525731, 0.850651, 0.000000],\n    [-0.525731, 0.850651, 0.000000]];\n\n  let ti = [[0, 9, 1], [1, 10, 0], [6, 7, 0], [10, 6, 0], [7, 9, 0], [5, 1, 4], [4, 1, 9], [5, 10, 1], [2, 8, 3], [3, 11, 2], [2, 5, 4],\n    [4, 8, 2], [2, 11, 5], [3, 7, 6], [6, 11, 3], [8, 7, 3], [9, 8, 4], [11, 10, 5], [10, 11, 6], [8, 9, 7]];\n\n  let geodesicSubDivide = function (p, fn, offset) {\n    let p1 = p[0];\n    let p2 = p[1];\n    let p3 = p[2];\n    let n = offset;\n    let c = [];\n    let f = [];\n\n    //           p3\n    //           /\\\n    //          /__\\     fn = 3\n    //      i  /\\  /\\\n    //        /__\\/__\\       total triangles = 9 (fn*fn)\n    //       /\\  /\\  /\\\n    //     0/__\\/__\\/__\\\n    //    p1 0   j      p2\n\n    for (let i = 0; i < fn; i++) {\n      for (let j = 0; j < fn - i; j++) {\n        let t0 = i / fn;\n        let t1 = (i + 1) / fn;\n        let s0 = j / (fn - i);\n        let s1 = (j + 1) / (fn - i);\n        let s2 = fn - i - 1 ? j / (fn - i - 1) : 1;\n        let q = [];\n\n        q[0] = mix3(mix3(p1, p2, s0), p3, t0);\n        q[1] = mix3(mix3(p1, p2, s1), p3, t0);\n        q[2] = mix3(mix3(p1, p2, s2), p3, t1);\n\n        // -- normalize\n        for (let k = 0; k < 3; k++) {\n          let r = Math.sqrt(q[k][0] * q[k][0] + q[k][1] * q[k][1] + q[k][2] * q[k][2]);\n          for (let l = 0; l < 3; l++) {\n            q[k][l] /= r;\n          }\n        }\n        c.push(q[0], q[1], q[2]);\n        f.push([n, n + 1, n + 2]);\n        n += 3;\n\n        if (j < fn - i - 1) {\n          let s3 = fn - i - 1 ? (j + 1) / (fn - i - 1) : 1;\n          q[0] = mix3(mix3(p1, p2, s1), p3, t0);\n          q[1] = mix3(mix3(p1, p2, s3), p3, t1);\n          q[2] = mix3(mix3(p1, p2, s2), p3, t1);\n\n          // -- normalize\n          for (let k = 0; k < 3; k++) {\n            let r = Math.sqrt(q[k][0] * q[k][0] + q[k][1] * q[k][1] + q[k][2] * q[k][2]);\n            for (let l = 0; l < 3; l++) {\n              q[k][l] /= r;\n            }\n          }\n          c.push(q[0], q[1], q[2]);\n          f.push([n, n + 1, n + 2]);\n          n += 3;\n        }\n      }\n    }\n    return {points: c, triangles: f, offset: n};\n  };\n\n  const mix3 = function (a, b, f) {\n    let _f = 1 - f;\n    let c = [];\n    for (let i = 0; i < 3; i++) {\n      c[i] = a[i] * _f + b[i] * f;\n    }\n    return c;\n  };\n\n  if (params) {\n    if (params.fn) fn = Math.floor(params.fn / 6);\n  }\n\n  if (fn <= 0) fn = 1;\n\n  let c = [];\n  let f = [];\n  let offset = 0;\n\n  for (let i = 0; i < ti.length; i++) {\n    let g = geodesicSubDivide([ci[ti[i][0]], ci[ti[i][1]], ci[ti[i][2]]], fn, offset);\n    c = c.concat(g.points);\n    f = f.concat(g.triangles);\n    offset = g.offset;\n  }\n  return scale(r, polyhedron({points: c, triangles: f}));\n}\n\n/** Construct a cylinder\n * @param {Object} [options] - options for construction\n * @param {Float} [options.r=1] - radius of the cylinder\n * @param {Float} [options.r1=1] - radius of the top of the cylinder\n * @param {Float} [options.r2=1] - radius of the bottom of the cylinder\n * @param {Float} [options.d=1] - diameter of the cylinder\n * @param {Float} [options.d1=1] - diameter of the top of the cylinder\n * @param {Float} [options.d2=1] - diameter of the bottom of the cylinder\n * @param {Integer} [options.fn=32] - number of sides of the cylinder (ie quality/resolution)\n * @returns {CSG} new cylinder\n *\n * @example\n * let cylinder = cylinder({\n *   d: 10,\n *   fn: 20\n * })\n */\nfunction cylinder(params) {\n  const defaults = {\n    r: 1,\n    r1: 1,\n    r2: 1,\n    h: 1,\n    fn: 32,\n    round: false\n  };\n  let {r1, r2, h, fn, round} = Object.assign({}, defaults, params);\n  let offset = [0, 0, 0];\n  let a = arguments;\n  if (params && params.d) {\n    r1 = r2 = params.d / 2;\n  }\n  if (params && params.r) {\n    r1 = params.r;\n    r2 = params.r;\n  }\n  if (params && params.h) {\n    h = params.h;\n  }\n  if (params && (params.r1 || params.r2)) {\n    r1 = params.r1;\n    r2 = params.r2;\n    if (params.h) h = params.h;\n  }\n  if (params && (params.d1 || params.d2)) {\n    r1 = params.d1 / 2;\n    r2 = params.d2 / 2;\n  }\n\n  if (a && a[0] && a[0].length) {\n    a = a[0];\n    r1 = a[0];\n    r2 = a[1];\n    h = a[2];\n    if (a.length === 4) fn = a[3];\n  }\n\n  let object;\n  if (params && (params.start && params.end)) {\n    object = round\n      ? CSG.roundedCylinder({start: params.start, end: params.end, radiusStart: r1, radiusEnd: r2, resolution: fn})\n      : CSG.cylinder({start: params.start, end: params.end, radiusStart: r1, radiusEnd: r2, resolution: fn});\n  } else {\n    object = round\n      ? CSG.roundedCylinder({start: [0, 0, 0], end: [0, 0, h], radiusStart: r1, radiusEnd: r2, resolution: fn})\n      : CSG.cylinder({start: [0, 0, 0], end: [0, 0, h], radiusStart: r1, radiusEnd: r2, resolution: fn});\n    let r = r1 > r2 ? r1 : r2;\n    if (params && params.center && params.center.length) { // preparing individual x,y,z center\n      offset = [params.center[0] ? 0 : r, params.center[1] ? 0 : r, params.center[2] ? -h / 2 : 0];\n    } else if (params && params.center === true) {\n      offset = [0, 0, -h / 2];\n    } else if (params && params.center === false) {\n      offset = [0, 0, 0];\n    }\n    object = (offset[0] || offset[1] || offset[2]) ? translate(offset, object) : object;\n  }\n  return object;\n}\n\n/** Construct a torus\n * @param {Object} [options] - options for construction\n * @param {Float} [options.ri=1] - radius of base circle\n * @param {Float} [options.ro=4] - radius offset\n * @param {Integer} [options.fni=16] - segments of base circle (ie quality)\n * @param {Integer} [options.fno=32] - segments of extrusion (ie quality)\n * @param {Integer} [options.roti=0] - rotation angle of base circle\n * @returns {CSG} new torus\n *\n * @example\n * let torus1 = torus({\n *   ri: 10\n * })\n */\nfunction torus(params) {\n  const defaults = {\n    ri: 1,\n    ro: 4,\n    fni: 16,\n    fno: 32,\n    roti: 0\n  };\n  params = Object.assign({}, defaults, params);\n\n  /* possible enhancements ? declarative limits\n  const limits = {\n    fni: {min: 3},\n    fno: {min: 3}\n  } */\n\n  let {ri, ro, fni, fno, roti} = params;\n\n  if (fni < 3) fni = 3;\n  if (fno < 3) fno = 3;\n\n  let baseCircle = circle({r: ri, fn: fni, center: true});\n\n  if (roti) baseCircle = baseCircle.rotateZ(roti);\n  let result = rotate_extrude({fn: fno}, translate([ro, 0, 0], baseCircle));\n  // result = result.union(result)\n  return result;\n}\n\n/** Construct a polyhedron from the given triangles/ polygons/points\n * @param {Object} [options] - options for construction\n * @param {Array} [options.triangles] - triangles to build the polyhedron from\n * @param {Array} [options.polygons] - polygons to build the polyhedron from\n * @param {Array} [options.points] - points to build the polyhedron from\n * @param {Array} [options.colors] - colors to apply to the polyhedron\n * @returns {CSG} new polyhedron\n *\n * @example\n * let torus1 = polyhedron({\n *   points: [...]\n * })\n */\nfunction polyhedron(params) {\n  let pgs = [];\n  let ref = params.triangles || params.polygons;\n  let colors = params.colors || null;\n\n  for (let i = 0; i < ref.length; i++) {\n    let pp = [];\n    for (let j = 0; j < ref[i].length; j++) {\n      pp[j] = params.points[ref[i][j]];\n    }\n\n    let v = [];\n    for (let j = ref[i].length - 1; j >= 0; j--) { // --- we reverse order for examples of OpenSCAD work\n      v.push(new Vertex3(new Vector3(pp[j][0], pp[j][1], pp[j][2])));\n    }\n    let s = Polygon3.defaultShared;\n    if (colors && colors[i]) {\n      s = Polygon3.Shared.fromColor(colors[i]);\n    }\n    pgs.push(new Polygon3(v, s));\n  }\n\n  // forced to import here, otherwise out of order imports mess things up\n  const {fromPolygons} = require('../core/CSGFactories');\n  return fromPolygons(pgs);\n}\n\nmodule.exports = {\n  cube,\n  sphere,\n  cylinder,\n  geodesicSphere,\n  torus,\n  polyhedron\n};\n","const Matrix4x4 = require('./math/Matrix4');\nconst Vector3D = require('./math/Vector3');\nconst Plane = require('./math/Plane');\n\n// Add several convenience methods to the classes that support a transform() method:\nconst addTransformationMethodsToPrototype = function (prot) {\n  prot.mirrored = function (plane) {\n    return this.transform(Matrix4x4.mirroring(plane));\n  };\n\n  prot.mirroredX = function () {\n    let plane = new Plane(Vector3D.Create(1, 0, 0), 0);\n    return this.mirrored(plane);\n  };\n\n  prot.mirroredY = function () {\n    let plane = new Plane(Vector3D.Create(0, 1, 0), 0);\n    return this.mirrored(plane);\n  };\n\n  prot.mirroredZ = function () {\n    let plane = new Plane(Vector3D.Create(0, 0, 1), 0);\n    return this.mirrored(plane);\n  };\n\n  prot.translate = function (v) {\n    return this.transform(Matrix4x4.translation(v));\n  };\n\n  prot.scale = function (f) {\n    return this.transform(Matrix4x4.scaling(f));\n  };\n\n  prot.rotateX = function (deg) {\n    return this.transform(Matrix4x4.rotationX(deg));\n  };\n\n  prot.rotateY = function (deg) {\n    return this.transform(Matrix4x4.rotationY(deg));\n  };\n\n  prot.rotateZ = function (deg) {\n    return this.transform(Matrix4x4.rotationZ(deg));\n  };\n\n  prot.rotate = function (rotationCenter, rotationAxis, degrees) {\n    return this.transform(Matrix4x4.rotation(rotationCenter, rotationAxis, degrees));\n  };\n\n  prot.rotateEulerAngles = function (alpha, beta, gamma, position) {\n    position = position || [0, 0, 0];\n\n    let Rz1 = Matrix4x4.rotationZ(alpha);\n    let Rx = Matrix4x4.rotationX(beta);\n    let Rz2 = Matrix4x4.rotationZ(gamma);\n    let T = Matrix4x4.translation(new Vector3D(position));\n\n    return this.transform(Rz2.multiply(Rx).multiply(Rz1).multiply(T));\n  };\n\n  prot.rotateEulerXYZ = function (alpha, beta, gamma, position) {\n    position = position || [0, 0, 0];\n\n    let Rx = Matrix4x4.rotationX(alpha);\n    let Ry = Matrix4x4.rotationY(beta);\n    let Rz = Matrix4x4.rotationZ(gamma);\n    let T = Matrix4x4.translation(new Vector3D(position));\n\n    return this.transform(Rz.multiply(Ry).multiply(Rx).multiply(T));\n  };\n};\n\n// TODO: consider generalization and adding to addTransformationMethodsToPrototype\nconst addCenteringToPrototype = function (prot, axes) {\n  prot.center = function (cAxes) {\n    cAxes = Array.prototype.map.call(arguments, function (a) {\n      return a; // .toLowerCase();\n    });\n    // no args: center on all axes\n    if (!cAxes.length) {\n      cAxes = axes.slice();\n    }\n    let b = this.getBounds();\n    return this.translate(axes.map(function (a) {\n      return cAxes.indexOf(a) > -1 ? -(b[0][a] + b[1][a]) / 2 : 0;\n    }));\n  };\n};\nmodule.exports = {\n  addTransformationMethodsToPrototype,\n  addCenteringToPrototype\n};\n","const {_CSGDEBUG, EPS} = require('./constants');\nconst Vertex = require('./math/Vertex3');\nconst Polygon = require('./math/Polygon3');\n\nfunction calcInterpolationFactor(pointa, pointb, intermediatePoint) {\n  return pointa.distanceTo(intermediatePoint) / pointa.distanceTo(pointb);\n}\n\n// Returns object:\n// .type:\n//   0: coplanar-front\n//   1: coplanar-back\n//   2: front\n//   3: back\n//   4: spanning\n// In case the polygon is spanning, returns:\n// .front: a Polygon of the front part\n// .back: a Polygon of the back part\nfunction splitPolygonByPlane(plane, polygon) {\n  let result = {\n    type: null,\n    front: null,\n    back: null\n  };\n  // cache in local lets (speedup):\n  let planenormal = plane.normal;\n  let vertices = polygon.vertices;\n  let numvertices = vertices.length;\n  if (polygon.plane.equals(plane)) {\n    result.type = 0;\n  } else {\n    let thisw = plane.w;\n    let hasfront = false;\n    let hasback = false;\n    let vertexIsBack = [];\n    let MINEPS = -EPS;\n    for (let i = 0; i < numvertices; i++) {\n      let t = planenormal.dot(vertices[i].pos) - thisw;\n      let isback = (t < 0);\n      vertexIsBack.push(isback);\n      if (t > EPS) hasfront = true;\n      if (t < MINEPS) hasback = true;\n    }\n    if ((!hasfront) && (!hasback)) {\n      // all points coplanar\n      let t = planenormal.dot(polygon.plane.normal);\n      result.type = (t >= 0) ? 0 : 1;\n    } else if (!hasback) {\n      result.type = 2;\n    } else if (!hasfront) {\n      result.type = 3;\n    } else {\n      // spanning\n      result.type = 4;\n      let frontvertices = [];\n      let backvertices = [];\n      let isback = vertexIsBack[0];\n      for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n        let vertex = vertices[vertexindex];\n        let nextvertexindex = vertexindex + 1;\n        if (nextvertexindex >= numvertices) nextvertexindex = 0;\n        let nextisback = vertexIsBack[nextvertexindex];\n        if (isback === nextisback) {\n          // line segment is on one side of the plane:\n          if (isback) {\n            backvertices.push(vertex);\n          } else {\n            frontvertices.push(vertex);\n          }\n        } else {\n          // line segment intersects plane:\n          let point = vertex.pos;\n          let nextpoint = vertices[nextvertexindex].pos;\n          let interpolationFactor =\n            calcInterpolationFactor(point, nextpoint, plane.splitLineBetweenPoints(point, nextpoint));\n          let intersectionvertex = vertex.interpolate(vertices[nextvertexindex], interpolationFactor);\n          if (isback) {\n            backvertices.push(vertex);\n            backvertices.push(intersectionvertex);\n            frontvertices.push(intersectionvertex);\n          } else {\n            frontvertices.push(vertex);\n            frontvertices.push(intersectionvertex);\n            backvertices.push(intersectionvertex);\n          }\n        }\n        isback = nextisback;\n      } // for vertexindex\n      // remove duplicate vertices:\n      let EPS_SQUARED = EPS * EPS;\n      if (backvertices.length >= 3) {\n        let prevvertex = backvertices[backvertices.length - 1];\n        for (let vertexindex = 0; vertexindex < backvertices.length; vertexindex++) {\n          let vertex = backvertices[vertexindex];\n          if (vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {\n            backvertices.splice(vertexindex, 1);\n            vertexindex--;\n          }\n          prevvertex = vertex;\n        }\n      }\n      if (frontvertices.length >= 3) {\n        let prevvertex = frontvertices[frontvertices.length - 1];\n        for (let vertexindex = 0; vertexindex < frontvertices.length; vertexindex++) {\n          let vertex = frontvertices[vertexindex];\n          if (vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {\n            frontvertices.splice(vertexindex, 1);\n            vertexindex--;\n          }\n          prevvertex = vertex;\n        }\n      }\n      if (frontvertices.length >= 3) {\n        result.front = new Polygon(frontvertices, polygon.shared, polygon.plane);\n      }\n      if (backvertices.length >= 3) {\n        result.back = new Polygon(backvertices, polygon.shared, polygon.plane);\n      }\n    }\n  }\n  return result;\n}\n\n// # class PolygonTreeNode\n// This class manages hierarchical splits of polygons\n// At the top is a root node which doesn hold a polygon, only child PolygonTreeNodes\n// Below that are zero or more 'top' nodes; each holds a polygon. The polygons can be in different planes\n// splitByPlane() splits a node by a plane. If the plane intersects the polygon, two new child nodes\n// are created holding the splitted polygon.\n// getPolygons() retrieves the polygon from the tree. If for PolygonTreeNode the polygon is split but\n// the two split parts (child nodes) are still intact, then the unsplit polygon is returned.\n// This ensures that we can safely split a polygon into many fragments. If the fragments are untouched,\n//  getPolygons() will return the original unsplit polygon instead of the fragments.\n// remove() removes a polygon from the tree. Once a polygon is removed, the parent polygons are invalidated\n// since they are no longer intact.\n// constructor creates the root node:\nconst PolygonTreeNode = function () {\n  this.parent = null;\n  this.children = [];\n  this.polygon = null;\n  this.removed = false;\n};\n\nPolygonTreeNode.prototype = {\n  // fill the tree with polygons. Should be called on the root node only; child nodes must\n  // always be a derivate (split) of the parent node.\n  addPolygons: function (polygons) {\n    // new polygons can only be added to root node; children can only be splitted polygons\n    if (!this.isRootNode()) {\n      throw new Error('Assertion failed');\n    }\n    let _this = this;\n    polygons.map(function (polygon) {\n      _this.addChild(polygon);\n    });\n  },\n\n  // remove a node\n  // - the siblings become toplevel nodes\n  // - the parent is removed recursively\n  remove: function () {\n    if (!this.removed) {\n      this.removed = true;\n\n      if (_CSGDEBUG) {\n        if (this.isRootNode()) throw new Error('Assertion failed'); // can't remove root node\n        if (this.children.length) throw new Error('Assertion failed'); // we shouldn't remove nodes with children\n      }\n\n      // remove ourselves from the parent's children list:\n      let parentschildren = this.parent.children;\n      let i = parentschildren.indexOf(this);\n      if (i < 0) throw new Error('Assertion failed');\n      parentschildren.splice(i, 1);\n\n      // invalidate the parent's polygon, and of all parents above it:\n      this.parent.recursivelyInvalidatePolygon();\n    }\n  },\n\n  isRemoved: function () {\n    return this.removed;\n  },\n\n  isRootNode: function () {\n    return !this.parent;\n  },\n\n  // invert all polygons in the tree. Call on the root node\n  invert: function () {\n    if (!this.isRootNode()) throw new Error('Assertion failed'); // can only call this on the root node\n    this.invertSub();\n  },\n\n  getPolygon: function () {\n    if (!this.polygon) throw new Error('Assertion failed'); // doesn't have a polygon, which means that it has been broken down\n    return this.polygon;\n  },\n\n  getPolygons: function (result) {\n    let children = [this];\n    let queue = [children];\n    let i, j, l, node;\n    for (i = 0; i < queue.length; ++i) { // queue size can change in loop, don't cache length\n      children = queue[i];\n      for (j = 0, l = children.length; j < l; j++) { // ok to cache length\n        node = children[j];\n        if (node.polygon) {\n          // the polygon hasn't been broken yet. We can ignore the children and return our polygon:\n          result.push(node.polygon);\n        } else {\n          // our polygon has been split up and broken, so gather all subpolygons from the children\n          queue.push(node.children);\n        }\n      }\n    }\n  },\n\n  // split the node by a plane; add the resulting nodes to the frontnodes and backnodes array\n  // If the plane doesn't intersect the polygon, the 'this' object is added to one of the arrays\n  // If the plane does intersect the polygon, two new child nodes are created for the front and back fragments,\n  //  and added to both arrays.\n  splitByPlane: function (plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes) {\n    if (this.children.length) {\n      let queue = [this.children];\n      let i;\n      let j;\n      let l;\n      let node;\n      let nodes;\n      for (i = 0; i < queue.length; i++) { // queue.length can increase, do not cache\n        nodes = queue[i];\n        for (j = 0, l = nodes.length; j < l; j++) { // ok to cache length\n          node = nodes[j];\n          if (node.children.length) {\n            queue.push(node.children);\n          } else {\n            // no children. Split the polygon:\n            node._splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes);\n          }\n        }\n      }\n    } else {\n      this._splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes);\n    }\n  },\n\n  // only to be called for nodes with no children\n  _splitByPlane: function (plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes) {\n    let polygon = this.polygon;\n    if (polygon) {\n      let bound = polygon.boundingSphere();\n      let sphereradius = bound[1] + EPS; // FIXME Why add imprecision?\n      let planenormal = plane.normal;\n      let spherecenter = bound[0];\n      let d = planenormal.dot(spherecenter) - plane.w;\n      if (d > sphereradius) {\n        frontnodes.push(this);\n      } else if (d < -sphereradius) {\n        backnodes.push(this);\n      } else {\n        let splitresult = splitPolygonByPlane(plane, polygon);\n        switch (splitresult.type) {\n          case 0:\n            // coplanar front:\n            coplanarfrontnodes.push(this);\n            break;\n\n          case 1:\n            // coplanar back:\n            coplanarbacknodes.push(this);\n            break;\n\n          case 2:\n            // front:\n            frontnodes.push(this);\n            break;\n\n          case 3:\n            // back:\n            backnodes.push(this);\n            break;\n\n          case 4:\n            // spanning:\n            if (splitresult.front) {\n              let frontnode = this.addChild(splitresult.front);\n              frontnodes.push(frontnode);\n            }\n            if (splitresult.back) {\n              let backnode = this.addChild(splitresult.back);\n              backnodes.push(backnode);\n            }\n            break;\n        }\n      }\n    }\n  },\n\n  // PRIVATE methods from here:\n  // add child to a node\n  // this should be called whenever the polygon is split\n  // a child should be created for every fragment of the split polygon\n  // returns the newly created child\n  addChild: function (polygon) {\n    let newchild = new PolygonTreeNode();\n    newchild.parent = this;\n    newchild.polygon = polygon;\n    this.children.push(newchild);\n    return newchild;\n  },\n\n  invertSub: function () {\n    let children = [this];\n    let queue = [children];\n    let i, j, l, node;\n    for (i = 0; i < queue.length; i++) {\n      children = queue[i];\n      for (j = 0, l = children.length; j < l; j++) {\n        node = children[j];\n        if (node.polygon) {\n          node.polygon = node.polygon.flipped();\n        }\n        queue.push(node.children);\n      }\n    }\n  },\n\n  recursivelyInvalidatePolygon: function () {\n    let node = this;\n    while (node.polygon) {\n      node.polygon = null;\n      if (node.parent) {\n        node = node.parent;\n      }\n    }\n  }\n};\n\n// # class Tree\n// This is the root of a BSP tree\n// We are using this separate class for the root of the tree, to hold the PolygonTreeNode root\n// The actual tree is kept in this.rootnode\nconst Tree = function (polygons) {\n  this.polygonTree = new PolygonTreeNode();\n  this.rootnode = new Node(null);\n  if (polygons) this.addPolygons(polygons);\n};\n\nTree.prototype = {\n  invert: function () {\n    this.polygonTree.invert();\n    this.rootnode.invert();\n  },\n\n  // Remove all polygons in this BSP tree that are inside the other BSP tree\n  // `tree`.\n  clipTo: function (tree, alsoRemovecoplanarFront) {\n    alsoRemovecoplanarFront = !!alsoRemovecoplanarFront;\n    this.rootnode.clipTo(tree, alsoRemovecoplanarFront);\n  },\n\n  allPolygons: function () {\n    let result = [];\n    this.polygonTree.getPolygons(result);\n    return result;\n  },\n\n  addPolygons: function (polygons) {\n    let _this = this;\n    let polygontreenodes = polygons.map(function (p) {\n      return _this.polygonTree.addChild(p);\n    });\n    this.rootnode.addPolygonTreeNodes(polygontreenodes);\n  }\n};\n\n// # class Node\n// Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n// by picking a polygon to split along.\n// Polygons are not stored directly in the tree, but in PolygonTreeNodes, stored in\n// this.polygontreenodes. Those PolygonTreeNodes are children of the owning\n// Tree.polygonTree\n// This is not a leafy BSP tree since there is\n// no distinction between internal and leaf nodes.\nconst Node = function (parent) {\n  this.plane = null;\n  this.front = null;\n  this.back = null;\n  this.polygontreenodes = [];\n  this.parent = parent;\n};\n\nNode.prototype = {\n  // Convert solid space to empty space and empty space to solid space.\n  invert: function () {\n    let queue = [this];\n    let node;\n    for (let i = 0; i < queue.length; i++) {\n      node = queue[i];\n      if (node.plane) node.plane = node.plane.flipped();\n      if (node.front) queue.push(node.front);\n      if (node.back) queue.push(node.back);\n      let temp = node.front;\n      node.front = node.back;\n      node.back = temp;\n    }\n  },\n\n  // clip polygontreenodes to our plane\n  // calls remove() for all clipped PolygonTreeNodes\n  clipPolygons: function (polygontreenodes, alsoRemovecoplanarFront) {\n    let args = {'node': this, 'polygontreenodes': polygontreenodes};\n    let node;\n    let stack = [];\n\n    do {\n      node = args.node;\n      polygontreenodes = args.polygontreenodes;\n\n      // begin \"function\"\n      if (node.plane) {\n        let backnodes = [];\n        let frontnodes = [];\n        let coplanarfrontnodes = alsoRemovecoplanarFront ? backnodes : frontnodes;\n        let plane = node.plane;\n        let numpolygontreenodes = polygontreenodes.length;\n        for (let i = 0; i < numpolygontreenodes; i++) {\n          let node1 = polygontreenodes[i];\n          if (!node1.isRemoved()) {\n            node1.splitByPlane(plane, coplanarfrontnodes, backnodes, frontnodes, backnodes);\n          }\n        }\n\n        if (node.front && (frontnodes.length > 0)) {\n          stack.push({'node': node.front, 'polygontreenodes': frontnodes});\n        }\n        let numbacknodes = backnodes.length;\n        if (node.back && (numbacknodes > 0)) {\n          stack.push({'node': node.back, 'polygontreenodes': backnodes});\n        } else {\n          // there's nothing behind this plane. Delete the nodes behind this plane:\n          for (let i = 0; i < numbacknodes; i++) {\n            backnodes[i].remove();\n          }\n        }\n      }\n      args = stack.pop();\n    } while (typeof (args) !== 'undefined');\n  },\n\n  // Remove all polygons in this BSP tree that are inside the other BSP tree\n  // `tree`.\n  clipTo: function (tree, alsoRemovecoplanarFront) {\n    let node = this;\n    let stack = [];\n    do {\n      if (node.polygontreenodes.length > 0) {\n        tree.rootnode.clipPolygons(node.polygontreenodes, alsoRemovecoplanarFront);\n      }\n      if (node.front) stack.push(node.front);\n      if (node.back) stack.push(node.back);\n      node = stack.pop();\n    } while (typeof (node) !== 'undefined');\n  },\n\n  addPolygonTreeNodes: function (polygontreenodes) {\n    let args = {'node': this, 'polygontreenodes': polygontreenodes};\n    let node;\n    let stack = [];\n    do {\n      node = args.node;\n      polygontreenodes = args.polygontreenodes;\n\n      if (polygontreenodes.length === 0) {\n        args = stack.pop();\n        continue;\n      }\n      let _this = node;\n      if (!node.plane) {\n        let bestplane = polygontreenodes[0].getPolygon().plane;\n        node.plane = bestplane;\n      }\n      let frontnodes = [];\n      let backnodes = [];\n\n      for (let i = 0, n = polygontreenodes.length; i < n; ++i) {\n        polygontreenodes[i].splitByPlane(_this.plane, _this.polygontreenodes, backnodes, frontnodes, backnodes);\n      }\n\n      if (frontnodes.length > 0) {\n        if (!node.front) node.front = new Node(node);\n        stack.push({'node': node.front, 'polygontreenodes': frontnodes});\n      }\n      if (backnodes.length > 0) {\n        if (!node.back) node.back = new Node(node);\n        stack.push({'node': node.back, 'polygontreenodes': backnodes});\n      }\n\n      args = stack.pop();\n    } while (typeof (args) !== 'undefined');\n  },\n\n  getParentPlaneNormals: function (normals, maxdepth) {\n    if (maxdepth > 0) {\n      if (this.parent) {\n        normals.push(this.parent.plane.normal);\n        this.parent.getParentPlaneNormals(normals, maxdepth - 1);\n      }\n    }\n  }\n};\n\nmodule.exports = Tree;\n","const {EPS} = require('../constants');\nconst {solve2Linear} = require('../utils');\n\n// see if the line between p0start and p0end intersects with the line between p1start and p1end\n// returns true if the lines strictly intersect, the end points are not counted!\nconst linesIntersect = function (p0start, p0end, p1start, p1end) {\n  if (p0end.equals(p1start) || p1end.equals(p0start)) {\n    let d = p1end.minus(p1start).unit().plus(p0end.minus(p0start).unit()).length();\n    if (d < EPS) {\n      return true;\n    }\n  } else {\n    let d0 = p0end.minus(p0start);\n    let d1 = p1end.minus(p1start);\n    // FIXME These epsilons need review and testing\n    if (Math.abs(d0.cross(d1)) < 1e-9) return false; // lines are parallel\n    let alphas = solve2Linear(-d0.x, d1.x, -d0.y, d1.y, p0start.x - p1start.x, p0start.y - p1start.y);\n    if ((alphas[0] > 1e-6) && (alphas[0] < 0.999999) && (alphas[1] > 1e-5) && (alphas[1] < 0.999999)) return true;\n    // if( (alphas[0] >= 0) && (alphas[0] <= 1) && (alphas[1] >= 0) && (alphas[1] <= 1) ) return true;\n  }\n  return false;\n};\n\nmodule.exports = {linesIntersect};\n","const {isCAG} = require('../../core/utils');\n\n/** union/ combine the given shapes\n * @param {Object(s)|Array} objects - objects to combine : can be given\n * - one by one: union(a,b,c) or\n * - as an array: union([a,b,c])\n * @returns {CSG} new CSG object, the union of all input shapes\n *\n * @example\n * let unionOfSphereAndCube = union(sphere(), cube())\n */\nexport function union() {\n  const defaults = {\n    extrude2d: false,\n  };\n\n  let options = {...defaults};\n  let o;\n  let i = 0;\n  let a = arguments;\n\n  if (a[0].length) a = a[0];\n\n  if ('extrude2d' in a[0]) { // first parameter is options\n    options = Object.assign({}, defaults, a[0]);\n    o = a[i++];\n  }\n\n  o = a[i++];\n\n  // TODO: add option to be able to set this?\n  if ((typeof (a[i]) === 'object') && isCAG(a[i]) && options.extrude2d) {\n    o = a[i].extrude({offset: [0, 0, 0.1]}); // -- convert a 2D shape to a thin solid, note: do not a[i] = a[i].extrude()\n  }\n  for (; i < a.length; i++) {\n    let obj = a[i];\n\n    if ((typeof (a[i]) === 'object') && isCAG(a[i]) && options.extrude2d) {\n      obj = a[i].extrude({offset: [0, 0, 0.1]}); // -- convert a 2D shape to a thin solid:\n    }\n    o = o.union(obj);\n  }\n  return o;\n}\n","const {isCAG} = require('../../core/utils');\n\n/** difference/ subtraction of the given shapes ie:\n * cut out C From B From A ie : a - b - c etc\n * @param {Object(s)|Array} objects - objects to subtract\n * can be given\n * - one by one: difference(a,b,c) or\n * - as an array: difference([a,b,c])\n * @returns {CSG} new CSG object, the difference of all input shapes\n *\n * @example\n * let differenceOfSphereAndCube = difference(sphere(), cube())\n */\nexport function difference() {\n  let object;\n  let i = 0;\n  let a = arguments;\n  if (a[0].length) a = a[0];\n  for (object = a[i++]; i < a.length; i++) {\n    if (isCAG(a[i])) {\n      object = object.subtract(a[i]);\n    } else {\n      object = object.subtract(a[i].setColor(1, 1, 0)); // -- color the cuts\n    }\n  }\n  return object;\n}\n","const {isCAG} = require('../../core/utils');\n\n/** intersection of the given shapes: ie keep only the common parts between the given shapes\n * @param {Object(s)|Array} objects - objects to intersect\n * can be given\n * - one by one: intersection(a,b,c) or\n * - as an array: intersection([a,b,c])\n * @returns {CSG} new CSG object, the intersection of all input shapes\n *\n * @example\n * let intersectionOfSphereAndCube = intersection(sphere(), cube())\n */\nexport function intersection() {\n  let object;\n  let i = 0;\n  let a = arguments;\n  if (a[0].length) a = a[0];\n  for (object = a[i++]; i < a.length; i++) {\n    if (isCAG(a[i])) {\n      object = object.intersect(a[i]);\n    } else {\n      object = object.intersect(a[i].setColor(1, 1, 0)); // -- color the cuts\n    }\n  }\n  return object;\n}\n","const FuzzyFactory = require('./FuzzyFactory');\nconst {EPS} = require('./constants');\nconst Side = require('./math/Side');\n\nconst FuzzyCAGFactory = function () {\n  this.vertexfactory = new FuzzyFactory(2, EPS);\n};\n\nFuzzyCAGFactory.prototype = {\n  getVertex: function (sourcevertex) {\n    let elements = [sourcevertex.pos._x, sourcevertex.pos._y];\n    let result = this.vertexfactory.lookupOrCreate(elements, function (els) {\n      return sourcevertex;\n    });\n    return result;\n  },\n\n  getSide: function (sourceside) {\n    let vertex0 = this.getVertex(sourceside.vertex0);\n    let vertex1 = this.getVertex(sourceside.vertex1);\n    return new Side(vertex0, vertex1);\n  }\n};\n\nmodule.exports = FuzzyCAGFactory;\n","const {EPS} = require('../constants');\nconst OrthoNormalBasis = require('./OrthoNormalBasis');\nconst {interpolateBetween2DPointsForY, insertSorted, fnNumberSort} = require('../utils');\nconst Vertex = require('./Vertex3');\nconst Vector2D = require('./Vector2');\nconst Line2D = require('./Line2');\nconst Polygon = require('./Polygon3');\n\n\nconst calcInterpolationFactor = function (pointa, pointb, intermediatePoint) {\n  return pointa.distanceTo(intermediatePoint) / pointa.distanceTo(pointb);\n};\n\n// Retesselation function for a set of coplanar polygons. See the introduction at the top of\n// this file.\nconst reTesselateCoplanarPolygons = function (sourcepolygons, destpolygons) {\n  let numpolygons = sourcepolygons.length;\n  if (numpolygons > 0) {\n    let plane = sourcepolygons[0].plane;\n    let shared = sourcepolygons[0].shared;\n    let orthobasis = new OrthoNormalBasis(plane);\n    let polygonvertices2d = []; // array of array of Vector2D\n    let polygonuvcoordinates = []; // array of array of Vector2D\n    let polygontopvertexindexes = []; // array of indexes of topmost vertex per polygon\n    let topy2polygonindexes = {};\n    let ycoordinatetopolygonindexes = {};\n\n    let xcoordinatebins = {};\n    let ycoordinatebins = {};\n\n    // convert all polygon vertices to 2D\n    // Make a list of all encountered y coordinates\n    // And build a map of all polygons that have a vertex at a certain y coordinate:\n    let ycoordinateBinningFactor = 1.0 / EPS * 10;\n    for (let polygonindex = 0; polygonindex < numpolygons; polygonindex++) {\n      let poly3d = sourcepolygons[polygonindex];\n      let vertices2d = [];\n      let uvcoordinates = [];\n      let numvertices = poly3d.vertices.length;\n      let minindex = -1;\n      if (numvertices > 0) {\n        let miny, maxy, maxindex;\n        for (let i = 0; i < numvertices; i++) {\n          let pos2d = orthobasis.to2D(poly3d.vertices[i].pos);\n          let uvcoordinate = poly3d.vertices[i].uv;\n          // perform binning of y coordinates: If we have multiple vertices very\n          // close to each other, give them the same y coordinate:\n          let ycoordinatebin = Math.floor(pos2d.y * ycoordinateBinningFactor);\n          let newy;\n          if (ycoordinatebin in ycoordinatebins) {\n            newy = ycoordinatebins[ycoordinatebin];\n          } else if (ycoordinatebin + 1 in ycoordinatebins) {\n            newy = ycoordinatebins[ycoordinatebin + 1];\n          } else if (ycoordinatebin - 1 in ycoordinatebins) {\n            newy = ycoordinatebins[ycoordinatebin - 1];\n          } else {\n            newy = pos2d.y;\n            ycoordinatebins[ycoordinatebin] = pos2d.y;\n          }\n          pos2d = Vector2D.Create(pos2d.x, newy);\n          vertices2d.push(pos2d);\n          uvcoordinates.push(uvcoordinate);\n          let y = pos2d.y;\n          if ((i === 0) || (y < miny)) {\n            miny = y;\n            minindex = i;\n          }\n          if ((i === 0) || (y > maxy)) {\n            maxy = y;\n            maxindex = i;\n          }\n          if (!(y in ycoordinatetopolygonindexes)) {\n            ycoordinatetopolygonindexes[y] = {};\n          }\n          ycoordinatetopolygonindexes[y][polygonindex] = true;\n        }\n        if (miny >= maxy) {\n          // degenerate polygon, all vertices have same y coordinate. Just ignore it from now:\n          vertices2d = [];\n          uvcoordinates = [];\n          numvertices = 0;\n          minindex = -1;\n        } else {\n          if (!(miny in topy2polygonindexes)) {\n            topy2polygonindexes[miny] = [];\n          }\n          topy2polygonindexes[miny].push(polygonindex);\n        }\n      } // if(numvertices > 0)\n      // reverse the vertex order:\n      vertices2d.reverse();\n      uvcoordinates.reverse();\n      minindex = numvertices - minindex - 1;\n      polygonvertices2d.push(vertices2d);\n      polygonuvcoordinates.push(uvcoordinates);\n      polygontopvertexindexes.push(minindex);\n    }\n    let ycoordinates = [];\n    for (let ycoordinate in ycoordinatetopolygonindexes) ycoordinates.push(ycoordinate);\n    ycoordinates.sort(fnNumberSort);\n\n    // Now we will iterate over all y coordinates, from lowest to highest y coordinate\n    // activepolygons: source polygons that are 'active', i.e. intersect with our y coordinate\n    //   Is sorted so the polygons are in left to right order\n    // Each element in activepolygons has these properties:\n    //        polygonindex: the index of the source polygon (i.e. an index into the sourcepolygons\n    //                      and polygonvertices2d arrays)\n    //        leftvertexindex: the index of the vertex at the left side of the polygon (lowest x)\n    //                         that is at or just above the current y coordinate\n    //        rightvertexindex: dito at right hand side of polygon\n    //        topleft, bottomleft: coordinates of the left side of the polygon crossing the current y coordinate\n    //        topright, bottomright: coordinates of the right hand side of the polygon crossing the current y coordinate\n    let activepolygons = [];\n    let prevoutpolygonrow = [];\n    for (let yindex = 0; yindex < ycoordinates.length; yindex++) {\n      let newoutpolygonrow = [];\n      let ycoordinate_as_string = ycoordinates[yindex];\n      let ycoordinate = Number(ycoordinate_as_string);\n\n      // update activepolygons for this y coordinate:\n      // - Remove any polygons that end at this y coordinate\n      // - update leftvertexindex and rightvertexindex (which point to the current vertex index\n      //   at the the left and right side of the polygon\n      // Iterate over all polygons that have a corner at this y coordinate:\n      let polygonindexeswithcorner = ycoordinatetopolygonindexes[ycoordinate_as_string];\n      for (let activepolygonindex = 0; activepolygonindex < activepolygons.length; ++activepolygonindex) {\n        let activepolygon = activepolygons[activepolygonindex];\n        let polygonindex = activepolygon.polygonindex;\n        if (polygonindexeswithcorner[polygonindex]) {\n          // this active polygon has a corner at this y coordinate:\n          let vertices2d = polygonvertices2d[polygonindex];\n          let uvcoordinates = polygonuvcoordinates[polygonindex];\n          let numvertices = vertices2d.length;\n          let newleftvertexindex = activepolygon.leftvertexindex;\n          let newrightvertexindex = activepolygon.rightvertexindex;\n          // See if we need to increase leftvertexindex or decrease rightvertexindex:\n          while (true) {\n            let nextleftvertexindex = newleftvertexindex + 1;\n            if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;\n            if (vertices2d[nextleftvertexindex].y !== ycoordinate) break;\n            newleftvertexindex = nextleftvertexindex;\n          }\n          let nextrightvertexindex = newrightvertexindex - 1;\n          if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;\n          if (vertices2d[nextrightvertexindex].y === ycoordinate) {\n            newrightvertexindex = nextrightvertexindex;\n          }\n          if ((newleftvertexindex !== activepolygon.leftvertexindex) && (newleftvertexindex === newrightvertexindex)) {\n            // We have increased leftvertexindex or decreased rightvertexindex, and now they point to the same vertex\n            // This means that this is the bottom point of the polygon. We'll remove it:\n            activepolygons.splice(activepolygonindex, 1);\n            --activepolygonindex;\n          } else {\n            activepolygon.leftvertexindex = newleftvertexindex;\n            activepolygon.rightvertexindex = newrightvertexindex;\n            activepolygon.topleft = vertices2d[newleftvertexindex];\n            activepolygon.topleftuv = uvcoordinates[newleftvertexindex];\n            activepolygon.topright = vertices2d[newrightvertexindex];\n            activepolygon.toprightuv = uvcoordinates[newrightvertexindex];\n            let nextleftvertexindex = newleftvertexindex + 1;\n            if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;\n            activepolygon.bottomleft = vertices2d[nextleftvertexindex];\n            activepolygon.bottomleftuv = uvcoordinates[nextleftvertexindex];\n            let nextrightvertexindex = newrightvertexindex - 1;\n            if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;\n            activepolygon.bottomright = vertices2d[nextrightvertexindex];\n            activepolygon.bottomrightuv = uvcoordinates[nextrightvertexindex];\n          }\n        } // if polygon has corner here\n      } // for activepolygonindex\n      let nextycoordinate;\n      if (yindex >= ycoordinates.length - 1) {\n        // last row, all polygons must be finished here:\n        activepolygons = [];\n        nextycoordinate = null;\n      } else // yindex < ycoordinates.length-1\n      {\n        nextycoordinate = Number(ycoordinates[yindex + 1]);\n        let middleycoordinate = 0.5 * (ycoordinate + nextycoordinate);\n        // update activepolygons by adding any polygons that start here:\n        let startingpolygonindexes = topy2polygonindexes[ycoordinate_as_string];\n        for (let polygonindex_key in startingpolygonindexes) {\n          let polygonindex = startingpolygonindexes[polygonindex_key];\n          let vertices2d = polygonvertices2d[polygonindex];\n          let uvcoordinates = polygonuvcoordinates[polygonindex];\n          let numvertices = vertices2d.length;\n          let topvertexindex = polygontopvertexindexes[polygonindex];\n          // the top of the polygon may be a horizontal line. In that case topvertexindex can point to any point on this line.\n          // Find the left and right topmost vertices which have the current y coordinate:\n          let topleftvertexindex = topvertexindex;\n          while (true) {\n            let i = topleftvertexindex + 1;\n            if (i >= numvertices) i = 0;\n            if (vertices2d[i].y !== ycoordinate) break;\n            if (i === topvertexindex) break; // should not happen, but just to prevent endless loops\n            topleftvertexindex = i;\n          }\n          let toprightvertexindex = topvertexindex;\n          while (true) {\n            let i = toprightvertexindex - 1;\n            if (i < 0) i = numvertices - 1;\n            if (vertices2d[i].y !== ycoordinate) break;\n            if (i === topleftvertexindex) break; // should not happen, but just to prevent endless loops\n            toprightvertexindex = i;\n          }\n          let nextleftvertexindex = topleftvertexindex + 1;\n          if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;\n          let nextrightvertexindex = toprightvertexindex - 1;\n          if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;\n          let newactivepolygon = {\n            polygonindex: polygonindex,\n            leftvertexindex: topleftvertexindex,\n            rightvertexindex: toprightvertexindex,\n            topleft: vertices2d[topleftvertexindex],\n            topleftuv: uvcoordinates[topleftvertexindex],\n            topright: vertices2d[toprightvertexindex],\n            toprightuv: uvcoordinates[toprightvertexindex],\n            bottomleft: vertices2d[nextleftvertexindex],\n            bottomleftuv: uvcoordinates[nextleftvertexindex],\n            bottomright: vertices2d[nextrightvertexindex],\n            bottomrightuv: uvcoordinates[nextrightvertexindex]\n          };\n          insertSorted(activepolygons, newactivepolygon, function (el1, el2) {\n            let x1 = interpolateBetween2DPointsForY(\n              el1.topleft, el1.bottomleft, middleycoordinate);\n            let x2 = interpolateBetween2DPointsForY(\n              el2.topleft, el2.bottomleft, middleycoordinate);\n            if (x1 > x2) return 1;\n            if (x1 < x2) return -1;\n            return 0;\n          });\n        } // for(let polygonindex in startingpolygonindexes)\n      } //  yindex < ycoordinates.length-1\n      // if( (yindex === ycoordinates.length-1) || (nextycoordinate - ycoordinate > EPS) )\n      if (true) {\n        // Now activepolygons is up to date\n        // Build the output polygons for the next row in newoutpolygonrow:\n        for (let activepolygonKey in activepolygons) {\n          let activepolygon = activepolygons[activepolygonKey];\n          let polygonindex = activepolygon.polygonindex;\n          let vertices2d = polygonvertices2d[polygonindex];\n          let numvertices = vertices2d.length;\n\n          let x = interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, ycoordinate);\n          let topleft = Vector2D.Create(x, ycoordinate);\n          let topleftuv = activepolygon.topleftuv.lerp(activepolygon.bottomleftuv,\n            calcInterpolationFactor(activepolygon.topleft,\n              activepolygon.bottomleft,\n              topleft));\n          x = interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, ycoordinate);\n          let topright = Vector2D.Create(x, ycoordinate);\n          let toprightuv = activepolygon.toprightuv.lerp(activepolygon.bottomrightuv,\n            calcInterpolationFactor(activepolygon.topright,\n              activepolygon.bottomright,\n              topright));\n          x = interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, nextycoordinate);\n          let bottomleft = Vector2D.Create(x, nextycoordinate);\n          let bottomleftuv = activepolygon.topleftuv.lerp(activepolygon.bottomleftuv,\n            calcInterpolationFactor(activepolygon.topleft,\n              activepolygon.bottomleft,\n              bottomleft));\n          x = interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, nextycoordinate);\n          let bottomright = Vector2D.Create(x, nextycoordinate);\n          let bottomrightuv = activepolygon.toprightuv.lerp(activepolygon.bottomrightuv,\n            calcInterpolationFactor(activepolygon.topright,\n              activepolygon.bottomright,\n              bottomright));\n          let outpolygon = {\n            topleft: topleft,\n            topleftuv: topleftuv,\n            topright: topright,\n            toprightuv: toprightuv,\n            bottomleft: bottomleft,\n            bottomleftuv: bottomleftuv,\n            bottomright: bottomright,\n            bottomrightuv: bottomrightuv,\n            leftline: Line2D.fromPoints(topleft, bottomleft),\n            rightline: Line2D.fromPoints(bottomright, topright)\n          };\n          if (newoutpolygonrow.length > 0) {\n            let prevoutpolygon = newoutpolygonrow[newoutpolygonrow.length - 1];\n            let d1 = outpolygon.topleft.distanceTo(prevoutpolygon.topright);\n            let d2 = outpolygon.bottomleft.distanceTo(prevoutpolygon.bottomright);\n            if ((d1 < EPS) && (d2 < EPS)) {\n              // we can join this polygon with the one to the left:\n              outpolygon.topleft = prevoutpolygon.topleft;\n              outpolygon.topleftuv = prevoutpolygon.topleftuv;\n              outpolygon.leftline = prevoutpolygon.leftline;\n              outpolygon.bottomleft = prevoutpolygon.bottomleft;\n              outpolygon.bottomleftuv = prevoutpolygon.bottomleftuv;\n              newoutpolygonrow.splice(newoutpolygonrow.length - 1, 1);\n            }\n          }\n          newoutpolygonrow.push(outpolygon);\n        } // for(activepolygon in activepolygons)\n        if (yindex > 0) {\n          // try to match the new polygons against the previous row:\n          let prevcontinuedindexes = {};\n          let matchedindexes = {};\n          for (let i = 0; i < newoutpolygonrow.length; i++) {\n            let thispolygon = newoutpolygonrow[i];\n            for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {\n              if (!matchedindexes[ii]) // not already processed?\n              {\n                // We have a match if the sidelines are equal or if the top coordinates\n                // are on the sidelines of the previous polygon\n                let prevpolygon = prevoutpolygonrow[ii];\n                if (prevpolygon.bottomleft.distanceTo(thispolygon.topleft) < EPS) {\n                  if (prevpolygon.bottomright.distanceTo(thispolygon.topright) < EPS) {\n                    // Yes, the top of this polygon matches the bottom of the previous:\n                    matchedindexes[ii] = true;\n                    // Now check if the joined polygon would remain convex:\n                    let d1 = thispolygon.leftline.direction().x - prevpolygon.leftline.direction().x;\n                    let d2 = thispolygon.rightline.direction().x - prevpolygon.rightline.direction().x;\n                    let leftlinecontinues = Math.abs(d1) < EPS;\n                    let rightlinecontinues = Math.abs(d2) < EPS;\n                    let leftlineisconvex = leftlinecontinues || (d1 >= 0);\n                    let rightlineisconvex = rightlinecontinues || (d2 >= 0);\n                    if (leftlineisconvex && rightlineisconvex) {\n                      // yes, both sides have convex corners:\n                      // This polygon will continue the previous polygon\n                      thispolygon.outpolygon = prevpolygon.outpolygon;\n                      thispolygon.leftlinecontinues = leftlinecontinues;\n                      thispolygon.rightlinecontinues = rightlinecontinues;\n                      prevcontinuedindexes[ii] = true;\n                    }\n                    break;\n                  }\n                }\n              } // if(!prevcontinuedindexes[ii])\n            } // for ii\n          } // for i\n          for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {\n            if (!prevcontinuedindexes[ii]) {\n              // polygon ends here\n              // Finish the polygon with the last point(s):\n              let prevpolygon = prevoutpolygonrow[ii];\n              prevpolygon.outpolygon.rightpoints.push(prevpolygon.bottomright);\n              prevpolygon.outpolygon.rightuvcoordinates.push(prevpolygon.bottomrightuv);\n              if (prevpolygon.bottomright.distanceTo(prevpolygon.bottomleft) > EPS) {\n                // polygon ends with a horizontal line:\n                prevpolygon.outpolygon.leftpoints.push(prevpolygon.bottomleft);\n                prevpolygon.outpolygon.leftuvcoordinates.push(prevpolygon.bottomleftuv);\n              }\n              // reverse the left half so we get a counterclockwise circle:\n              prevpolygon.outpolygon.leftpoints.reverse();\n              prevpolygon.outpolygon.leftuvcoordinates.reverse();\n              let points2d = prevpolygon.outpolygon.rightpoints.concat(prevpolygon.outpolygon.leftpoints);\n              let uvcoordinates = prevpolygon.outpolygon.rightuvcoordinates.concat(prevpolygon.outpolygon.leftuvcoordinates);\n              let vertices3d = [];\n              points2d.map(function (point2d, i) {\n                let point3d = orthobasis.to3D(point2d);\n                let vertex3d = Vertex.fromPosAndUV(point3d, uvcoordinates[i]);\n                vertices3d.push(vertex3d);\n              });\n              let polygon = new Polygon(vertices3d, shared, plane);\n              destpolygons.push(polygon);\n            }\n          }\n        } // if(yindex > 0)\n        for (let i = 0; i < newoutpolygonrow.length; i++) {\n          let thispolygon = newoutpolygonrow[i];\n          if (!thispolygon.outpolygon) {\n            // polygon starts here:\n            thispolygon.outpolygon = {\n              leftpoints: [],\n              leftuvcoordinates: [],\n              rightpoints: [],\n              rightuvcoordinates: []\n            };\n            thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);\n            thispolygon.outpolygon.leftuvcoordinates.push(thispolygon.topleftuv);\n            if (thispolygon.topleft.distanceTo(thispolygon.topright) > EPS) {\n              // we have a horizontal line at the top:\n              thispolygon.outpolygon.rightpoints.push(thispolygon.topright);\n              thispolygon.outpolygon.rightuvcoordinates.push(thispolygon.toprightuv);\n            }\n          } else {\n            // continuation of a previous row\n            if (!thispolygon.leftlinecontinues) {\n              thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);\n              thispolygon.outpolygon.leftuvcoordinates.push(thispolygon.topleftuv);\n            }\n            if (!thispolygon.rightlinecontinues) {\n              thispolygon.outpolygon.rightpoints.push(thispolygon.topright);\n              thispolygon.outpolygon.rightuvcoordinates.push(thispolygon.toprightuv);\n            }\n          }\n        }\n        prevoutpolygonrow = newoutpolygonrow;\n      }\n    } // for yindex\n  } // if(numpolygons > 0)\n};\n\nmodule.exports = reTesselateCoplanarPolygons;\n","const Vector2D = require('../math/Vector2');\n\n// see http://local.wasp.uwa.edu.au/~pbourke/geometry/polyarea/ :\n// Area of the polygon. For a counter clockwise rotating polygon the area is positive, otherwise negative\n// Note(bebbi): this looks wrong. See polygon getArea()\nconst area = function (cag) {\n  let polygonArea = 0;\n  cag.sides.map(function (side) {\n    polygonArea += side.vertex0.pos.cross(side.vertex1.pos);\n  });\n  polygonArea *= 0.5;\n  return polygonArea;\n};\n\nconst getBounds = function (cag) {\n  let minpoint;\n  if (cag.sides.length === 0) {\n    minpoint = new Vector2D(0, 0);\n  } else {\n    minpoint = cag.sides[0].vertex0.pos;\n  }\n  let maxpoint = minpoint;\n  cag.sides.map(function (side) {\n    minpoint = minpoint.min(side.vertex0.pos);\n    minpoint = minpoint.min(side.vertex1.pos);\n    maxpoint = maxpoint.max(side.vertex0.pos);\n    maxpoint = maxpoint.max(side.vertex1.pos);\n  });\n  return [minpoint, maxpoint];\n};\n\nmodule.exports = {area, getBounds};\n","const Vertex3 = require('../core/math/Vertex3');\nconst Vector3 = require('../core/math/Vector3');\nconst Polygon3 = require('../core/math/Polygon3');\n\n// FIXME: this is to have more readable/less extremely verbose code below\nconst vertexFromVectorArray = array => {\n  return new Vertex3(new Vector3(array));\n};\n\nconst polygonFromPoints = points => {\n  // EEK talk about wrapping wrappers !\n  const vertices = points.map(point => new Vertex3(new Vector3(point)));\n  return new Polygon3(vertices);\n};\n\n// Simplified, array vector rightMultiply1x3Vector\nconst rightMultiply1x3VectorToArray = (matrix, vector) => {\n  const [v0, v1, v2] = vector;\n  const v3 = 1;\n  let x = v0 * matrix.elements[0] + v1 * matrix.elements[1] + v2 * matrix.elements[2] + v3 * matrix.elements[3];\n  let y = v0 * matrix.elements[4] + v1 * matrix.elements[5] + v2 * matrix.elements[6] + v3 * matrix.elements[7];\n  let z = v0 * matrix.elements[8] + v1 * matrix.elements[9] + v2 * matrix.elements[10] + v3 * matrix.elements[11];\n  let w = v0 * matrix.elements[12] + v1 * matrix.elements[13] + v2 * matrix.elements[14] + v3 * matrix.elements[15];\n\n  // scale such that fourth element becomes 1:\n  if (w !== 1) {\n    const invw = 1.0 / w;\n    x *= invw;\n    y *= invw;\n    z *= invw;\n  }\n  return [x, y, z];\n};\n\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\nconst cagToPointsArray = input => {\n  let points;\n  if ('sides' in input) { // this is a cag\n    points = [];\n    input.sides.forEach(side => {\n      points.push([side.vertex0.pos.x, side.vertex0.pos.y]);\n      points.push([side.vertex1.pos.x, side.vertex1.pos.y]);\n    });\n    // cag.sides.map(side => [side.vertex0.pos.x, side.vertex0.pos.y])\n    //, side.vertex1.pos.x, side.vertex1.pos.y])\n    // due to the logic of CAG.fromPoints()\n    // move the first point to the last\n    /* if (points.length > 0) {\n      points.push(points.shift())\n    } */\n  } else if ('points' in input) {\n    points = input.points.map(p => ([p.x, p.y]));\n  }\n\n  return points;\n};\n\nconst degToRad = deg => (Math.PI / 180) * deg;\n\nmodule.exports = {cagToPointsArray, clamp, rightMultiply1x3VectorToArray, polygonFromPoints};\n","const Path2D = require('../core/math/Path2');\n\nconst cagoutlinePaths = function (_cag) {\n  let cag = _cag.canonicalized();\n  let sideTagToSideMap = {};\n  let startVertexTagToSideTagMap = {};\n  cag.sides.map(function (side) {\n    let sidetag = side.getTag();\n    sideTagToSideMap[sidetag] = side;\n    let startvertextag = side.vertex0.getTag();\n    if (!(startvertextag in startVertexTagToSideTagMap)) {\n      startVertexTagToSideTagMap[startvertextag] = [];\n    }\n    startVertexTagToSideTagMap[startvertextag].push(sidetag);\n  });\n  let paths = [];\n  while (true) {\n    let startsidetag = null;\n    for (let aVertexTag in startVertexTagToSideTagMap) {\n      let sidesForcagVertex = startVertexTagToSideTagMap[aVertexTag];\n      startsidetag = sidesForcagVertex[0];\n      sidesForcagVertex.splice(0, 1);\n      if (sidesForcagVertex.length === 0) {\n        delete startVertexTagToSideTagMap[aVertexTag];\n      }\n      break;\n    }\n    if (startsidetag === null) break; // we've had all sides\n    let connectedVertexPoints = [];\n    let sidetag = startsidetag;\n    let cagside = sideTagToSideMap[sidetag];\n    let startvertextag = cagside.vertex0.getTag();\n    while (true) {\n      connectedVertexPoints.push(cagside.vertex0.pos);\n      let nextvertextag = cagside.vertex1.getTag();\n      if (nextvertextag === startvertextag) break; // we've closed the polygon\n      if (!(nextvertextag in startVertexTagToSideTagMap)) {\n        throw new Error('Area is not closed!');\n      }\n      let nextpossiblesidetags = startVertexTagToSideTagMap[nextvertextag];\n      let nextsideindex = -1;\n      if (nextpossiblesidetags.length === 1) {\n        nextsideindex = 0;\n      } else {\n        // more than one side starting at the same vertex. cag means we have\n        // two shapes touching at the same corner\n        let bestangle = null;\n        let cagangle = cagside.direction().angleDegrees();\n        for (let sideindex = 0; sideindex < nextpossiblesidetags.length; sideindex++) {\n          let nextpossiblesidetag = nextpossiblesidetags[sideindex];\n          let possibleside = sideTagToSideMap[nextpossiblesidetag];\n          let angle = possibleside.direction().angleDegrees();\n          let angledif = angle - cagangle;\n          if (angledif < -180) angledif += 360;\n          if (angledif >= 180) angledif -= 360;\n          if ((nextsideindex < 0) || (angledif > bestangle)) {\n            nextsideindex = sideindex;\n            bestangle = angledif;\n          }\n        }\n      }\n      let nextsidetag = nextpossiblesidetags[nextsideindex];\n      nextpossiblesidetags.splice(nextsideindex, 1);\n      if (nextpossiblesidetags.length === 0) {\n        delete startVertexTagToSideTagMap[nextvertextag];\n      }\n      cagside = sideTagToSideMap[nextsidetag];\n    } // inner loop\n    // due to the logic of fromPoints()\n    // move the first point to the last\n    if (connectedVertexPoints.length > 0) {\n      connectedVertexPoints.push(connectedVertexPoints.shift());\n    }\n    let path = new Path2D(connectedVertexPoints, true);\n    paths.push(path);\n  } // outer loop\n  return paths;\n};\n\nmodule.exports = cagoutlinePaths;\n","/* converts input data to array if it is not already an array */\nfunction toArray(data) {\n  if (!data) return [];\n  if (data.constructor !== Array) return [data];\n  return data;\n}\n\nmodule.exports = toArray;\n","const Polygon = require('../core/math/Polygon3');\nconst {fromPolygons} = require('../core/CSGFactories');\nconst {fnSortByIndex} = require('../core/utils');\n\n// FIXME: WHY is this for 3D polygons and not for 2D shapes ?\n/**\n * Creates solid from slices (Polygon) by generating walls\n * @param {Object} options Solid generating options\n *  - numslices {Number} Number of slices to be generated\n *  - callback(t, slice) {Function} Callback function generating slices.\n *          arguments: t = [0..1], slice = [0..numslices - 1]\n *          return: Polygon or null to skip\n *  - loop {Boolean} no flats, only walls, it's used to generate solids like a tor\n */\nconst solidFromSlices = function (polygon, options) {\n  let polygons = [];\n  let csg = null;\n  let prev = null;\n  let bottom = null;\n  let top = null;\n  let numSlices = 2;\n  let bLoop = false;\n  let fnCallback;\n  let flipped = null;\n\n  if (options) {\n    bLoop = Boolean(options['loop']);\n\n    if (options.numslices) {\n      numSlices = options.numslices;\n    }\n\n    if (options.callback) {\n      fnCallback = options.callback;\n    }\n  }\n  if (!fnCallback) {\n    let square = Polygon.createFromPoints([\n      [0, 0, 0],\n      [1, 0, 0],\n      [1, 1, 0],\n      [0, 1, 0]\n    ]);\n    fnCallback = function (t, slice) {\n      return t === 0 || t === 1 ? square.translate([0, 0, t]) : null;\n    };\n  }\n  for (let i = 0, iMax = numSlices - 1; i <= iMax; i++) {\n    csg = fnCallback.call(polygon, i / iMax, i);\n    if (csg) {\n      if (!(csg instanceof Polygon)) {\n        throw new Error('Polygon.solidFromSlices callback error: Polygon expected');\n      }\n      csg.checkIfConvex();\n\n      if (prev) { // generate walls\n        if (flipped === null) { // not generated yet\n          flipped = prev.plane.signedDistanceToPoint(csg.vertices[0].pos) < 0;\n        }\n        _addWalls(polygons, prev, csg, flipped);\n      } else { // the first - will be a bottom\n        bottom = csg;\n      }\n      prev = csg;\n    } // callback can return null to skip that slice\n  }\n  top = csg;\n\n  if (bLoop) {\n    let bSameTopBottom = bottom.vertices.length === top.vertices.length &&\n      bottom.vertices.every(function (v, index) {\n        return v.pos.equals(top.vertices[index].pos);\n      });\n    // if top and bottom are not the same -\n    // generate walls between them\n    if (!bSameTopBottom) {\n      _addWalls(polygons, top, bottom, flipped);\n    } // else - already generated\n  } else {\n    // save top and bottom\n    // TODO: flip if necessary\n    polygons.unshift(flipped ? bottom : bottom.flipped());\n    polygons.push(flipped ? top.flipped() : top);\n  }\n  return fromPolygons(polygons);\n};\n\n/**\n * @param walls Array of wall polygons\n * @param bottom Bottom polygon\n * @param top Top polygon\n */\nconst _addWalls = function (walls, bottom, top, bFlipped) {\n  let bottomPoints = bottom.vertices.slice(0); // make a copy\n  let topPoints = top.vertices.slice(0); // make a copy\n  let color = top.shared || null;\n\n  // check if bottom perimeter is closed\n  if (!bottomPoints[0].pos.equals(bottomPoints[bottomPoints.length - 1].pos)) {\n    bottomPoints.push(bottomPoints[0]);\n  }\n\n  // check if top perimeter is closed\n  if (!topPoints[0].pos.equals(topPoints[topPoints.length - 1].pos)) {\n    topPoints.push(topPoints[0]);\n  }\n  if (bFlipped) {\n    bottomPoints = bottomPoints.reverse();\n    topPoints = topPoints.reverse();\n  }\n\n  let iTopLen = topPoints.length - 1;\n  let iBotLen = bottomPoints.length - 1;\n  let iExtra = iTopLen - iBotLen;// how many extra triangles we need\n  let bMoreTops = iExtra > 0;\n  let bMoreBottoms = iExtra < 0;\n\n  let aMin = []; // indexes to start extra triangles (polygon with minimal square)\n  // init - we need exactly /iExtra/ small triangles\n  for (let i = Math.abs(iExtra); i > 0; i--) {\n    aMin.push({\n      len: Infinity,\n      index: -1\n    });\n  }\n\n  let len;\n  if (bMoreBottoms) {\n    for (let i = 0; i < iBotLen; i++) {\n      len = bottomPoints[i].pos.distanceToSquared(bottomPoints[i + 1].pos);\n      // find the element to replace\n      for (let j = aMin.length - 1; j >= 0; j--) {\n        if (aMin[j].len > len) {\n          aMin[j].len = len;\n          aMin.index = j;\n          break;\n        }\n      } // for\n    }\n  } else if (bMoreTops) {\n    for (let i = 0; i < iTopLen; i++) {\n      len = topPoints[i].pos.distanceToSquared(topPoints[i + 1].pos);\n      // find the element to replace\n      for (let j = aMin.length - 1; j >= 0; j--) {\n        if (aMin[j].len > len) {\n          aMin[j].len = len;\n          aMin.index = j;\n          break;\n        }\n      } // for\n    }\n  } // if\n  // sort by index\n  aMin.sort(fnSortByIndex);\n  let getTriangle = function addWallsPutTriangle(pointA, pointB, pointC, color) {\n    return new Polygon([pointA, pointB, pointC], color);\n    // return bFlipped ? triangle.flipped() : triangle;\n  };\n\n  let bpoint = bottomPoints[0];\n  let tpoint = topPoints[0];\n  let secondPoint;\n  let nBotFacet;\n  let nTopFacet; // length of triangle facet side\n  for (let iB = 0, iT = 0, iMax = iTopLen + iBotLen; iB + iT < iMax;) {\n    if (aMin.length) {\n      if (bMoreTops && iT === aMin[0].index) { // one vertex is on the bottom, 2 - on the top\n        secondPoint = topPoints[++iT];\n        // console.log('<<< extra top: ' + secondPoint + ', ' + tpoint + ', bottom: ' + bpoint);\n        walls.push(getTriangle(\n          secondPoint, tpoint, bpoint, color\n        ));\n        tpoint = secondPoint;\n        aMin.shift();\n        continue;\n      } else if (bMoreBottoms && iB === aMin[0].index) {\n        secondPoint = bottomPoints[++iB];\n        walls.push(getTriangle(\n          tpoint, bpoint, secondPoint, color\n        ));\n        bpoint = secondPoint;\n        aMin.shift();\n        continue;\n      }\n    }\n    // choose the shortest path\n    if (iB < iBotLen) { // one vertex is on the top, 2 - on the bottom\n      nBotFacet = tpoint.pos.distanceToSquared(bottomPoints[iB + 1].pos);\n    } else {\n      nBotFacet = Infinity;\n    }\n    if (iT < iTopLen) { // one vertex is on the bottom, 2 - on the top\n      nTopFacet = bpoint.pos.distanceToSquared(topPoints[iT + 1].pos);\n    } else {\n      nTopFacet = Infinity;\n    }\n    if (nBotFacet <= nTopFacet) {\n      secondPoint = bottomPoints[++iB];\n      walls.push(getTriangle(\n        tpoint, bpoint, secondPoint, color\n      ));\n      bpoint = secondPoint;\n    } else if (iT < iTopLen) { // nTopFacet < Infinity\n      secondPoint = topPoints[++iT];\n      // console.log('<<< top: ' + secondPoint + ', ' + tpoint + ', bottom: ' + bpoint);\n      walls.push(getTriangle(\n        secondPoint, tpoint, bpoint, color\n      ));\n      tpoint = secondPoint;\n    }\n    ;\n  }\n  return walls;\n};\n\nmodule.exports = solidFromSlices;\n","const {EPS} = require('../constants');\nconst Polygon = require('../math/Polygon3');\nconst Plane = require('../math/Plane');\n\nfunction addSide(sidemap, vertextag2sidestart, vertextag2sideend, vertex0, vertex1, polygonindex) {\n  let starttag = vertex0.getTag();\n  let endtag = vertex1.getTag();\n  if (starttag === endtag) throw new Error('Assertion failed');\n  let newsidetag = starttag + '/' + endtag;\n  let reversesidetag = endtag + '/' + starttag;\n  if (reversesidetag in sidemap) {\n    // we have a matching reverse oriented side.\n    // Instead of adding the new side, cancel out the reverse side:\n    // console.log(\"addSide(\"+newsidetag+\") has reverse side:\");\n    deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, vertex1, vertex0, null);\n    return null;\n  }\n  //  console.log(\"addSide(\"+newsidetag+\")\");\n  let newsideobj = {\n    vertex0: vertex0,\n    vertex1: vertex1,\n    polygonindex: polygonindex\n  };\n  if (!(newsidetag in sidemap)) {\n    sidemap[newsidetag] = [newsideobj];\n  } else {\n    sidemap[newsidetag].push(newsideobj);\n  }\n  if (starttag in vertextag2sidestart) {\n    vertextag2sidestart[starttag].push(newsidetag);\n  } else {\n    vertextag2sidestart[starttag] = [newsidetag];\n  }\n  if (endtag in vertextag2sideend) {\n    vertextag2sideend[endtag].push(newsidetag);\n  } else {\n    vertextag2sideend[endtag] = [newsidetag];\n  }\n  return newsidetag;\n}\n\nfunction deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, vertex0, vertex1, polygonindex) {\n  let starttag = vertex0.getTag();\n  let endtag = vertex1.getTag();\n  let sidetag = starttag + '/' + endtag;\n  // console.log(\"deleteSide(\"+sidetag+\")\");\n  if (!(sidetag in sidemap)) throw new Error('Assertion failed');\n  let idx = -1;\n  let sideobjs = sidemap[sidetag];\n  for (let i = 0; i < sideobjs.length; i++) {\n    let sideobj = sideobjs[i];\n    if (sideobj.vertex0 !== vertex0) continue;\n    if (sideobj.vertex1 !== vertex1) continue;\n    if (polygonindex !== null) {\n      if (sideobj.polygonindex !== polygonindex) continue;\n    }\n    idx = i;\n    break;\n  }\n  if (idx < 0) throw new Error('Assertion failed');\n  sideobjs.splice(idx, 1);\n  if (sideobjs.length === 0) {\n    delete sidemap[sidetag];\n  }\n  idx = vertextag2sidestart[starttag].indexOf(sidetag);\n  if (idx < 0) throw new Error('Assertion failed');\n  vertextag2sidestart[starttag].splice(idx, 1);\n  if (vertextag2sidestart[starttag].length === 0) {\n    delete vertextag2sidestart[starttag];\n  }\n\n  idx = vertextag2sideend[endtag].indexOf(sidetag);\n  if (idx < 0) throw new Error('Assertion failed');\n  vertextag2sideend[endtag].splice(idx, 1);\n  if (vertextag2sideend[endtag].length === 0) {\n    delete vertextag2sideend[endtag];\n  }\n}\n\n/*\n     fixTJunctions:\n\n     Suppose we have two polygons ACDB and EDGF:\n\n      A-----B\n      |     |\n      |     E--F\n      |     |  |\n      C-----D--G\n\n     Note that vertex E forms a T-junction on the side BD. In this case some STL slicers will complain\n     that the solid is not watertight. This is because the watertightness check is done by checking if\n     each side DE is matched by another side ED.\n\n     This function will return a new solid with ACDB replaced by ACDEB\n\n     Note that this can create polygons that are slightly non-convex (due to rounding errors). Therefore the result should\n     not be used for further CSG operations!\n*/\nconst fixTJunctions = function (fromPolygons, csg) {\n  csg = csg.canonicalized();\n  let sidemap = {};\n\n  // STEP 1\n  for (let polygonindex = 0; polygonindex < csg.polygons.length; polygonindex++) {\n    let polygon = csg.polygons[polygonindex];\n    let numvertices = polygon.vertices.length;\n    // should be true\n    if (numvertices >= 3) {\n      let vertex = polygon.vertices[0];\n      let vertextag = vertex.getTag();\n      for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n        let nextvertexindex = vertexindex + 1;\n        if (nextvertexindex === numvertices) nextvertexindex = 0;\n        let nextvertex = polygon.vertices[nextvertexindex];\n        let nextvertextag = nextvertex.getTag();\n        let sidetag = vertextag + '/' + nextvertextag;\n        let reversesidetag = nextvertextag + '/' + vertextag;\n        if (reversesidetag in sidemap) {\n          // this side matches the same side in another polygon. Remove from sidemap:\n          let ar = sidemap[reversesidetag];\n          ar.splice(-1, 1);\n          if (ar.length === 0) {\n            delete sidemap[reversesidetag];\n          }\n        } else {\n          let sideobj = {\n            vertex0: vertex,\n            vertex1: nextvertex,\n            polygonindex: polygonindex\n          };\n          if (!(sidetag in sidemap)) {\n            sidemap[sidetag] = [sideobj];\n          } else {\n            sidemap[sidetag].push(sideobj);\n          }\n        }\n        vertex = nextvertex;\n        vertextag = nextvertextag;\n      }\n    }\n  }\n  // STEP 2\n  // now sidemap contains 'unmatched' sides\n  // i.e. side AB in one polygon does not have a matching side BA in another polygon\n  let vertextag2sidestart = {};\n  let vertextag2sideend = {};\n  let sidestocheck = {};\n  let sidemapisempty = true;\n  for (let sidetag in sidemap) {\n    sidemapisempty = false;\n    sidestocheck[sidetag] = true;\n    sidemap[sidetag].map(function (sideobj) {\n      let starttag = sideobj.vertex0.getTag();\n      let endtag = sideobj.vertex1.getTag();\n      if (starttag in vertextag2sidestart) {\n        vertextag2sidestart[starttag].push(sidetag);\n      } else {\n        vertextag2sidestart[starttag] = [sidetag];\n      }\n      if (endtag in vertextag2sideend) {\n        vertextag2sideend[endtag].push(sidetag);\n      } else {\n        vertextag2sideend[endtag] = [sidetag];\n      }\n    });\n  }\n\n  // STEP 3 : if sidemap is not empty\n  if (!sidemapisempty) {\n    // make a copy of the polygons array, since we are going to modify it:\n    let polygons = csg.polygons.slice(0);\n    while (true) {\n      let sidemapisempty = true;\n      for (let sidetag in sidemap) {\n        sidemapisempty = false;\n        sidestocheck[sidetag] = true;\n      }\n      if (sidemapisempty) break;\n      let donesomething = false;\n      while (true) {\n        let sidetagtocheck = null;\n        for (let sidetag in sidestocheck) {\n          sidetagtocheck = sidetag;\n          break; // FIXME  : say what now ?\n        }\n        if (sidetagtocheck === null) break; // sidestocheck is empty, we're done!\n        let donewithside = true;\n        if (sidetagtocheck in sidemap) {\n          let sideobjs = sidemap[sidetagtocheck];\n          if (sideobjs.length === 0) throw new Error('Assertion failed');\n          let sideobj = sideobjs[0];\n          for (let directionindex = 0; directionindex < 2; directionindex++) {\n            let startvertex = (directionindex === 0) ? sideobj.vertex0 : sideobj.vertex1;\n            let endvertex = (directionindex === 0) ? sideobj.vertex1 : sideobj.vertex0;\n            let startvertextag = startvertex.getTag();\n            let endvertextag = endvertex.getTag();\n            let matchingsides = [];\n            if (directionindex === 0) {\n              if (startvertextag in vertextag2sideend) {\n                matchingsides = vertextag2sideend[startvertextag];\n              }\n            } else {\n              if (startvertextag in vertextag2sidestart) {\n                matchingsides = vertextag2sidestart[startvertextag];\n              }\n            }\n            for (let matchingsideindex = 0; matchingsideindex < matchingsides.length; matchingsideindex++) {\n              let matchingsidetag = matchingsides[matchingsideindex];\n              let matchingside = sidemap[matchingsidetag][0];\n              let matchingsidestartvertex = (directionindex === 0) ? matchingside.vertex0 : matchingside.vertex1;\n              let matchingsideendvertex = (directionindex === 0) ? matchingside.vertex1 : matchingside.vertex0;\n              let matchingsidestartvertextag = matchingsidestartvertex.getTag();\n              let matchingsideendvertextag = matchingsideendvertex.getTag();\n              if (matchingsideendvertextag !== startvertextag) throw new Error('Assertion failed');\n              if (matchingsidestartvertextag === endvertextag) {\n                // matchingside cancels sidetagtocheck\n                deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, startvertex, endvertex, null);\n                deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, endvertex, startvertex, null);\n                donewithside = false;\n                directionindex = 2; // skip reverse direction check\n                donesomething = true;\n                break;\n              } else {\n                let startpos = startvertex.pos;\n                let endpos = endvertex.pos;\n                let checkpos = matchingsidestartvertex.pos;\n                let direction = checkpos.minus(startpos);\n                // Now we need to check if endpos is on the line startpos-checkpos:\n                let t = endpos.minus(startpos).dot(direction) / direction.dot(direction);\n                if ((t > 0) && (t < 1)) {\n                  let closestpoint = startpos.plus(direction.times(t));\n                  let distancesquared = closestpoint.distanceToSquared(endpos);\n                  if (distancesquared < (EPS * EPS)) {\n                    // Yes it's a t-junction! We need to split matchingside in two:\n                    let polygonindex = matchingside.polygonindex;\n                    let polygon = polygons[polygonindex];\n                    // find the index of startvertextag in polygon:\n                    let insertionvertextag = matchingside.vertex1.getTag();\n                    let insertionvertextagindex = -1;\n                    for (let i = 0; i < polygon.vertices.length; i++) {\n                      if (polygon.vertices[i].getTag() === insertionvertextag) {\n                        insertionvertextagindex = i;\n                        break;\n                      }\n                    }\n                    if (insertionvertextagindex < 0) throw new Error('Assertion failed');\n                    // split the side by inserting the vertex:\n                    let newvertices = polygon.vertices.slice(0);\n                    newvertices.splice(insertionvertextagindex, 0, endvertex);\n                    let newpolygon = new Polygon(newvertices, polygon.shared /* polygon.plane */);\n\n                    // calculate plane with differents point\n                    if (isNaN(newpolygon.plane.w)) {\n                      let found = false;\n                      let loop = function (callback) {\n                        newpolygon.vertices.forEach(function (item) {\n                          if (found) return;\n                          callback(item);\n                        });\n                      };\n\n                      loop(function (a) {\n                        loop(function (b) {\n                          loop(function (c) {\n                            newpolygon.plane = Plane.fromPoints(a.pos, b.pos, c.pos);\n                            if (!isNaN(newpolygon.plane.w)) {\n                              found = true;\n                            }\n                          });\n                        });\n                      });\n                    }\n                    polygons[polygonindex] = newpolygon;\n                    // remove the original sides from our maps\n                    // deleteSide(sideobj.vertex0, sideobj.vertex1, null)\n                    deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, matchingside.vertex0, matchingside.vertex1, polygonindex);\n                    let newsidetag1 = addSide(sidemap, vertextag2sidestart, vertextag2sideend, matchingside.vertex0, endvertex, polygonindex);\n                    let newsidetag2 = addSide(sidemap, vertextag2sidestart, vertextag2sideend, endvertex, matchingside.vertex1, polygonindex);\n                    if (newsidetag1 !== null) sidestocheck[newsidetag1] = true;\n                    if (newsidetag2 !== null) sidestocheck[newsidetag2] = true;\n                    donewithside = false;\n                    directionindex = 2; // skip reverse direction check\n                    donesomething = true;\n                    break;\n                  } // if(distancesquared < 1e-10)\n                } // if( (t > 0) && (t < 1) )\n              } // if(endingstidestartvertextag === endvertextag)\n            } // for matchingsideindex\n          } // for directionindex\n        } // if(sidetagtocheck in sidemap)\n        if (donewithside) {\n          delete sidestocheck[sidetagtocheck];\n        }\n      }\n      if (!donesomething) break;\n    }\n    let newcsg = fromPolygons(polygons);\n    newcsg.properties = csg.properties;\n    newcsg.isCanonicalized = true;\n    newcsg.isRetesselated = true;\n    csg = newcsg;\n  }\n\n  // FIXME : what is even the point of this ???\n  /* sidemapisempty = true\n  for (let sidetag in sidemap) {\n    sidemapisempty = false\n    break\n  }\n  */\n\n  return csg;\n};\n\nmodule.exports = fixTJunctions;\n","const Vector3D = require('../math/Vector3');\n\n/**\n * Returns an array of Vector3D, providing minimum coordinates and maximum coordinates\n * of this solid.\n * @returns {Vector3D[]}\n * @example\n * let bounds = A.getBounds()\n * let minX = bounds[0].x\n */\nconst bounds = function (csg) {\n  if (!csg.cachedBoundingBox) {\n    let minpoint = new Vector3D(0, 0, 0);\n    let maxpoint = new Vector3D(0, 0, 0);\n    let polygons = csg.polygons;\n    let numpolygons = polygons.length;\n    for (let i = 0; i < numpolygons; i++) {\n      let polygon = polygons[i];\n      let bounds = polygon.boundingBox();\n      if (i === 0) {\n        minpoint = bounds[0];\n        maxpoint = bounds[1];\n      } else {\n        minpoint = minpoint.min(bounds[0]);\n        maxpoint = maxpoint.max(bounds[1]);\n      }\n    }\n    // FIXME: not ideal, we are mutating the input, we need to move some of it out\n    csg.cachedBoundingBox = [minpoint, maxpoint];\n  }\n  return csg.cachedBoundingBox;\n};\n\nconst volume = function (csg) {\n  let result = csg.toTriangles().map(function (triPoly) {\n    return triPoly.getTetraFeatures(['volume']);\n  });\n  console.log('volume', result);\n};\n\nconst area = function (csg) {\n  let result = csg.toTriangles().map(function (triPoly) {\n    return triPoly.getTetraFeatures(['area']);\n  });\n  console.log('area', result);\n};\n\nmodule.exports = {bounds, volume, area};\n","const CAG = require('../CAG'); // FIXME: circular dependency !\nconst {EPS} = require('../constants');\n\n// project the 3D CSG onto a plane\n// This returns a 2D CAG with the 'shadow' shape of the 3D solid when projected onto the\n// plane represented by the orthonormal basis\nconst projectToOrthoNormalBasis = function (csg, orthobasis) {\n  let cags = [];\n  csg.polygons.filter(function (p) {\n    // only return polys in plane, others may disturb result\n    return p.plane.normal.minus(orthobasis.plane.normal).lengthSquared() < (EPS * EPS);\n  })\n    .map(function (polygon) {\n      let cag = polygon.projectToOrthoNormalBasis(orthobasis);\n      if (cag.sides.length > 0) {\n        cags.push(cag);\n      }\n    });\n  let result = new CAG().union(cags);\n  return result;\n};\n\nmodule.exports = {projectToOrthoNormalBasis};\n","const {EPS} = require('../core/constants');\nconst Plane = require('../core/math/Plane');\nconst Vector2 = require('../core/math/Vector2');\nconst Vertex3 = require('../core/math/Vertex3');\nconst Polygon3 = require('../core/math/Polygon3');\nconst OrthoNormalBasis = require('../core/math/OrthoNormalBasis');\n\n/** cuts a csg along a orthobasis\n * @param  {CSG} csg the csg object to cut\n * @param  {Orthobasis} orthobasis the orthobasis to cut along\n */\nconst sectionCut = function (csg, orthobasis) {\n  let plane1 = orthobasis.plane;\n  let plane2 = orthobasis.plane.flipped();\n  plane1 = new Plane(plane1.normal, plane1.w);\n  plane2 = new Plane(plane2.normal, plane2.w + (5 * EPS));\n  let cut3d = csg.cutByPlane(plane1);\n  cut3d = cut3d.cutByPlane(plane2);\n  return cut3d.projectToOrthoNormalBasis(orthobasis);\n};\n\n/** Cut the solid by a plane. Returns the solid on the back side of the plane\n * @param  {Plane} plane\n * @returns {CSG} the solid on the back side of the plane\n */\nconst cutByPlane = function (csg, plane) {\n  if (csg.polygons.length === 0) {\n    const CSG = require('../core/CSG'); // FIXME: circular dependency ! CSG => cutByPlane => CSG\n    return new CSG();\n  }\n  // Ideally we would like to do an intersection with a polygon of inifinite size\n  // but this is not supported by our implementation. As a workaround, we will create\n  // a cube, with one face on the plane, and a size larger enough so that the entire\n  // solid fits in the cube.\n  // find the max distance of any vertex to the center of the plane:\n  let planecenter = plane.normal.times(plane.w);\n  let maxdistance = 0;\n  csg.polygons.map(function (polygon) {\n    polygon.vertices.map(function (vertex) {\n      let distance = vertex.pos.distanceToSquared(planecenter);\n      if (distance > maxdistance) maxdistance = distance;\n    });\n  });\n  maxdistance = Math.sqrt(maxdistance);\n  maxdistance *= 1.01; // make sure it's really larger\n  // Now build a polygon on the plane, at any point farther than maxdistance from the plane center:\n  let vertices = [];\n  let orthobasis = new OrthoNormalBasis(plane);\n  vertices.push(Vertex3.fromPosAndUV(orthobasis.to3D(new Vector2(maxdistance, -maxdistance)),\n    new Vector2(maxdistance, -maxdistance)));\n  vertices.push(Vertex3.fromPosAndUV(orthobasis.to3D(new Vector2(-maxdistance, -maxdistance)),\n    new Vector2(-maxdistance, -maxdistance)));\n  vertices.push(Vertex3.fromPosAndUV(orthobasis.to3D(new Vector2(-maxdistance, maxdistance)),\n    new Vector2(-maxdistance, maxdistance)));\n  vertices.push(Vertex3.fromPosAndUV(orthobasis.to3D(new Vector2(maxdistance, maxdistance)),\n    new Vector2(maxdistance, maxdistance)));\n  const polygon = new Polygon3(vertices, null, plane.flipped());\n\n  // and extrude the polygon into a cube, backwards of the plane:\n  const cube = polygon.extrude(plane.normal.times(-maxdistance));\n\n  // Now we can do the intersection:\n  let result = csg.intersect(cube);\n  result.properties = csg.properties; // keep original properties\n  return result;\n};\n\nmodule.exports = {sectionCut, cutByPlane};\n","const CAG = require('../core/CAG');\nconst {parseOptionAs2DVector, parseOptionAsFloat, parseOptionAsInt} = require('./optionParsers');\nconst {defaultResolution2D} = require('../core/constants');\nconst Vector2D = require('../core/math/Vector2');\nconst Vertex2 = require('../core/math/Vertex2');\nconst Path2D = require('../core/math/Path2');\nconst {fromCompactBinary, fromPoints, fromPath2, fromSides} = require('../core/CAGFactories');\n\n/** Construct a circle.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of circle\n * @param {Number} [options.radius=1] - radius of circle\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @returns {CAG} new CAG object\n */\nconst circle = function (options) {\n  options = options || {};\n  let center = parseOptionAs2DVector(options, 'center', [0, 0]);\n  let radius = parseOptionAsFloat(options, 'radius', 1);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n  let points = [];\n  for (let i = 0; i < resolution; i++) {\n    let radians = 2 * Math.PI * i / resolution;\n    let point = Vector2D.fromAngleRadians(radians).times(radius).plus(center);\n    points.push(point);\n  }\n  return fromPoints(points);\n};\n\n/** Construct an ellispe.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of ellipse\n * @param {Vector2D} [options.radius=[1,1]] - radius of ellipse, width and height\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @returns {CAG} new CAG object\n */\nconst ellipse = function (options) {\n  options = options || {};\n  let c = parseOptionAs2DVector(options, 'center', [0, 0]);\n  let r = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  r = r.abs(); // negative radii make no sense\n  let res = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n\n  let e2 = new Path2D([[c.x, c.y + r.y]]);\n  e2 = e2.appendArc([c.x, c.y - r.y], {\n    xradius: r.x,\n    yradius: r.y,\n    xaxisrotation: 0,\n    resolution: res,\n    clockwise: true,\n    large: false\n  });\n  e2 = e2.appendArc([c.x, c.y + r.y], {\n    xradius: r.x,\n    yradius: r.y,\n    xaxisrotation: 0,\n    resolution: res,\n    clockwise: true,\n    large: false\n  });\n  e2 = e2.close();\n  return fromPath2(e2);\n};\n\n/** Construct a rectangle.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of rectangle\n * @param {Vector2D} [options.radius=[1,1]] - radius of rectangle, width and height\n * @param {Vector2D} [options.corner1=[0,0]] - bottom left corner of rectangle (alternate)\n * @param {Vector2D} [options.corner2=[0,0]] - upper right corner of rectangle (alternate)\n * @returns {CAG} new CAG object\n */\nconst rectangle = function (options) {\n  options = options || {};\n  let c, r;\n  if (('corner1' in options) || ('corner2' in options)) {\n    if (('center' in options) || ('radius' in options)) {\n      throw new Error('rectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter');\n    }\n    let corner1 = parseOptionAs2DVector(options, 'corner1', [0, 0]);\n    let corner2 = parseOptionAs2DVector(options, 'corner2', [1, 1]);\n    c = corner1.plus(corner2).times(0.5);\n    r = corner2.minus(corner1).times(0.5);\n  } else {\n    c = parseOptionAs2DVector(options, 'center', [0, 0]);\n    r = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  }\n  r = r.abs(); // negative radii make no sense\n  let rswap = new Vector2D(r.x, -r.y);\n  let points = [\n    c.plus(r), c.plus(rswap), c.minus(r), c.minus(rswap)\n  ];\n  return fromPoints(points);\n};\n\n/** Construct a rounded rectangle.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of rounded rectangle\n * @param {Vector2D} [options.radius=[1,1]] - radius of rounded rectangle, width and height\n * @param {Vector2D} [options.corner1=[0,0]] - bottom left corner of rounded rectangle (alternate)\n * @param {Vector2D} [options.corner2=[0,0]] - upper right corner of rounded rectangle (alternate)\n * @param {Number} [options.roundradius=0.2] - round radius of corners\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @returns {CAG} new CAG object\n *\n * @example\n * let r = roundedRectangle({\n *   center: [0, 0],\n *   radius: [5, 10],\n *   roundradius: 2,\n *   resolution: 36,\n * });\n */\nconst roundedRectangle = function (options) {\n  options = options || {};\n  let center, radius;\n  if (('corner1' in options) || ('corner2' in options)) {\n    if (('center' in options) || ('radius' in options)) {\n      throw new Error('roundedRectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter');\n    }\n    let corner1 = parseOptionAs2DVector(options, 'corner1', [0, 0]);\n    let corner2 = parseOptionAs2DVector(options, 'corner2', [1, 1]);\n    center = corner1.plus(corner2).times(0.5);\n    radius = corner2.minus(corner1).times(0.5);\n  } else {\n    center = parseOptionAs2DVector(options, 'center', [0, 0]);\n    radius = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  }\n  radius = radius.abs(); // negative radii make no sense\n  let roundradius = parseOptionAsFloat(options, 'roundradius', 0.2);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n  let maxroundradius = Math.min(radius.x, radius.y);\n  maxroundradius -= 0.1;\n  roundradius = Math.min(roundradius, maxroundradius);\n  roundradius = Math.max(0, roundradius);\n  radius = new Vector2D(radius.x - roundradius, radius.y - roundradius);\n  let rect = rectangle({\n    center: center,\n    radius: radius\n  });\n  if (roundradius > 0) {\n    rect = rect.expand(roundradius, resolution);\n  }\n  return rect;\n};\n\n/** Reconstruct a CAG from the output of toCompactBinary().\n * @param {CompactBinary} bin - see toCompactBinary()\n * @returns {CAG} new CAG object\n */\n/*fromCompactBinary = function (bin) {\n  if (bin['class'] !== 'CAG') throw new Error('Not a CAG')\n  let vertices = []\n  let vertexData = bin.vertexData\n  let numvertices = vertexData.length / 2\n  let arrayindex = 0\n  for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n    let x = vertexData[arrayindex++]\n    let y = vertexData[arrayindex++]\n    let pos = new Vector2D(x, y)\n    let vertex = new Vertex2(pos)\n    vertices.push(vertex)\n  }\n\n  let sides = []\n  let numsides = bin.sideVertexIndices.length / 2\n  arrayindex = 0\n  for (let sideindex = 0; sideindex < numsides; sideindex++) {\n    let vertexindex0 = bin.sideVertexIndices[arrayindex++]\n    let vertexindex1 = bin.sideVertexIndices[arrayindex++]\n    let side = new Side(vertices[vertexindex0], vertices[vertexindex1])\n    sides.push(side)\n  }\n  let cag = fromSides(sides)\n  cag.isCanonicalized = true\n  return cag\n}*/\n\nmodule.exports = {\n  circle,\n  ellipse,\n  rectangle,\n  roundedRectangle,\n  fromCompactBinary\n};\n","const {parseOption, parseOptionAs3DVector, parseOptionAs2DVector, parseOptionAs3DVectorList, parseOptionAsFloat, parseOptionAsInt} = require('./optionParsers');\nconst {defaultResolution3D, defaultResolution2D, EPS} = require('../core/constants');\nconst Vector3 = require('../core/math/Vector3');\nconst Vertex3 = require('../core/math/Vertex3');\nconst Polygon3 = require('../core/math/Polygon3');\nconst {Connector} = require('../core/connectors');\nconst Properties = require('../core/Properties');\nconst {fromPolygons} = require('../core/CSGFactories');\n\n/** Construct an axis-aligned solid cuboid.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.center=[0,0,0]] - center of cube\n * @param {Vector3} [options.radius=[1,1,1]] - radius of cube, single scalar also possible\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cube = CSG.cube({\n *   center: [5, 5, 5],\n *   radius: 5, // scalar radius\n * });\n */\nconst cube = function (options) {\n  let c;\n  let r;\n  let corner1;\n  let corner2;\n  options = options || {};\n  if (('corner1' in options) || ('corner2' in options)) {\n    if (('center' in options) || ('radius' in options)) {\n      throw new Error('cube: should either give a radius and center parameter, or a corner1 and corner2 parameter');\n    }\n    corner1 = parseOptionAs3DVector(options, 'corner1', [0, 0, 0]);\n    corner2 = parseOptionAs3DVector(options, 'corner2', [1, 1, 1]);\n    c = corner1.plus(corner2).times(0.5);\n    r = corner2.minus(corner1).times(0.5);\n  } else {\n    c = parseOptionAs3DVector(options, 'center', [0, 0, 0]);\n    r = parseOptionAs3DVector(options, 'radius', [1, 1, 1]);\n  }\n  r = r.abs(); // negative radii make no sense\n  let result = fromPolygons([\n    [\n      [0, 4, 6, 2],\n      [-1, 0, 0]\n    ],\n    [\n      [1, 3, 7, 5],\n      [+1, 0, 0]\n    ],\n    [\n      [0, 1, 5, 4],\n      [0, -1, 0]\n    ],\n    [\n      [2, 6, 7, 3],\n      [0, +1, 0]\n    ],\n    [\n      [0, 2, 3, 1],\n      [0, 0, -1]\n    ],\n    [\n      [4, 5, 7, 6],\n      [0, 0, +1]\n    ]\n  ].map(function (info) {\n    let vertices = info[0].map(function (i) {\n      let pos = new Vector3(\n        c.x + r.x * (2 * !!(i & 1) - 1), c.y + r.y * (2 * !!(i & 2) - 1), c.z + r.z * (2 * !!(i & 4) - 1));\n      return new Vertex3(pos);\n    });\n    return new Polygon3(vertices, null /* , plane */);\n  }));\n  result.properties.cube = new Properties();\n  result.properties.cube.center = new Vector3(c);\n  // add 6 connectors, at the centers of each face:\n  result.properties.cube.facecenters = [\n    new Connector(new Vector3([r.x, 0, 0]).plus(c), [1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([-r.x, 0, 0]).plus(c), [-1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, r.y, 0]).plus(c), [0, 1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, -r.y, 0]).plus(c), [0, -1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, 0, r.z]).plus(c), [0, 0, 1], [1, 0, 0]),\n    new Connector(new Vector3([0, 0, -r.z]).plus(c), [0, 0, -1], [1, 0, 0])\n  ];\n  return result;\n};\n\n/** Construct a solid sphere\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.center=[0,0,0]] - center of sphere\n * @param {Number} [options.radius=1] - radius of sphere\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @param {Array} [options.axes] -  an array with 3 vectors for the x, y and z base vectors\n * @returns {CSG} new 3D solid\n *\n *\n * @example\n * let sphere = CSG.sphere({\n *   center: [0, 0, 0],\n *   radius: 2,\n *   resolution: 32,\n * });\n */\nconst sphere = function (options) {\n  options = options || {};\n  let center = parseOptionAs3DVector(options, 'center', [0, 0, 0]);\n  let radius = parseOptionAsFloat(options, 'radius', 1);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n  let xvector, yvector, zvector;\n  if ('axes' in options) {\n    xvector = options.axes[0].unit().times(radius);\n    yvector = options.axes[1].unit().times(radius);\n    zvector = options.axes[2].unit().times(radius);\n  } else {\n    xvector = new Vector3([1, 0, 0]).times(radius);\n    yvector = new Vector3([0, -1, 0]).times(radius);\n    zvector = new Vector3([0, 0, 1]).times(radius);\n  }\n  if (resolution < 4) resolution = 4;\n  let qresolution = Math.round(resolution / 4);\n  let prevcylinderpoint;\n  let polygons = [];\n  for (let slice1 = 0; slice1 <= resolution; slice1++) {\n    let angle = Math.PI * 2.0 * slice1 / resolution;\n    let cylinderpoint = xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));\n    if (slice1 > 0) {\n      // cylinder vertices:\n      let vertices = [];\n      let prevcospitch, prevsinpitch;\n      for (let slice2 = 0; slice2 <= qresolution; slice2++) {\n        let pitch = 0.5 * Math.PI * slice2 / qresolution;\n        let cospitch = Math.cos(pitch);\n        let sinpitch = Math.sin(pitch);\n        if (slice2 > 0) {\n          vertices = [];\n          vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));\n          vertices.push(new Vertex3(center.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));\n          if (slice2 < qresolution) {\n            vertices.push(new Vertex3(center.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));\n          }\n          vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));\n          polygons.push(new Polygon3(vertices));\n          vertices = [];\n          vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));\n          vertices.push(new Vertex3(center.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));\n          if (slice2 < qresolution) {\n            vertices.push(new Vertex3(center.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));\n          }\n          vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));\n          vertices.reverse();\n          polygons.push(new Polygon3(vertices));\n        }\n        prevcospitch = cospitch;\n        prevsinpitch = sinpitch;\n      }\n    }\n    prevcylinderpoint = cylinderpoint;\n  }\n  let result = fromPolygons(polygons);\n  result.properties.sphere = new Properties();\n  result.properties.sphere.center = new Vector3(center);\n  result.properties.sphere.facepoint = center.plus(xvector);\n  return result;\n};\n\n/** Construct a solid cylinder.\n * @param {Object} [options] - options for construction\n * @param {Vector} [options.start=[0,-1,0]] - start point of cylinder\n * @param {Vector} [options.end=[0,1,0]] - end point of cylinder\n * @param {Number} [options.radius=1] - radius of cylinder, must be scalar\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cylinder = CSG.cylinder({\n *   start: [0, -10, 0],\n *   end: [0, 10, 0],\n *   radius: 10,\n *   resolution: 16\n * });\n */\nconst cylinder = function (options) {\n  let s = parseOptionAs3DVector(options, 'start', [0, -1, 0]);\n  let e = parseOptionAs3DVector(options, 'end', [0, 1, 0]);\n  let r = parseOptionAsFloat(options, 'radius', 1);\n  let rEnd = parseOptionAsFloat(options, 'radiusEnd', r);\n  let rStart = parseOptionAsFloat(options, 'radiusStart', r);\n  let alpha = parseOptionAsFloat(options, 'sectorAngle', 360);\n  alpha = alpha > 360 ? alpha % 360 : alpha;\n\n  if ((rEnd < 0) || (rStart < 0)) {\n    throw new Error('Radius should be non-negative');\n  }\n  if ((rEnd === 0) && (rStart === 0)) {\n    throw new Error('Either radiusStart or radiusEnd should be positive');\n  }\n\n  let slices = parseOptionAsInt(options, 'resolution', defaultResolution2D); // FIXME is this 3D?\n  let ray = e.minus(s);\n  let axisZ = ray.unit(); //, isY = (Math.abs(axisZ.y) > 0.5);\n  let axisX = axisZ.randomNonParallelVector().unit();\n\n  //  let axisX = new Vector3(isY, !isY, 0).cross(axisZ).unit();\n  let axisY = axisX.cross(axisZ).unit();\n  let start = new Vertex3(s);\n  let end = new Vertex3(e);\n  let polygons = [];\n\n  function point(stack, slice, radius) {\n    let angle = slice * Math.PI * alpha / 180;\n    let out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));\n    let pos = s.plus(ray.times(stack)).plus(out.times(radius));\n    return new Vertex3(pos);\n  }\n\n  if (alpha > 0) {\n    for (let i = 0; i < slices; i++) {\n      let t0 = i / slices;\n      let t1 = (i + 1) / slices;\n      if (rEnd === rStart) {\n        polygons.push(new Polygon3([start, point(0, t0, rEnd), point(0, t1, rEnd)]));\n        polygons.push(new Polygon3([point(0, t1, rEnd), point(0, t0, rEnd), point(1, t0, rEnd), point(1, t1, rEnd)]));\n        polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));\n      } else {\n        if (rStart > 0) {\n          polygons.push(new Polygon3([start, point(0, t0, rStart), point(0, t1, rStart)]));\n          polygons.push(new Polygon3([point(0, t0, rStart), point(1, t0, rEnd), point(0, t1, rStart)]));\n        }\n        if (rEnd > 0) {\n          polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));\n          polygons.push(new Polygon3([point(1, t0, rEnd), point(1, t1, rEnd), point(0, t1, rStart)]));\n        }\n      }\n    }\n    if (alpha < 360) {\n      polygons.push(new Polygon3([start, end, point(0, 0, rStart)]));\n      polygons.push(new Polygon3([point(0, 0, rStart), end, point(1, 0, rEnd)]));\n      polygons.push(new Polygon3([start, point(0, 1, rStart), end]));\n      polygons.push(new Polygon3([point(0, 1, rStart), point(1, 1, rEnd), end]));\n    }\n  }\n  let result = fromPolygons(polygons);\n  result.properties.cylinder = new Properties();\n  result.properties.cylinder.start = new Connector(s, axisZ.negated(), axisX);\n  result.properties.cylinder.end = new Connector(e, axisZ, axisX);\n  let cylCenter = s.plus(ray.times(0.5));\n  let fptVec = axisX.rotate(s, axisZ, -alpha / 2).times((rStart + rEnd) / 2);\n  let fptVec90 = fptVec.cross(axisZ);\n  // note this one is NOT a face normal for a cone. - It's horizontal from cyl perspective\n  result.properties.cylinder.facepointH = new Connector(cylCenter.plus(fptVec), fptVec, axisZ);\n  result.properties.cylinder.facepointH90 = new Connector(cylCenter.plus(fptVec90), fptVec90, axisZ);\n  return result;\n};\n\n/** Construct a cylinder with rounded ends.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.start=[0,-1,0]] - start point of cylinder\n * @param {Vector3} [options.end=[0,1,0]] - end point of cylinder\n * @param {Number} [options.radius=1] - radius of rounded ends, must be scalar\n * @param {Vector3} [options.normal] - vector determining the starting angle for tesselation. Should be non-parallel to start.minus(end)\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cylinder = CSG.roundedCylinder({\n *   start: [0, -10, 0],\n *   end: [0, 10, 0],\n *   radius: 2,\n *   resolution: 16\n * });\n */\nconst roundedCylinder = function (options) {\n  let p1 = parseOptionAs3DVector(options, 'start', [0, -1, 0]);\n  let p2 = parseOptionAs3DVector(options, 'end', [0, 1, 0]);\n  let radius = parseOptionAsFloat(options, 'radius', 1);\n  let direction = p2.minus(p1);\n  let defaultnormal;\n  if (Math.abs(direction.x) > Math.abs(direction.y)) {\n    defaultnormal = new Vector3(0, 1, 0);\n  } else {\n    defaultnormal = new Vector3(1, 0, 0);\n  }\n  let normal = parseOptionAs3DVector(options, 'normal', defaultnormal);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n  if (resolution < 4) resolution = 4;\n  let polygons = [];\n  let qresolution = Math.floor(0.25 * resolution);\n  let length = direction.length();\n  if (length < EPS) {\n    return sphere({\n      center: p1,\n      radius: radius,\n      resolution: resolution\n    });\n  }\n  let zvector = direction.unit().times(radius);\n  let xvector = zvector.cross(normal).unit().times(radius);\n  let yvector = xvector.cross(zvector).unit().times(radius);\n  let prevcylinderpoint;\n  for (let slice1 = 0; slice1 <= resolution; slice1++) {\n    let angle = Math.PI * 2.0 * slice1 / resolution;\n    let cylinderpoint = xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));\n    if (slice1 > 0) {\n      // cylinder vertices:\n      let vertices = [];\n      vertices.push(new Vertex3(p1.plus(cylinderpoint)));\n      vertices.push(new Vertex3(p1.plus(prevcylinderpoint)));\n      vertices.push(new Vertex3(p2.plus(prevcylinderpoint)));\n      vertices.push(new Vertex3(p2.plus(cylinderpoint)));\n      polygons.push(new Polygon3(vertices));\n      let prevcospitch, prevsinpitch;\n      for (let slice2 = 0; slice2 <= qresolution; slice2++) {\n        let pitch = 0.5 * Math.PI * slice2 / qresolution;\n        // let pitch = Math.asin(slice2/qresolution);\n        let cospitch = Math.cos(pitch);\n        let sinpitch = Math.sin(pitch);\n        if (slice2 > 0) {\n          vertices = [];\n          vertices.push(new Vertex3(p1.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));\n          vertices.push(new Vertex3(p1.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));\n          if (slice2 < qresolution) {\n            vertices.push(new Vertex3(p1.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));\n          }\n          vertices.push(new Vertex3(p1.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));\n          polygons.push(new Polygon3(vertices));\n          vertices = [];\n          vertices.push(new Vertex3(p2.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));\n          vertices.push(new Vertex3(p2.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));\n          if (slice2 < qresolution) {\n            vertices.push(new Vertex3(p2.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));\n          }\n          vertices.push(new Vertex3(p2.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));\n          vertices.reverse();\n          polygons.push(new Polygon3(vertices));\n        }\n        prevcospitch = cospitch;\n        prevsinpitch = sinpitch;\n      }\n    }\n    prevcylinderpoint = cylinderpoint;\n  }\n  let result = fromPolygons(polygons);\n  let ray = zvector.unit();\n  let axisX = xvector.unit();\n  result.properties.roundedCylinder = new Properties();\n  result.properties.roundedCylinder.start = new Connector(p1, ray.negated(), axisX);\n  result.properties.roundedCylinder.end = new Connector(p2, ray, axisX);\n  result.properties.roundedCylinder.facepoint = p1.plus(xvector);\n  return result;\n};\n\n/** Construct an elliptic cylinder.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.start=[0,-1,0]] - start point of cylinder\n * @param {Vector3} [options.end=[0,1,0]] - end point of cylinder\n * @param {Vector2D} [options.radius=[1,1]] - radius of rounded ends, must be two dimensional array\n * @param {Vector2D} [options.radiusStart=[1,1]] - OPTIONAL radius of rounded start, must be two dimensional array\n * @param {Vector2D} [options.radiusEnd=[1,1]] - OPTIONAL radius of rounded end, must be two dimensional array\n * @param {Number} [options.resolution=defaultResolution2D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n *     let cylinder = CSG.cylinderElliptic({\n *       start: [0, -10, 0],\n *       end: [0, 10, 0],\n *       radiusStart: [10,5],\n *       radiusEnd: [8,3],\n *       resolution: 16\n *     });\n */\n\nconst cylinderElliptic = function (options) {\n  let s = parseOptionAs3DVector(options, 'start', [0, -1, 0]);\n  let e = parseOptionAs3DVector(options, 'end', [0, 1, 0]);\n  let r = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  let rEnd = parseOptionAs2DVector(options, 'radiusEnd', r);\n  let rStart = parseOptionAs2DVector(options, 'radiusStart', r);\n\n  if ((rEnd._x < 0) || (rStart._x < 0) || (rEnd._y < 0) || (rStart._y < 0)) {\n    throw new Error('Radius should be non-negative');\n  }\n  if ((rEnd._x === 0 || rEnd._y === 0) && (rStart._x === 0 || rStart._y === 0)) {\n    throw new Error('Either radiusStart or radiusEnd should be positive');\n  }\n\n  let slices = parseOptionAsInt(options, 'resolution', defaultResolution2D); // FIXME is this correct?\n  let ray = e.minus(s);\n  let axisZ = ray.unit(); //, isY = (Math.abs(axisZ.y) > 0.5);\n  let axisX = axisZ.randomNonParallelVector().unit();\n\n  //  let axisX = new Vector3(isY, !isY, 0).cross(axisZ).unit();\n  let axisY = axisX.cross(axisZ).unit();\n  let start = new Vertex3(s);\n  let end = new Vertex3(e);\n  let polygons = [];\n\n  function point(stack, slice, radius) {\n    let angle = slice * Math.PI * 2;\n    let out = axisX.times(radius._x * Math.cos(angle)).plus(axisY.times(radius._y * Math.sin(angle)));\n    let pos = s.plus(ray.times(stack)).plus(out);\n    return new Vertex3(pos);\n  }\n\n  for (let i = 0; i < slices; i++) {\n    let t0 = i / slices;\n    let t1 = (i + 1) / slices;\n\n    if (rEnd._x === rStart._x && rEnd._y === rStart._y) {\n      polygons.push(new Polygon3([start, point(0, t0, rEnd), point(0, t1, rEnd)]));\n      polygons.push(new Polygon3([point(0, t1, rEnd), point(0, t0, rEnd), point(1, t0, rEnd), point(1, t1, rEnd)]));\n      polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));\n    } else {\n      if (rStart._x > 0) {\n        polygons.push(new Polygon3([start, point(0, t0, rStart), point(0, t1, rStart)]));\n        polygons.push(new Polygon3([point(0, t0, rStart), point(1, t0, rEnd), point(0, t1, rStart)]));\n      }\n      if (rEnd._x > 0) {\n        polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));\n        polygons.push(new Polygon3([point(1, t0, rEnd), point(1, t1, rEnd), point(0, t1, rStart)]));\n      }\n    }\n  }\n  let result = fromPolygons(polygons);\n  result.properties.cylinder = new Properties();\n  result.properties.cylinder.start = new Connector(s, axisZ.negated(), axisX);\n  result.properties.cylinder.end = new Connector(e, axisZ, axisX);\n  result.properties.cylinder.facepoint = s.plus(axisX.times(rStart));\n  return result;\n};\n\n/** Construct an axis-aligned solid rounded cuboid.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.center=[0,0,0]] - center of rounded cube\n * @param {Vector3} [options.radius=[1,1,1]] - radius of rounded cube, single scalar is possible\n * @param {Number} [options.roundradius=0.2] - radius of rounded edges\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cube = CSG.roundedCube({\n *   center: [2, 0, 2],\n *   radius: 15,\n *   roundradius: 2,\n *   resolution: 36,\n * });\n */\nconst roundedCube = function (options) {\n  let minRR = 1e-2; // minroundradius 1e-3 gives rounding errors already\n  let center;\n  let cuberadius;\n  let corner1;\n  let corner2;\n  options = options || {};\n  if (('corner1' in options) || ('corner2' in options)) {\n    if (('center' in options) || ('radius' in options)) {\n      throw new Error('roundedCube: should either give a radius and center parameter, or a corner1 and corner2 parameter');\n    }\n    corner1 = parseOptionAs3DVector(options, 'corner1', [0, 0, 0]);\n    corner2 = parseOptionAs3DVector(options, 'corner2', [1, 1, 1]);\n    center = corner1.plus(corner2).times(0.5);\n    cuberadius = corner2.minus(corner1).times(0.5);\n  } else {\n    center = parseOptionAs3DVector(options, 'center', [0, 0, 0]);\n    cuberadius = parseOptionAs3DVector(options, 'radius', [1, 1, 1]);\n  }\n  cuberadius = cuberadius.abs(); // negative radii make no sense\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n  if (resolution < 4) resolution = 4;\n  if (resolution % 2 === 1 && resolution < 8) resolution = 8; // avoid ugly\n  let roundradius = parseOptionAs3DVector(options, 'roundradius', [0.2, 0.2, 0.2]);\n  // slight hack for now - total radius stays ok\n  roundradius = Vector3.Create(Math.max(roundradius.x, minRR), Math.max(roundradius.y, minRR), Math.max(roundradius.z, minRR));\n  let innerradius = cuberadius.minus(roundradius);\n  if (innerradius.x < 0 || innerradius.y < 0 || innerradius.z < 0) {\n    throw new Error('roundradius <= radius!');\n  }\n  let res = sphere({radius: 1, resolution: resolution});\n  res = res.scale(roundradius);\n  innerradius.x > EPS && (res = res.stretchAtPlane([1, 0, 0], [0, 0, 0], 2 * innerradius.x));\n  innerradius.y > EPS && (res = res.stretchAtPlane([0, 1, 0], [0, 0, 0], 2 * innerradius.y));\n  innerradius.z > EPS && (res = res.stretchAtPlane([0, 0, 1], [0, 0, 0], 2 * innerradius.z));\n  res = res.translate([-innerradius.x + center.x, -innerradius.y + center.y, -innerradius.z + center.z]);\n  res = res.reTesselated();\n  res.properties.roundedCube = new Properties();\n  res.properties.roundedCube.center = new Vertex3(center);\n  res.properties.roundedCube.facecenters = [\n    new Connector(new Vector3([cuberadius.x, 0, 0]).plus(center), [1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([-cuberadius.x, 0, 0]).plus(center), [-1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, cuberadius.y, 0]).plus(center), [0, 1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, -cuberadius.y, 0]).plus(center), [0, -1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, 0, cuberadius.z]).plus(center), [0, 0, 1], [1, 0, 0]),\n    new Connector(new Vector3([0, 0, -cuberadius.z]).plus(center), [0, 0, -1], [1, 0, 0])\n  ];\n  return res;\n};\n\n/** Create a polyhedron using Openscad style arguments.\n * Define face vertices clockwise looking from outside.\n * @param {Object} [options] - options for construction\n * @returns {CSG} new 3D solid\n */\nconst polyhedron = function (options) {\n  options = options || {};\n  if (('points' in options) !== ('faces' in options)) {\n    throw new Error(\"polyhedron needs 'points' and 'faces' arrays\");\n  }\n  let vertices = parseOptionAs3DVectorList(options, 'points', [\n    [1, 1, 0],\n    [1, -1, 0],\n    [-1, -1, 0],\n    [-1, 1, 0],\n    [0, 0, 1]\n  ])\n    .map(function (pt) {\n      return new Vertex3(pt);\n    });\n  let faces = parseOption(options, 'faces', [\n    [0, 1, 4],\n    [1, 2, 4],\n    [2, 3, 4],\n    [3, 0, 4],\n    [1, 0, 3],\n    [2, 1, 3]\n  ]);\n  // Openscad convention defines inward normals - so we have to invert here\n  faces.forEach(function (face) {\n    face.reverse();\n  });\n  let polygons = faces.map(function (face) {\n    return new Polygon3(face.map(function (idx) {\n      return vertices[idx];\n    }));\n  });\n\n  // TODO: facecenters as connectors? probably overkill. Maybe centroid\n  // the re-tesselation here happens because it's so easy for a user to\n  // create parametrized polyhedrons that end up with 1-2 dimensional polygons.\n  // These will create infinite loops at CSG.Tree()\n  return fromPolygons(polygons).reTesselated();\n};\n\nmodule.exports = {\n  cube,\n  sphere,\n  roundedCube,\n  cylinder,\n  roundedCylinder,\n  cylinderElliptic,\n  polyhedron\n};\n","// color table from http://www.w3.org/TR/css3-color/\nconst cssColors = {\n// basic color keywords\n  'black': [0 / 255, 0 / 255, 0 / 255],\n  'silver': [192 / 255, 192 / 255, 192 / 255],\n  'gray': [128 / 255, 128 / 255, 128 / 255],\n  'white': [255 / 255, 255 / 255, 255 / 255],\n  'maroon': [128 / 255, 0 / 255, 0 / 255],\n  'red': [255 / 255, 0 / 255, 0 / 255],\n  'purple': [128 / 255, 0 / 255, 128 / 255],\n  'fuchsia': [255 / 255, 0 / 255, 255 / 255],\n  'green': [0 / 255, 128 / 255, 0 / 255],\n  'lime': [0 / 255, 255 / 255, 0 / 255],\n  'olive': [128 / 255, 128 / 255, 0 / 255],\n  'yellow': [255 / 255, 255 / 255, 0 / 255],\n  'navy': [0 / 255, 0 / 255, 128 / 255],\n  'blue': [0 / 255, 0 / 255, 255 / 255],\n  'teal': [0 / 255, 128 / 255, 128 / 255],\n  'aqua': [0 / 255, 255 / 255, 255 / 255],\n  // extended color keywords\n  'aliceblue': [240 / 255, 248 / 255, 255 / 255],\n  'antiquewhite': [250 / 255, 235 / 255, 215 / 255],\n  // 'aqua': [ 0 / 255, 255 / 255, 255 / 255 ],\n  'aquamarine': [127 / 255, 255 / 255, 212 / 255],\n  'azure': [240 / 255, 255 / 255, 255 / 255],\n  'beige': [245 / 255, 245 / 255, 220 / 255],\n  'bisque': [255 / 255, 228 / 255, 196 / 255],\n  // 'black': [ 0 / 255, 0 / 255, 0 / 255 ],\n  'blanchedalmond': [255 / 255, 235 / 255, 205 / 255],\n  // 'blue': [ 0 / 255, 0 / 255, 255 / 255 ],\n  'blueviolet': [138 / 255, 43 / 255, 226 / 255],\n  'brown': [165 / 255, 42 / 255, 42 / 255],\n  'burlywood': [222 / 255, 184 / 255, 135 / 255],\n  'cadetblue': [95 / 255, 158 / 255, 160 / 255],\n  'chartreuse': [127 / 255, 255 / 255, 0 / 255],\n  'chocolate': [210 / 255, 105 / 255, 30 / 255],\n  'coral': [255 / 255, 127 / 255, 80 / 255],\n  'cornflowerblue': [100 / 255, 149 / 255, 237 / 255],\n  'cornsilk': [255 / 255, 248 / 255, 220 / 255],\n  'crimson': [220 / 255, 20 / 255, 60 / 255],\n  'cyan': [0 / 255, 255 / 255, 255 / 255],\n  'darkblue': [0 / 255, 0 / 255, 139 / 255],\n  'darkcyan': [0 / 255, 139 / 255, 139 / 255],\n  'darkgoldenrod': [184 / 255, 134 / 255, 11 / 255],\n  'darkgray': [169 / 255, 169 / 255, 169 / 255],\n  'darkgreen': [0 / 255, 100 / 255, 0 / 255],\n  'darkgrey': [169 / 255, 169 / 255, 169 / 255],\n  'darkkhaki': [189 / 255, 183 / 255, 107 / 255],\n  'darkmagenta': [139 / 255, 0 / 255, 139 / 255],\n  'darkolivegreen': [85 / 255, 107 / 255, 47 / 255],\n  'darkorange': [255 / 255, 140 / 255, 0 / 255],\n  'darkorchid': [153 / 255, 50 / 255, 204 / 255],\n  'darkred': [139 / 255, 0 / 255, 0 / 255],\n  'darksalmon': [233 / 255, 150 / 255, 122 / 255],\n  'darkseagreen': [143 / 255, 188 / 255, 143 / 255],\n  'darkslateblue': [72 / 255, 61 / 255, 139 / 255],\n  'darkslategray': [47 / 255, 79 / 255, 79 / 255],\n  'darkslategrey': [47 / 255, 79 / 255, 79 / 255],\n  'darkturquoise': [0 / 255, 206 / 255, 209 / 255],\n  'darkviolet': [148 / 255, 0 / 255, 211 / 255],\n  'deeppink': [255 / 255, 20 / 255, 147 / 255],\n  'deepskyblue': [0 / 255, 191 / 255, 255 / 255],\n  'dimgray': [105 / 255, 105 / 255, 105 / 255],\n  'dimgrey': [105 / 255, 105 / 255, 105 / 255],\n  'dodgerblue': [30 / 255, 144 / 255, 255 / 255],\n  'firebrick': [178 / 255, 34 / 255, 34 / 255],\n  'floralwhite': [255 / 255, 250 / 255, 240 / 255],\n  'forestgreen': [34 / 255, 139 / 255, 34 / 255],\n  // 'fuchsia': [ 255 / 255, 0 / 255, 255 / 255 ],\n  'gainsboro': [220 / 255, 220 / 255, 220 / 255],\n  'ghostwhite': [248 / 255, 248 / 255, 255 / 255],\n  'gold': [255 / 255, 215 / 255, 0 / 255],\n  'goldenrod': [218 / 255, 165 / 255, 32 / 255],\n  // 'gray': [ 128 / 255, 128 / 255, 128 / 255 ],\n  // 'green': [ 0 / 255, 128 / 255, 0 / 255 ],\n  'greenyellow': [173 / 255, 255 / 255, 47 / 255],\n  'grey': [128 / 255, 128 / 255, 128 / 255],\n  'honeydew': [240 / 255, 255 / 255, 240 / 255],\n  'hotpink': [255 / 255, 105 / 255, 180 / 255],\n  'indianred': [205 / 255, 92 / 255, 92 / 255],\n  'indigo': [75 / 255, 0 / 255, 130 / 255],\n  'ivory': [255 / 255, 255 / 255, 240 / 255],\n  'khaki': [240 / 255, 230 / 255, 140 / 255],\n  'lavender': [230 / 255, 230 / 255, 250 / 255],\n  'lavenderblush': [255 / 255, 240 / 255, 245 / 255],\n  'lawngreen': [124 / 255, 252 / 255, 0 / 255],\n  'lemonchiffon': [255 / 255, 250 / 255, 205 / 255],\n  'lightblue': [173 / 255, 216 / 255, 230 / 255],\n  'lightcoral': [240 / 255, 128 / 255, 128 / 255],\n  'lightcyan': [224 / 255, 255 / 255, 255 / 255],\n  'lightgoldenrodyellow': [250 / 255, 250 / 255, 210 / 255],\n  'lightgray': [211 / 255, 211 / 255, 211 / 255],\n  'lightgreen': [144 / 255, 238 / 255, 144 / 255],\n  'lightgrey': [211 / 255, 211 / 255, 211 / 255],\n  'lightpink': [255 / 255, 182 / 255, 193 / 255],\n  'lightsalmon': [255 / 255, 160 / 255, 122 / 255],\n  'lightseagreen': [32 / 255, 178 / 255, 170 / 255],\n  'lightskyblue': [135 / 255, 206 / 255, 250 / 255],\n  'lightslategray': [119 / 255, 136 / 255, 153 / 255],\n  'lightslategrey': [119 / 255, 136 / 255, 153 / 255],\n  'lightsteelblue': [176 / 255, 196 / 255, 222 / 255],\n  'lightyellow': [255 / 255, 255 / 255, 224 / 255],\n  // 'lime': [ 0 / 255, 255 / 255, 0 / 255 ],\n  'limegreen': [50 / 255, 205 / 255, 50 / 255],\n  'linen': [250 / 255, 240 / 255, 230 / 255],\n  'magenta': [255 / 255, 0 / 255, 255 / 255],\n  // 'maroon': [ 128 / 255, 0 / 255, 0 / 255 ],\n  'mediumaquamarine': [102 / 255, 205 / 255, 170 / 255],\n  'mediumblue': [0 / 255, 0 / 255, 205 / 255],\n  'mediumorchid': [186 / 255, 85 / 255, 211 / 255],\n  'mediumpurple': [147 / 255, 112 / 255, 219 / 255],\n  'mediumseagreen': [60 / 255, 179 / 255, 113 / 255],\n  'mediumslateblue': [123 / 255, 104 / 255, 238 / 255],\n  'mediumspringgreen': [0 / 255, 250 / 255, 154 / 255],\n  'mediumturquoise': [72 / 255, 209 / 255, 204 / 255],\n  'mediumvioletred': [199 / 255, 21 / 255, 133 / 255],\n  'midnightblue': [25 / 255, 25 / 255, 112 / 255],\n  'mintcream': [245 / 255, 255 / 255, 250 / 255],\n  'mistyrose': [255 / 255, 228 / 255, 225 / 255],\n  'moccasin': [255 / 255, 228 / 255, 181 / 255],\n  'navajowhite': [255 / 255, 222 / 255, 173 / 255],\n  // 'navy': [ 0 / 255, 0 / 255, 128 / 255 ],\n  'oldlace': [253 / 255, 245 / 255, 230 / 255],\n  // 'olive': [ 128 / 255, 128 / 255, 0 / 255 ],\n  'olivedrab': [107 / 255, 142 / 255, 35 / 255],\n  'orange': [255 / 255, 165 / 255, 0 / 255],\n  'orangered': [255 / 255, 69 / 255, 0 / 255],\n  'orchid': [218 / 255, 112 / 255, 214 / 255],\n  'palegoldenrod': [238 / 255, 232 / 255, 170 / 255],\n  'palegreen': [152 / 255, 251 / 255, 152 / 255],\n  'paleturquoise': [175 / 255, 238 / 255, 238 / 255],\n  'palevioletred': [219 / 255, 112 / 255, 147 / 255],\n  'papayawhip': [255 / 255, 239 / 255, 213 / 255],\n  'peachpuff': [255 / 255, 218 / 255, 185 / 255],\n  'peru': [205 / 255, 133 / 255, 63 / 255],\n  'pink': [255 / 255, 192 / 255, 203 / 255],\n  'plum': [221 / 255, 160 / 255, 221 / 255],\n  'powderblue': [176 / 255, 224 / 255, 230 / 255],\n  // 'purple': [ 128 / 255, 0 / 255, 128 / 255 ],\n  // 'red': [ 255 / 255, 0 / 255, 0 / 255 ],\n  'rosybrown': [188 / 255, 143 / 255, 143 / 255],\n  'royalblue': [65 / 255, 105 / 255, 225 / 255],\n  'saddlebrown': [139 / 255, 69 / 255, 19 / 255],\n  'salmon': [250 / 255, 128 / 255, 114 / 255],\n  'sandybrown': [244 / 255, 164 / 255, 96 / 255],\n  'seagreen': [46 / 255, 139 / 255, 87 / 255],\n  'seashell': [255 / 255, 245 / 255, 238 / 255],\n  'sienna': [160 / 255, 82 / 255, 45 / 255],\n  // 'silver': [ 192 / 255, 192 / 255, 192 / 255 ],\n  'skyblue': [135 / 255, 206 / 255, 235 / 255],\n  'slateblue': [106 / 255, 90 / 255, 205 / 255],\n  'slategray': [112 / 255, 128 / 255, 144 / 255],\n  'slategrey': [112 / 255, 128 / 255, 144 / 255],\n  'snow': [255 / 255, 250 / 255, 250 / 255],\n  'springgreen': [0 / 255, 255 / 255, 127 / 255],\n  'steelblue': [70 / 255, 130 / 255, 180 / 255],\n  'tan': [210 / 255, 180 / 255, 140 / 255],\n  // 'teal': [ 0 / 255, 128 / 255, 128 / 255 ],\n  'thistle': [216 / 255, 191 / 255, 216 / 255],\n  'tomato': [255 / 255, 99 / 255, 71 / 255],\n  'turquoise': [64 / 255, 224 / 255, 208 / 255],\n  'violet': [238 / 255, 130 / 255, 238 / 255],\n  'wheat': [245 / 255, 222 / 255, 179 / 255],\n  // 'white': [ 255 / 255, 255 / 255, 255 / 255 ],\n  'whitesmoke': [245 / 255, 245 / 255, 245 / 255],\n  // 'yellow': [ 255 / 255, 255 / 255, 0 / 255 ],\n  'yellowgreen': [154 / 255, 205 / 255, 50 / 255]\n};\n\n/**\n * Converts an CSS color name to RGB color.\n *\n * @param   String  s       The CSS color name\n * @return  Array           The RGB representation, or [0,0,0] default\n */\nfunction css2rgb(s) {\n  return cssColors[s.toLowerCase()];\n}\n\n// color( (array[r,g,b] | css-string) [,alpha] (,array[objects] | list of objects) )\n/** apply the given color to the input object(s)\n * @param {Object} color - either an array or a hex string of color values\n * @param {Object|Array} objects either a single or multiple CSG/CAG objects to color\n * @returns {CSG} new CSG object , with the given color\n *\n * @example\n * let redSphere = color([1,0,0,1], sphere())\n */\nfunction color(color) {\n  let object;\n  let i = 1;\n  let a = arguments;\n\n  // assume first argument is RGB array\n  // but check if first argument is CSS string\n  if (typeof color === 'string') {\n    color = css2rgb(color);\n  }\n  // check if second argument is alpha\n  if (Number.isFinite(a[i])) {\n    color = color.concat(a[i]);\n    i++;\n  }\n  // check if next argument is an an array\n  if (Array.isArray(a[i])) {\n    a = a[i];\n    i = 0;\n  } // use this as the list of objects\n  for (object = a[i++]; i < a.length; i++) {\n    object = object.union(a[i]);\n  }\n  return object.setColor(color);\n}\n\n// from http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\n/**\n * Converts an RGB color value to HSL. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n * Assumes r, g, and b are contained in the set [0, 1] and\n * returns h, s, and l in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSL representation\n */\nfunction rgb2hsl(r, g, b) {\n  if (r.length) {\n    b = r[2];\n    g = r[1];\n    r = r[0];\n  }\n  let max = Math.max(r, g, b);\n  let min = Math.min(r, g, b);\n  let h;\n  let s;\n  let l = (max + min) / 2;\n\n  if (max === min) {\n    h = s = 0; // achromatic\n  } else {\n    let d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n\n  return [h, s, l];\n}\n\n/**\n * Converts an HSL color value to RGB. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n * Assumes h, s, and l are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 1].\n *\n * @param   Number  h       The hue\n * @param   Number  s       The saturation\n * @param   Number  l       The lightness\n * @return  Array           The RGB representation\n */\nfunction hsl2rgb(h, s, l) {\n  if (h.length) {\n    h = h[0];\n    s = h[1];\n    l = h[2];\n  }\n  let r;\n  let g;\n  let b;\n\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    let p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n\n  return [r, g, b];\n}\n\nfunction hue2rgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n\n/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 1] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   Number  r       The red color value\n * @param   Number  g       The green color value\n * @param   Number  b       The blue color value\n * @return  Array           The HSV representation\n */\n\nfunction rgb2hsv(r, g, b) {\n  if (r.length) {\n    r = r[0];\n    g = r[1];\n    b = r[2];\n  }\n  let max = Math.max(r, g, b);\n  let min = Math.min(r, g, b);\n  let h;\n  let s;\n  let v = max;\n\n  let d = max - min;\n  s = max === 0 ? 0 : d / max;\n\n  if (max === min) {\n    h = 0; // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n\n  return [h, s, v];\n}\n\n/**\n * Converts an HSV color value to RGB. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes h, s, and v are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 1].\n *\n * @param   Number  h       The hue\n * @param   Number  s       The saturation\n * @param   Number  v       The value\n * @return  Array           The RGB representation\n */\nfunction hsv2rgb(h, s, v) {\n  if (h.length) {\n    h = h[0];\n    s = h[1];\n    v = h[2];\n  }\n  let r, g, b;\n\n  let i = Math.floor(h * 6);\n  let f = h * 6 - i;\n  let p = v * (1 - s);\n  let q = v * (1 - f * s);\n  let t = v * (1 - (1 - f) * s);\n\n  switch (i % 6) {\n    case 0:\n      r = v, g = t, b = p;\n      break;\n    case 1:\n      r = q, g = v, b = p;\n      break;\n    case 2:\n      r = p, g = v, b = t;\n      break;\n    case 3:\n      r = p, g = q, b = v;\n      break;\n    case 4:\n      r = t, g = p, b = v;\n      break;\n    case 5:\n      r = v, g = p, b = q;\n      break;\n  }\n\n  return [r, g, b];\n}\n\n/**\n * Converts a HTML5 color value (string) to RGB values\n * See the color input type of HTML5 forms\n * Conversion formula:\n * - split the string; \"#RRGGBB\" into RGB components\n * - convert the HEX value into RGB values\n */\nfunction html2rgb(s) {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  if (s.length === 7) {\n    r = parseInt('0x' + s.slice(1, 3)) / 255;\n    g = parseInt('0x' + s.slice(3, 5)) / 255;\n    b = parseInt('0x' + s.slice(5, 7)) / 255;\n  }\n  return [r, g, b];\n}\n\n/**\n * Converts RGB color value to HTML5 color value (string)\n * Conversion forumla:\n * - convert R, G, B into HEX strings\n * - return HTML formatted string \"#RRGGBB\"\n */\nfunction rgb2html(r, g, b) {\n  if (r.length) {\n    r = r[0];\n    g = r[1];\n    b = r[2];\n  }\n  let s = '#' +\n    Number(0x1000000 + r * 255 * 0x10000 + g * 255 * 0x100 + b * 255).toString(16).substring(1, 7);\n  return s;\n}\n\nmodule.exports = {\n  css2rgb,\n  color,\n  rgb2hsl,\n  hsl2rgb,\n  rgb2hsv,\n  hsv2rgb,\n  html2rgb,\n  rgb2html\n};\n","// -- Math functions (360 deg based vs 2pi)\nfunction sin(a) {\n  return Math.sin(a / 360 * Math.PI * 2);\n}\n\nfunction cos(a) {\n  return Math.cos(a / 360 * Math.PI * 2);\n}\n\nfunction asin(a) {\n  return Math.asin(a) / (Math.PI * 2) * 360;\n}\n\nfunction acos(a) {\n  return Math.acos(a) / (Math.PI * 2) * 360;\n}\n\nfunction tan(a) {\n  return Math.tan(a / 360 * Math.PI * 2);\n}\n\nfunction atan(a) {\n  return Math.atan(a) / (Math.PI * 2) * 360;\n}\n\nfunction atan2(a, b) {\n  return Math.atan2(a, b) / (Math.PI * 2) * 360;\n}\n\nfunction ceil(a) {\n  return Math.ceil(a);\n}\n\nfunction floor(a) {\n  return Math.floor(a);\n}\n\nfunction abs(a) {\n  return Math.abs(a);\n}\n\nfunction min(a, b) {\n  return a < b ? a : b;\n}\n\nfunction max(a, b) {\n  return a > b ? a : b;\n}\n\nfunction rands(min, max, vn, seed) {\n  // -- seed is ignored for now, FIX IT (requires reimplementation of random())\n  //    see http://stackoverflow.com/questions/424292/how-to-create-my-own-javascript-random-number-generator-that-i-can-also-set-the\n  var v = new Array(vn);\n  for (var i = 0; i < vn; i++) {\n    v[i] = Math.random() * (max - min) + min;\n  }\n}\n\nfunction log(a) {\n  return Math.log(a);\n}\n\nfunction lookup(ix, v) {\n  var r = 0;\n  for (var i = 0; i < v.length; i++) {\n    var a0 = v[i];\n    if (a0[0] >= ix) {\n      i--;\n      a0 = v[i];\n      var a1 = v[i + 1];\n      var m = 0;\n      if (a0[0] !== a1[0]) {\n        m = abs((ix - a0[0]) / (a1[0] - a0[0]));\n      }\n      // echo(\">>\",i,ix,a0[0],a1[0],\";\",m,a0[1],a1[1])\n      if (m > 0) {\n        r = a0[1] * (1 - m) + a1[1] * m;\n      } else {\n        r = a0[1];\n      }\n      return r;\n    }\n  }\n  return r;\n}\n\nfunction pow(a, b) {\n  return Math.pow(a, b);\n}\n\nfunction sign(a) {\n  return a < 0 ? -1 : (a > 1 ? 1 : 0);\n}\n\nfunction sqrt(a) {\n  return Math.sqrt(a);\n}\n\nfunction round(a) {\n  return floor(a + 0.5);\n}\n\nmodule.exports = {\n  sin,\n  cos,\n  asin,\n  acos,\n  tan,\n  atan,\n  atan2,\n  ceil,\n  floor,\n  abs,\n  min,\n  max,\n  rands,\n  log,\n  lookup,\n  pow,\n  sign,\n  sqrt,\n  round\n};\n","const defaultFont = require('../fonts/single-line/hershey/simplex.js');\n\nconst defaultsVectorParams = {\n  xOffset: 0,\n  yOffset: 0,\n  input: '?',\n  align: 'left',\n  font: defaultFont,\n  height: 14, // == old vector_xxx simplex font height\n  lineSpacing: 2.142857142857143, // == 30/14 == old vector_xxx ratio\n  letterSpacing: 1,\n  extrudeOffset: 0\n};\n\n// vectorsXXX parameters handler\nfunction vectorParams(options, input) {\n  if (!input && typeof options === 'string') {\n    options = {input: options};\n  }\n  options = options || {};\n  let params = Object.assign({}, defaultsVectorParams, options);\n  params.input = input || params.input;\n  return params;\n}\n\n// translate text line\nfunction translateLine(options, line) {\n  const {x, y} = Object.assign({x: 0, y: 0}, options || {});\n  let segments = line.segments;\n  let segment = null;\n  let point = null;\n  for (let i = 0, il = segments.length; i < il; i++) {\n    segment = segments[i];\n    for (let j = 0, jl = segment.length; j < jl; j++) {\n      point = segment[j];\n      segment[j] = [point[0] + x, point[1] + y];\n    }\n  }\n  return line;\n}\n\n/** Represents a character as segments\n * @typedef {Object} VectorCharObject\n * @property {Float} width - character width\n * @property {Float} height - character height (uppercase)\n * @property {Array} segments - character segments [[[x, y], ...], ...]\n */\n\n/** Construct a {@link VectorCharObject} from a ascii character whose code is between 31 and 127,\n * if the character is not supported it is replaced by a question mark.\n * @param {Object|String} [options] - options for construction or ascii character\n * @param {Float} [options.xOffset=0] - x offset\n * @param {Float} [options.yOffset=0] - y offset\n * @param {Float} [options.height=21] - font size (uppercase height)\n * @param {Float} [options.extrudeOffset=0] - width of the extrusion that will be applied (manually) after the creation of the character\n * @param {String} [options.input='?'] - ascii character (ignored/overwrited if provided as seconds parameter)\n * @param {String} [char='?'] - ascii character\n * @returns {VectorCharObject}\n *\n * @example\n * let vectorCharObject = vectorChar()\n * or\n * let vectorCharObject = vectorChar('A')\n * or\n * let vectorCharObject = vectorChar({ xOffset: 57 }, 'C')\n * or\n * let vectorCharObject = vectorChar({ xOffset: 78, input: '!' })\n */\nfunction vectorChar(options, char) {\n  let {\n    xOffset, yOffset, input, font, height, extrudeOffset\n  } = vectorParams(options, char);\n  let code = input.charCodeAt(0);\n  if (!code || !font[code]) {\n    code = 63; // 63 => ?\n  }\n  let glyph = [].concat(font[code]);\n  let ratio = (height - extrudeOffset) / font.height;\n  let extrudeYOffset = (extrudeOffset / 2);\n  let width = glyph.shift() * ratio;\n  let segments = [];\n  let polyline = [];\n  for (let i = 0, il = glyph.length; i < il; i += 2) {\n    gx = ratio * glyph[i] + xOffset;\n    gy = ratio * glyph[i + 1] + yOffset + extrudeYOffset;\n    if (glyph[i] !== undefined) {\n      polyline.push([gx, gy]);\n      continue;\n    }\n    segments.push(polyline);\n    polyline = [];\n    i--;\n  }\n  if (polyline.length) {\n    segments.push(polyline);\n  }\n  return {width, height, segments};\n}\n\n/** Construct an array of character segments from a ascii string whose characters code is between 31 and 127,\n * if one character is not supported it is replaced by a question mark.\n * @param {Object|String} [options] - options for construction or ascii string\n * @param {Float} [options.xOffset=0] - x offset\n * @param {Float} [options.yOffset=0] - y offset\n * @param {Float} [options.height=21] - font size (uppercase height)\n * @param {Float} [options.lineSpacing=1.4] - line spacing expressed as a percentage of font size\n * @param {Float} [options.letterSpacing=1] - extra letter spacing expressed as a percentage of font size\n * @param {String} [options.align='left'] - multi-line text alignement: left, center or right\n * @param {Float} [options.extrudeOffset=0] - width of the extrusion that will be applied (manually) after the creation of the character\n * @param {String} [options.input='?'] - ascii string (ignored/overwrited if provided as seconds parameter)\n * @param {String} [text='?'] - ascii string\n * @returns {Array} characters segments [[[x, y], ...], ...]\n *\n * @example\n * let textSegments = vectorText()\n * or\n * let textSegments = vectorText('OpenJSCAD')\n * or\n * let textSegments = vectorText({ yOffset: -50 }, 'OpenJSCAD')\n * or\n * let textSegments = vectorText({ yOffset: -80, input: 'OpenJSCAD' })\n */\nfunction vectorText(options, text) {\n  let {\n    xOffset, yOffset, input, font, height, align, extrudeOffset, lineSpacing, letterSpacing\n  } = vectorParams(options, text);\n  let [x, y] = [xOffset, yOffset];\n  let [i, il, char, vect, width, diff] = [];\n  let line = {width: 0, segments: []};\n  let lines = [];\n  let output = [];\n  let maxWidth = 0;\n  let lineStart = x;\n  const pushLine = () => {\n    lines.push(line);\n    maxWidth = Math.max(maxWidth, line.width);\n    line = {width: 0, segments: []};\n  };\n  for (i = 0, il = input.length; i < il; i++) {\n    char = input[i];\n    vect = vectorChar({xOffset: x, yOffset: y, font, height, extrudeOffset}, char);\n    if (char === '\\n') {\n      x = lineStart;\n      y -= vect.height * lineSpacing;\n      pushLine();\n      continue;\n    }\n    width = vect.width * letterSpacing;\n    line.width += width;\n    x += width;\n    if (char !== ' ') {\n      line.segments = line.segments.concat(vect.segments);\n    }\n  }\n  if (line.segments.length) {\n    pushLine();\n  }\n  for (i = 0, il = lines.length; i < il; i++) {\n    line = lines[i];\n    if (maxWidth > line.width) {\n      diff = maxWidth - line.width;\n      if (align === 'right') {\n        line = translateLine({x: diff}, line);\n      } else if (align === 'center') {\n        line = translateLine({x: diff / 2}, line);\n      }\n    }\n    output = output.concat(line.segments);\n  }\n  return output;\n}\n\n/** Construct a {@link VectorCharObject} from a ascii character whose code is between 31 and 127,\n * if the character is not supported it is replaced by a question mark.\n * @param {Float} x - x offset\n * @param {Float} y - y offset\n * @param {String} char - ascii character\n * @returns {VectorCharObject}\n * @deprecated >= v2\n\n * @example\n * let vectorCharObject = vector_char(36, 0, 'B')\n */\nfunction vector_char(x, y, char) {\n  return vectorChar({xOffset: x, yOffset: y}, char);\n}\n\n/** Construct an array of character segments from a ascii string whose characters code is between 31 and 127,\n * if one character is not supported it is replaced by a question mark.\n * @param {Float} x - x offset\n * @param {Float} y - y offset\n * @param {String} text - ascii string\n * @returns {Array} characters segments [[[x, y], ...], ...]\n * @deprecated >= v2\n *\n * @example\n * let textSegments = vector_text(0, -20, 'OpenJSCAD')\n */\nfunction vector_text(x, y, text) {\n  return vectorText({xOffset: x, yOffset: y}, text);\n}\n\nmodule.exports = {\n  vector_char,\n  vector_text,\n  vectorChar,\n  vectorText\n};\n","// -- data source from from http://paulbourke.net/dataformats/hershey/\n// -- reduced to save some bytes...\n// { [ascii code]: [width, x, y, ...] } - undefined value as path separator\nmodule.exports = {\n  height: 14,\n  32: [16],\n  33: [10, 5, 21, 5, 7, , 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],\n  34: [16, 4, 21, 4, 14, , 12, 21, 12, 14],\n  35: [21, 11, 25, 4, -7, , 17, 25, 10, -7, , 4, 12, 18, 12, , 3, 6, 17, 6],\n  36: [20, 8, 25, 8, -4, , 12, 25, 12, -4, , 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3],\n  37: [24, 21, 21, 3, 0, , 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, , 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7],\n  38: [26, 23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2],\n  39: [10, 5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15],\n  40: [14, 11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7],\n  41: [14, 3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7],\n  42: [16, 8, 21, 8, 9, , 3, 18, 13, 12, , 13, 18, 3, 12],\n  43: [26, 13, 18, 13, 0, , 4, 9, 22, 9],\n  44: [10, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4],\n  45: [26, 4, 9, 22, 9],\n  46: [10, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],\n  47: [22, 20, 25, 2, -7],\n  48: [20, 9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21],\n  49: [20, 6, 17, 8, 18, 11, 21, 11, 0],\n  50: [20, 4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0],\n  51: [20, 5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4],\n  52: [20, 13, 21, 3, 7, 18, 7, , 13, 21, 13, 0],\n  53: [20, 15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4],\n  54: [20, 16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7],\n  55: [20, 17, 21, 7, 0, , 3, 21, 17, 21],\n  56: [20, 8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21],\n  57: [20, 16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3],\n  58: [10, 5, 14, 4, 13, 5, 12, 6, 13, 5, 14, , 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],\n  59: [10, 5, 14, 4, 13, 5, 12, 6, 13, 5, 14, , 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4],\n  60: [24, 20, 18, 4, 9, 20, 0],\n  61: [26, 4, 12, 22, 12, , 4, 6, 22, 6],\n  62: [24, 4, 18, 20, 9, 4, 0],\n  63: [18, 3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, , 9, 2, 8, 1, 9, 0, 10, 1, 9, 2],\n  64: [27, 18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, , 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, , 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, , 19, 16, 18, 8, 18, 6, 19, 5],\n  65: [18, 9, 21, 1, 0, , 9, 21, 17, 0, , 4, 7, 14, 7],\n  66: [21, 4, 21, 4, 0, , 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, , 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0],\n  67: [21, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5],\n  68: [21, 4, 21, 4, 0, , 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0],\n  69: [19, 4, 21, 4, 0, , 4, 21, 17, 21, , 4, 11, 12, 11, , 4, 0, 17, 0],\n  70: [18, 4, 21, 4, 0, , 4, 21, 17, 21, , 4, 11, 12, 11],\n  71: [21, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, , 13, 8, 18, 8],\n  72: [22, 4, 21, 4, 0, , 18, 21, 18, 0, , 4, 11, 18, 11],\n  73: [8, 4, 21, 4, 0],\n  74: [16, 12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7],\n  75: [21, 4, 21, 4, 0, , 18, 21, 4, 7, , 9, 12, 18, 0],\n  76: [17, 4, 21, 4, 0, , 4, 0, 16, 0],\n  77: [24, 4, 21, 4, 0, , 4, 21, 12, 0, , 20, 21, 12, 0, , 20, 21, 20, 0],\n  78: [22, 4, 21, 4, 0, , 4, 21, 18, 0, , 18, 21, 18, 0],\n  79: [22, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21],\n  80: [21, 4, 21, 4, 0, , 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10],\n  81: [22, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, , 12, 4, 18, -2],\n  82: [21, 4, 21, 4, 0, , 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, , 11, 11, 18, 0],\n  83: [20, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3],\n  84: [16, 8, 21, 8, 0, , 1, 21, 15, 21],\n  85: [22, 4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21],\n  86: [18, 1, 21, 9, 0, , 17, 21, 9, 0],\n  87: [24, 2, 21, 7, 0, , 12, 21, 7, 0, , 12, 21, 17, 0, , 22, 21, 17, 0],\n  88: [20, 3, 21, 17, 0, , 17, 21, 3, 0],\n  89: [18, 1, 21, 9, 11, 9, 0, , 17, 21, 9, 11],\n  90: [20, 17, 21, 3, 0, , 3, 21, 17, 21, , 3, 0, 17, 0],\n  91: [14, 4, 25, 4, -7, , 5, 25, 5, -7, , 4, 25, 11, 25, , 4, -7, 11, -7],\n  92: [14, 0, 21, 14, -3],\n  93: [14, 9, 25, 9, -7, , 10, 25, 10, -7, , 3, 25, 10, 25, , 3, -7, 10, -7],\n  94: [16, 6, 15, 8, 18, 10, 15, , 3, 12, 8, 17, 13, 12, , 8, 17, 8, 0],\n  95: [16, 0, -2, 16, -2],\n  96: [10, 6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17],\n  97: [19, 15, 14, 15, 0, , 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  98: [19, 4, 21, 4, 0, , 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3],\n  99: [18, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  100: [19, 15, 21, 15, 0, , 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  101: [18, 3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  102: [12, 10, 21, 8, 21, 6, 20, 5, 17, 5, 0, , 2, 14, 9, 14],\n  103: [19, 15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, , 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  104: [19, 4, 21, 4, 0, , 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0],\n  105: [8, 3, 21, 4, 20, 5, 21, 4, 22, 3, 21, , 4, 14, 4, 0],\n  106: [10, 5, 21, 6, 20, 7, 21, 6, 22, 5, 21, , 6, 14, 6, -3, 5, -6, 3, -7, 1, -7],\n  107: [17, 4, 21, 4, 0, , 14, 14, 4, 4, , 8, 8, 15, 0],\n  108: [8, 4, 21, 4, 0],\n  109: [30, 4, 14, 4, 0, , 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, , 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0],\n  110: [19, 4, 14, 4, 0, , 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0],\n  111: [19, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14],\n  112: [19, 4, 14, 4, -7, , 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3],\n  113: [19, 15, 14, 15, -7, , 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  114: [13, 4, 14, 4, 0, , 4, 8, 5, 11, 7, 13, 9, 14, 12, 14],\n  115: [17, 14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3],\n  116: [12, 5, 21, 5, 4, 6, 1, 8, 0, 10, 0, , 2, 14, 9, 14],\n  117: [19, 4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, , 15, 14, 15, 0],\n  118: [16, 2, 14, 8, 0, , 14, 14, 8, 0],\n  119: [22, 3, 14, 7, 0, , 11, 14, 7, 0, , 11, 14, 15, 0, , 19, 14, 15, 0],\n  120: [17, 3, 14, 14, 0, , 14, 14, 3, 0],\n  121: [16, 2, 14, 8, 0, , 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7],\n  122: [17, 14, 14, 3, 0, , 3, 14, 14, 14, , 3, 0, 14, 0],\n  123: [14, 9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, , 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, , 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7],\n  124: [8, 4, 25, 4, -7],\n  125: [14, 5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, , 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, , 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7],\n  126: [24, 3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, , 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]\n};\n"],"sourceRoot":""}