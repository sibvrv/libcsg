{"version":3,"sources":["webpack://libcsg/webpack/universalModuleDefinition","webpack://libcsg/webpack/bootstrap","webpack://libcsg/./core/math/index.ts","webpack://libcsg/./core/constants.ts","webpack://libcsg/./core/CSGFactories.ts","webpack://libcsg/./core/CAGFactories.ts","webpack://libcsg/./core/CAG.ts","webpack://libcsg/./core/Connector.ts","webpack://libcsg/./api/optionParsers.ts","webpack://libcsg/./modifiers/transforms/index.ts","webpack://libcsg/./core/utils/isCAG.ts","webpack://libcsg/./core/CSG.ts","webpack://libcsg/./primitives/csg/primitives3d.ts","webpack://libcsg/./core/utils/solve2Linear.ts","webpack://libcsg/./modifiers/booleans/index.ts","webpack://libcsg/./core/utils/sortHelpers.ts","webpack://libcsg/./modifiers/expansions/expandedShellOfCCSG.ts","webpack://libcsg/./modifiers/expansions/expandedShellOfCAG.ts","webpack://libcsg/./core/utils/isCSG.ts","webpack://libcsg/./modifiers/extrusions/index.ts","webpack://libcsg/./text/vectorChar.ts","webpack://libcsg/./text/vectorParams.ts","webpack://libcsg/./primitives/index.ts","webpack://libcsg/./core/utils/cagValidation.ts","webpack://libcsg/./core/utils/solidFromSlices.ts","webpack://libcsg/./core/utils/calcInterpolationFactor.ts","webpack://libcsg/./core/Properties.ts","webpack://libcsg/./core/utils/canonicalize.ts","webpack://libcsg/./core/FuzzyFactory3d.ts","webpack://libcsg/./core/FuzzyFactory.ts","webpack://libcsg/./core/utils/reTessellate.ts","webpack://libcsg/./api/ops-cnc.ts","webpack://libcsg/./api/centerHelper.ts","webpack://libcsg/./modifiers/expansions/index.ts","webpack://libcsg/./modifiers/extrusions/extrudeInOrthonormalBasis.ts","webpack://libcsg/./modifiers/transforms/hull.ts","webpack://libcsg/./primitives/geodesicSphere.ts","webpack://libcsg/./primitives/polyhedron.ts","webpack://libcsg/./color/css2rgb.ts","webpack://libcsg/./color/hue2rgb.ts","webpack://libcsg/./text/translateLine.ts","webpack://libcsg/./text/vectorText.ts","webpack://libcsg/./main.ts","webpack://libcsg/./primitives/square.ts","webpack://libcsg/./core/math/polygon3Factories.ts","webpack://libcsg/./core/math/PolygonShared.ts","webpack://libcsg/./core/math/Polygon2.ts","webpack://libcsg/./core/utils/linesIntersect.ts","webpack://libcsg/./modifiers/booleans/union.ts","webpack://libcsg/./modifiers/booleans/difference.ts","webpack://libcsg/./modifiers/booleans/intersection.ts","webpack://libcsg/./core/math/TransformationMethods.ts","webpack://libcsg/./core/math/Line2.ts","webpack://libcsg/./core/math/Line3.ts","webpack://libcsg/./core/math/Matrix4.ts","webpack://libcsg/./core/math/OrthoNormalBasis.ts","webpack://libcsg/./core/math/Path2.ts","webpack://libcsg/./core/math/Plane.ts","webpack://libcsg/./core/math/Polygon3.ts","webpack://libcsg/./core/Tree.ts","webpack://libcsg/./core/PolygonTreeNode.ts","webpack://libcsg/./core/splitPolygonByPlane.ts","webpack://libcsg/./core/Node.ts","webpack://libcsg/./core/utils/fixTJunctions.ts","webpack://libcsg/./core/FuzzyFactory2d.ts","webpack://libcsg/./core/utils/reTessellateCoplanarPolygons.ts","webpack://libcsg/./core/utils/insertSorted.ts","webpack://libcsg/./core/utils/interpolateBetween2DPointsForY.ts","webpack://libcsg/./core/utils/csgMeasurements.ts","webpack://libcsg/./core/utils/csgProjections.ts","webpack://libcsg/./api/ops-cuts.ts","webpack://libcsg/./modifiers/expansions/expand.ts","webpack://libcsg/./modifiers/expansions/contract.ts","webpack://libcsg/./core/ConnectorList.ts","webpack://libcsg/./core/math/Side.ts","webpack://libcsg/./core/math/Vector2.ts","webpack://libcsg/./core/math/Vector3.ts","webpack://libcsg/./core/math/Vertex2.ts","webpack://libcsg/./core/math/Vertex3.ts","webpack://libcsg/./core/utils/cagMeasurements.ts","webpack://libcsg/./modifiers/extrusions/extrudeInPlane.ts","webpack://libcsg/./modifiers/extrusions/extrude.ts","webpack://libcsg/./modifiers/extrusions/rotateExtrude.ts","webpack://libcsg/./modifiers/extrusions/linear_extrude.ts","webpack://libcsg/./modifiers/extrusions/rotate_extrude.ts","webpack://libcsg/./helpers/polygonFromPoints.ts","webpack://libcsg/./helpers/rightMultiply1x3VectorToArray.ts","webpack://libcsg/./helpers/cagToPointsArray.ts","webpack://libcsg/./math/clamp.ts","webpack://libcsg/./modifiers/extrusions/rectangular_extrude.ts","webpack://libcsg/./api/cagOutlinePaths.ts","webpack://libcsg/./primitives/csg/primitives2d.ts","webpack://libcsg/./primitives/circle.ts","webpack://libcsg/./primitives/polygon.ts","webpack://libcsg/./primitives/triangle.ts","webpack://libcsg/./primitives/cube.ts","webpack://libcsg/./modifiers/transforms/translate.ts","webpack://libcsg/./modifiers/transforms/scale.ts","webpack://libcsg/./modifiers/transforms/rotate.ts","webpack://libcsg/./modifiers/transforms/transform.ts","webpack://libcsg/./modifiers/transforms/center.ts","webpack://libcsg/./modifiers/transforms/mirror.ts","webpack://libcsg/./modifiers/transforms/expand.ts","webpack://libcsg/./modifiers/transforms/contract.ts","webpack://libcsg/./modifiers/transforms/minkowski.ts","webpack://libcsg/./helpers/ConvexHull.ts","webpack://libcsg/./helpers/ConvexHullPoint.ts","webpack://libcsg/./modifiers/transforms/chain_hull.ts","webpack://libcsg/./primitives/sphere.ts","webpack://libcsg/./primitives/cylinder.ts","webpack://libcsg/./primitives/torus.ts","webpack://libcsg/./color/index.ts","webpack://libcsg/./color/color.ts","webpack://libcsg/./color/colorTable/cssColors.ts","webpack://libcsg/./color/rgb2hsl.ts","webpack://libcsg/./color/rgb2html.ts","webpack://libcsg/./color/rgb2hsv.ts","webpack://libcsg/./color/html2rgb.ts","webpack://libcsg/./color/hsv2rgb.ts","webpack://libcsg/./color/hsl2rgb.ts","webpack://libcsg/./math/mathsHelpersAPI.ts","webpack://libcsg/./text/index.ts","webpack://libcsg/./text/vector_char.ts","webpack://libcsg/./text/fonts/single-line/hershey/simplex.ts","webpack://libcsg/./text/vector_text.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_CSGDEBUG","defaultResolution2D","defaultResolution3D","EPS","angleEPS","areaEPS","Math","sin","all","top","bottom","left","right","front","back","staticTag","getTag","fromPolygons","polygons","csg","CSG","isCanonicalized","isRetesselated","obj","map","Polygon3","fromObject","bin","class","Error","x","y","z","w","normal","plane","planes","planeData","numplanes","length","arrayindex","planeindex","Vector3","Create","Plane","push","pos","vertex","vertices","vertexData","numvertices","vertexindex","Vertex3","numpolygonvertices","polygonvertices","shared","polygon","shareds","_shared","Shared","numpolygons","numPolygons","numVerticesPerPolygon","polygonVertices","polygonPlaneIndexes","polygonSharedIndexes","polygonindex","fromSides","sides","cag","CAG","fromFakeCSG","Side","_fromFakePolygon","filter","Boolean","fromPoints","points","Array","isArray","undefined","fromPointsArray","fromNestedPointsArray","prevvertex","Vertex2","Vector2","point","result","isSelfIntersecting","area","abs","flipped","canonicalized","paths","forEach","_path","tree","p1","p2","parents","isHole","contains","path","parentKey","difference","union","fromPointsNoCheck","prevpoint","side","fromPath2","isClosed","getPoints","fromCompactBinary","numsides","sideVertexIndices","sideindex","vertexindex0","vertexindex1","cags","this","_toCSGWall","cagItem","reTesselated","subtract","subtractSub","rc","intersect","intersectSub","transform","matrix4x4","ismirror","isMirroring","newsides","reverse","center","axes","centerHelper","expandedShell","radius","resolution","expandedShellOfCAG","expand","contract","getBounds","debug","extrudeInOrthonormalBasis","orthonormalbasis","depth","options","extrudeInPlane","axis1","axis2","extrude","rotateExtrude","check","isCAGValid","canonicalize","reTessellate","getOutlinePaths","cagOutlinePaths","overCutInsideCorners","cutterradius","hasPointInside","toString","z0","z1","toPolygon3D","_toVector3DPairs","pairs","p0","vertex0","vertex1","pair","v","_toPlanePolygons","assign","origin","defaultAxis","defaultNormal","thisConnector","Connector","translation","axisVector","normalVector","toConnector","getTransformationTo","bounds","minus","plus","csgshell","csgplane","invert","polys","poly","uv","_toWallPolygons","iteration","toConnector1","toConnector2","toCag","m1","axisvector","m2","vps1","vps2","hasMirroredNormals","vps1List","vps2List","vps1Temp","vps2Temp","equals","vps1Item","idx","xbot0","xtop0","vp1","j","xbot1","distanceTo","xtop1","y0","y1","polygon1","fromPosAndUV","polygon2","toPoints","shift","toCompactBinary","vertexmap","Uint32Array","sidevertexindicesindex","vertextag","Float64Array","verticesArrayIndex","_x","_y","Vertex","circle","ellipse","rectangle","roundedRectangle","TransformationMethods","normalvector","unit","normalized","cross","multiply4x4","other","mirror","normalrotation","Number","us","transformation","Matrix4x4","negated","axesplane","anyPlaneFromVector3Ds","axesbasis","OrthoNormalBasis","angle1","to2D","angle","angle2","rotation","PI","multiply","getProjectionMatrix","rotationZ","getInverseProjectionMatrix","usAxesAligned","normalsplane","fromNormalAndPoint","normalsbasis","axisLine","Line3D","extend","distance","times","parseOption","optionname","defaultvalue","parseOptionAs3DVector","parseOptionAs3DVectorList","res","parseOptionAs2DVector","parseOptionAsFloat","isNaN","parseOptionAsInt","floor","parseOptionAsBool","properties","Properties","csgs","slice","unionSub","retesselate","mayOverlap","a","Tree","b","clipTo","newpolygons","allPolygons","concat","_merge","unionForNonIntersecting","islast","addPolygons","_reTessellate","flippedpolygons","transform1","_transform","transformedvertices","transformedplanes","newplane","planetag","newvertices","newvertex","unionWithThis","expandedShellOfCCSG","stretchAtPlane","onb","midpiece","sectionCut","piece1","cutByPlane","piece2","translate","fixTJunctions","mybounds","otherbounds","connectTo","myConnector","otherConnector","matrix","setShared","setColor","newshared","fromColor","args","getTransformationAndInverseTransformationToFlatLying","getTransformationToFlatLying","lieFlat","projectToOrthoNormalBasis","orthobasis","getFeatures","inFeatures","features","toTriangles","triPoly","getTetraFeatures","reduce","pv","feat","toPolygons","planemap","sharedmap","numshared","sharedtag","polygonVerticesIndex","sharedindex","_z","planesArrayIndex","firstVertex","Vector2D","Vector3D","Polygon","Polygon2D","Line2D","Path2D","ConnectorList","sphere","cube","roundedCube","cylinder","roundedCylinder","cylinderElliptic","polyhedron","fromSlices","optionsParsers","corner1","corner2","info","facecenters","xvector","yvector","zvector","prevcylinderpoint","qresolution","round","slice1","cylinderpoint","cos","prevcospitch","prevsinpitch","slice2","pitch","cospitch","sinpitch","facepoint","e","rEnd","rStart","alpha","slices","ray","axisZ","axisX","randomNonParallelVector","axisY","start","end","stack","out","t0","t1","cylCenter","fptVec","rotate","fptVec90","facepointH","facepointH90","defaultnormal","direction","cuberadius","roundradius","max","innerradius","scale","pt","faces","face","solve2Linear","u","invdet","index","_csg","extrudevector","extrudedface","vertexpairs","vertextagpair","prevvertextag","v1","v2","planenormals","vertexpair","startpoint","endpoint","zbase","xbase","ybase","angles","iMax","planenormal","si","dot","co","atan2","numangles","sort","fnNumberSort","prevp1","prevp2","startfacevertices","endfacevertices","skip","normals","vertexobj","xaxis","bestzaxis","bestzaxisorthogonality","crosslength","yaxis","zaxis","_sphere","_cag","pointmap","tag","dl","shellpoints","newcag","step","pcenter","end1","end2","angleDegrees","fullcircle","numsteps","fromAngleDegrees","char","xOffset","yOffset","input","font","height","extrudeOffset","code","charCodeAt","glyph","ratio","extrudeYOffset","width","segments","polyline","il","gx","gy","defaultsVectorParams","align","lineSpacing","letterSpacing","vectorParams","errors","pointcount","mappoint","count","err","side0","ii","side1","linesIntersect","console","log","inside","c1","c2","cag1","cag2","solidFromSlices","createFromPoints","fnCallback","prev","numSlices","bLoop","loop","numslices","callback","checkIfConvex","signedDistanceToPoint","_addWalls","every","unshift","walls","bFlipped","bottomPoints","topPoints","color","len","iTopLen","iBotLen","iExtra","bMoreTops","bMoreBottoms","aMin","Infinity","distanceToSquared","fnSortByIndex","secondPoint","getTriangle","pointA","pointB","pointC","triColor","bpoint","tpoint","iB","iT","calcInterpolationFactor","pointa","pointb","intermediatePoint","transformObj","source","propertyName","propertyValue","transformed","cloneObj","cloned","addFrom","otherproperties","csgOrCAG","canonicalizeCAG","canonicalizeCSG","FuzzyCSGFactory","CSGFromCSGFuzzyFactory","FuzzyCAGFactory","CAGFromCAGFuzzyFactory","sourcecsg","_this","newpolygon","getPolygon","sourcecag","getSide","vertexfactory","FuzzyFactory","planefactory","polygonsharedfactory","getPolygonShared","sourceshared","hash","getHash","getVertex","sourcevertex","elements","lookupOrCreate","els","getPlane","sourceplane","sourcepolygon","newverticesDedup","numdimensions","tolerance","lookuptable","multiplier","creatorCallback","el","valueQuantized","hashparts","q0","numhashes","hashmask","hashmaskShifted","hashpart","destpolygons","sourcepolygons","retesselayedpolygons","reTessellateCoplanarPolygons","z0connectorx","z0connectory","isfirst","minheight","maxdotz","besttransformation","bestinversetransformation","planeconnector","pointonplane","inversetransformation","transformedcsg","dotz","zheight","isbetter","from","to","cutouts","pointtag","pointobj","fromcoord","pointcoord","tocoord","angleRadians","midvector","circlesegmentangle","radiuscorrected","circlecenter","startangle","deltaangle","ceil","fromAngleRadians","defaults","objects","centerX","centerY","centerZ","results","offset","extruded","pts","done","isCAG","convexHull","ConvexHull","compute","indices","getIndices","ch","fn","ci","ti","mix3","factor","factorInv","cv","geodesicSubDivide","p3","f","s0","s1","s2","q","k","rv","sqrt","s3","triangles","fnValue","g","params","pgs","ref","colors","pp","defaultShared","colorName","line","segment","jl","text","lines","output","maxWidth","lineStart","pushLine","vect","vectorChar","diff","translateLine","primitives2d","square","triangle","primitives3d","geodesicSphere","torus","isCSG","version","size","halfWidth","halfHeight","vec","PolygonShared","join","p0start","p0end","p1start","p1end","d0","d1","alphas","extrude2d","intersection","mirrored","mirroring","mirroredX","mirroredY","mirroredZ","scaling","rotateX","deg","rotationX","rotateY","rotationY","rotateZ","rotationCenter","rotationAxis","degrees","rotateEulerAngles","beta","gamma","position","Rz1","Rx","Rz2","T","rotateEulerXYZ","Ry","Rz","_normal","parseFloat","_p1","_p2","xAtY","absDistanceToPoint","pointProjected","intersectWithLine","line2d","pointOnPlane","neworigin","newnormal","newpointOnPlane","neww","fromPlanes","mabsx","mabsy","mabsz","intersectWithPlane","labda","clone","newpoint","closestPointOnLine","_point","distanceToPoint","closestpoint","line3d","unity","radians","_rotationCenter","_rotationAxis","rotationPlane","nx","ny","nz","this0","this1","this2","this3","this4","this5","this6","this7","this8","this9","this10","this11","this12","this13","this14","this15","m0","m3","m4","m5","m6","m7","m8","m9","m10","m11","m12","m13","m14","m15","rightMultiply1x3Vector","v0","invw","leftMultiply1x3Vector","rightMultiply1x2Vector","leftMultiply1x2Vector","_rightvector","rightvector","planeorigin","GetCartesian","xaxisid","yaxisid","axisid","Z0Plane","vec3","to3D","vec2","line3Dto2D","a2d","b2d","line2Dto3D","a3d","b3d","rightpointTransformed","originTransformed","closed","newpoints","vPoint","arc","endangle","maketangent","absangledif","fromAngle","edgestepsize","numstepsMod","otherpath","appendPoint","appendPoints","close","getTurn","twiceArea","last","current","rectangularExtrude","expandToCAG","pathradius","numpoints","startindex","pointindex","innerToCAG","appendBezier","controlpoints","arguments","factorials","controlpointsParsed","lastBezierControlPoint","bezierOrder","fact","binomials","binomial","getPointForT","tK","oneMinusTNMinusK","pow","inv1MinusT","bernsteinCoefficient","newpointsT","subdivideBase","maxangle","maxsinangle","dir1","dir2","sinangle","t0New","t1New","point0New","point1New","splice","appendArc","inEndpoint","decimals","xradius","yradius","xaxisrotation","clockwise","largearc","sweepFlag","phi","cosphi","sinphi","minushalfdistance","startTranslated","biglambda","sqrtbiglambda","multiplier1","centerTranslated","vec1","theta1","theta2","deltatheta","theta","costheta","sintheta","fromVector3Ds","_a","_b","_c","point1","point2","point3","splitLineBetweenPoints","mirrorPoint","point3d","verticesConvex","prevprevpos","prevpos","isConvexPoint","nextpoint","isStrictlyConvexPoint","getSignedVolume","signedVolume","getArea","polygonArea","feature","offsetvector","sidefacepoints","nexti","xn","sidefacepolygon","boundingSphere","cachedBoundingSphere","box","boundingBox","middle","cachedBoundingBox","minpoint","maxpoint","min","points2d","polygonTree","PolygonTreeNode","rootnode","Node","alsoRemovecoplanarFront","getPolygons","polygontreenodes","addChild","addPolygonTreeNodes","parent","children","removed","isRootNode","remove","parentschildren","indexOf","recursivelyInvalidatePolygon","isRemoved","invertSub","node","queue","splitByPlane","coplanarfrontnodes","coplanarbacknodes","frontnodes","backnodes","nodes","_splitByPlane","bound","sphereradius","spherecenter","splitresult","splitPolygonByPlane","type","frontnode","backnode","newchild","thisw","hasfront","hasback","vertexIsBack","MINEPS","isback","frontvertices","backvertices","nextvertexindex","nextisback","interpolationFactor","intersectionvertex","interpolate","EPS_SQUARED","temp","clipPolygons","numpolygontreenodes","node1","numbacknodes","pop","bestplane","getParentPlaneNormals","maxdepth","addSide","sidemap","vertextag2sidestart","vertextag2sideend","starttag","endtag","newsidetag","deleteSide","newsideobj","sidetag","sideobjs","sideobj","nextvertex","nextvertextag","reversesidetag","ar","sidestocheck","sidemapisempty","donesomething","sidetagtocheck","donewithside","directionindex","startvertex","endvertex","startvertextag","endvertextag","matchingsides","matchingsideindex","matchingsidetag","matchingside","matchingsidestartvertex","matchingsideendvertex","matchingsidestartvertextag","startpos","endpos","insertionvertextag","insertionvertextagindex","item","newsidetag1","newsidetag2","newcsg","sourceside","polygonvertices2d","polygonuvcoordinates","polygontopvertexindexes","topy2polygonindexes","ycoordinatetopolygonindexes","ycoordinatebins","ycoordinateBinningFactor","poly3d","vertices2d","uvcoordinates","minindex","miny","maxy","pos2d","uvcoordinate","ycoordinatebin","newy","ycoordinates","ycoordinate","activepolygons","prevoutpolygonrow","yindex","newoutpolygonrow","ycoordinateAsString","polygonindexeswithcorner","activepolygonindex","activepolygon","newleftvertexindex","leftvertexindex","newrightvertexindex","rightvertexindex","nextleftvertexindex","nextrightvertexindex","topleft","topleftuv","topright","toprightuv","bottomleft","bottomleftuv","bottomright","bottomrightuv","nextycoordinate","startingpolygonindexes","polygonindexKey","topvertexindex","topleftvertexindex","toprightvertexindex","newactivepolygon","insertSorted","el1","el2","x1","interpolateBetween2DPointsForY","x2","activepolygonKey","lerp","outpolygon","leftline","rightline","prevoutpolygon","d2","prevcontinuedindexes","matchedindexes","thispolygon","prevpolygon","leftlinecontinues","rightlinecontinues","rightpoints","rightuvcoordinates","leftpoints","leftuvcoordinates","point2d","vertex3d","array","element","comparefunc","leftbound","rightbound","testindex","f1","f2","_bounds","volume","lengthSquared","plane1","plane2","cut3d","planecenter","maxdistance","_polygon","shape","connectors","connectorsList","fromPath2D","path2D","arg1","arg2","_fromPath2DTangents","_fromPath2DExplicit","axis","pathLen","toVector3D","appendConnector","angleIsh","angleIshVal","getAngle","setClosed","conn","followWith","cagish","getCag","cagishVal","connector","verify","currCag","prevConnector","prevCag","notFirst","apply","connI","connI1","vert1Indices","pts2d","newp1","newp2","dividedBy","toFixed","newVertex","newpos","newUv","offsetVector","twistangle","twiststeps","axisV","normalV","connS","connE","connT2","connT1","baseShape","twist","startAngle","overflow","totalAngle","clamp","overlapTolerance","shapePoints","cagToPointsArray","pointsWithNegativeX","pointsWithPositiveX","arePointsWithNegAndPosX","curPoint","nextPoint","prevMatrix","curMatrix","rightMultiply1x3VectorToArray","pointAP","pointBP","overlappingPoints","polygonFromPoints","sideShape","endCap","startCap","vector","basePoints","h","sideTagToSideMap","startVertexTagToSideTagMap","sideTag","startVertexTag","startSideTag","aVertexTag","sidesForcagVertex","connectedVertexPoints","cagSide","nextVertexTag","nextPossibleSideTags","nextSideIndex","bestAngle","cagAngle","sideIndex","nextPossibleSideTag","angleDiff","nextSideTag","e2","large","rswap","maxroundradius","rect","roundRadius","halfSize","mesh","_objects","scaleValue","transformationMatrix","isFinite","clear","ccw","_points","al","ang","dist","ConvexHullPoint","compare","tmp","M","hulls","hullsAmount","hull","r1","r2","radiusStart","radiusEnd","ri","ro","fni","fno","roti","baseCircle","rotate_extrude","colorValue","css2rgb","cssColors3ub","substring","parseInt","hue2rgb","TWO_PI","asin","acos","tan","atan","minValue","maxValue","vn","seed","random","ix","a0","a1","hersheyFont","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","vectorText"],"mappings":"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AAC,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAC/IC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,CAAE,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GACjYC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,EAAG,CAAE,EAAG,EAAG,GAAI,GAClDC,GAAI,CAAC,GAAI,EAAG,GAAI,EAAG,EAAG,CAAE,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,CAAE,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GACrKC,GAAI,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAA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","file":"main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"libcsg\"] = factory();\n\telse\n\t\troot[\"libcsg\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 40);\n","// Utils\n\nexport * from './polygon3Factories';\n\n// Extra\n\nexport * from './PolygonShared';\nexport * from './Polygon2';\n\n// Classes\n\nexport * from './TransformationMethods';\nexport * from './Line2';\nexport * from './Line3';\nexport * from './Matrix4';\nexport * from './OrthoNormalBasis';\nexport * from './Path2';\nexport * from './Plane';\nexport * from './Polygon3';\nexport * from './Side';\nexport * from './Vector2';\nexport * from './Vector3';\nexport * from './Vertex2';\nexport * from './Vertex3';\n","export const _CSGDEBUG = false;\n\n/**\n * Number of polygons per 360 degree revolution for 2D objects.\n * @default\n */\nexport const defaultResolution2D = 32; // FIXME this seems excessive\n\n/**\n * Number of polygons per 360 degree revolution for 3D objects.\n * @default\n */\nexport const defaultResolution3D = 12;\n\n/**\n * Epsilon used during determination of near zero distances.\n * @default\n */\nexport const EPS = 1e-5;\n\n/**\n * Epsilon used during determination of near zero areas.\n * @default\n */\nexport const angleEPS = 0.10;\n\n/**\n * Epsilon used during determination of near zero areas.\n * This is the minimal area of a minimal polygon.\n * @default\n */\nexport const areaEPS = 0.50 * EPS * EPS * Math.sin(angleEPS);\n\nexport const all = 0;\nexport const top = 1;\nexport const bottom = 2;\nexport const left = 3;\nexport const right = 4;\nexport const front = 5;\nexport const back = 6;\n\n// Tag factory: we can request a unique tag through CSG.getTag()\nexport let staticTag = 1;\nexport const getTag = () => staticTag++;\n","import {Plane, Polygon3, Vector3, Vertex3} from '@core/math';\nimport {CSG} from '@core/CSG';\n\n/**\n * Construct a CSG solid from a list of `Polygon` instances.\n * @param {Polygon[]} polygons - list of polygons\n * @returns {CSG} new CSG object\n */\nexport const fromPolygons = (polygons: Polygon3[]) => {\n  const csg = new CSG();\n  csg.polygons = polygons;\n  csg.isCanonicalized = false;\n  csg.isRetesselated = false;\n  return csg;\n};\n\n/**\n * Reconstruct a CSG solid from an object with identical property names.\n * @param {Object} obj - anonymous object, typically from JSON\n * @returns {CSG} new CSG object\n */\nexport function fromObject(obj: any) {\n  const polygons = obj.polygons.map((p: any) => {\n    return Polygon3.fromObject(p);\n  });\n  const csg = fromPolygons(polygons);\n  csg.isCanonicalized = obj.isCanonicalized;\n  csg.isRetesselated = obj.isRetesselated;\n  return csg;\n}\n\n/**\n * Reconstruct a CSG from the output of toCompactBinary().\n * @param {CompactBinary} bin - see toCompactBinary().\n * @returns {CSG} new CSG object\n */\nexport function fromCompactBinary(bin: any) {\n  if (bin.class !== 'CSG') throw new Error('Not a CSG');\n  const planes = [];\n  const planeData = bin.planeData;\n  const numplanes = planeData.length / 4;\n  let arrayindex = 0;\n  let x;\n  let y;\n  let z;\n  let w;\n  let normal;\n  let plane;\n  for (let planeindex = 0; planeindex < numplanes; planeindex++) {\n    x = planeData[arrayindex++];\n    y = planeData[arrayindex++];\n    z = planeData[arrayindex++];\n    w = planeData[arrayindex++];\n    normal = Vector3.Create(x, y, z);\n    plane = new Plane(normal, w);\n    planes.push(plane);\n  }\n\n  const vertices = [];\n  const vertexData = bin.vertexData;\n  const numvertices = vertexData.length / 3;\n  let pos;\n  let vertex;\n  arrayindex = 0;\n  for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n    x = vertexData[arrayindex++];\n    y = vertexData[arrayindex++];\n    z = vertexData[arrayindex++];\n    pos = Vector3.Create(x, y, z);\n    vertex = new Vertex3(pos);\n    vertices.push(vertex);\n  }\n\n  const shareds = bin.shared.map((_shared: any) => {\n    return Polygon3.Shared.fromObject(_shared);\n  });\n\n  const polygons = [];\n  const numpolygons = bin.numPolygons;\n  const numVerticesPerPolygon = bin.numVerticesPerPolygon;\n  const polygonVertices = bin.polygonVertices;\n  const polygonPlaneIndexes = bin.polygonPlaneIndexes;\n  const polygonSharedIndexes = bin.polygonSharedIndexes;\n  let numpolygonvertices;\n  let polygonvertices;\n  let shared;\n  let polygon; // already defined plane,\n  arrayindex = 0;\n  for (let polygonindex = 0; polygonindex < numpolygons; polygonindex++) {\n    numpolygonvertices = numVerticesPerPolygon[polygonindex];\n    polygonvertices = [];\n    for (let i = 0; i < numpolygonvertices; i++) {\n      polygonvertices.push(vertices[polygonVertices[arrayindex++]]);\n    }\n    plane = planes[polygonPlaneIndexes[polygonindex]];\n    shared = shareds[polygonSharedIndexes[polygonindex]];\n    polygon = new Polygon3(polygonvertices, shared, plane);\n    polygons.push(polygon);\n  }\n  const csg = fromPolygons(polygons);\n  csg.isCanonicalized = true;\n  csg.isRetesselated = true;\n  return csg;\n}\n","import {Side, Vector2, Vertex2} from '@core/math';\nimport {areaEPS} from '@core/constants';\nimport {contains, isSelfIntersecting} from './utils/cagValidation';\nimport {difference, union} from '@modifiers/booleans';\nimport {CAG} from '@core/CAG';\nimport {CSG} from '@core/CSG';\n\n/**\n * Construct a CAG from a list of `Side` instances.\n * @param {Side[]} sides - list of sides\n * @returns {CAG} new CAG object\n */\nexport const fromSides = (sides: Side[]) => {\n  const cag = new CAG();\n  cag.sides = sides;\n  return cag;\n};\n\n/**\n * Converts a CSG to a  The CSG must consist of polygons with only z coordinates +1 and -1\n * as constructed by _toCSGWall(-1, 1). This is so we can use the 3D union(), intersect() etc\n * @param csg\n */\nexport const fromFakeCSG = (csg: CSG) => {\n  const sides = csg.polygons\n    .map((p) => Side._fromFakePolygon(p)!)\n    .filter(Boolean);\n  return fromSides(sides);\n};\n\n/**\n * Construct a CAG from a list of points (a polygon) or an nested array of points.\n * The rotation direction of the points is not relevant.\n * The points can define a convex or a concave polygon.\n * The polygon must not self intersect.\n * Hole detection follows the even/odd rule,\n * which means that the order of the paths is not important.\n * @param {points[]|Array.<points[]>} points - (nested) list of points in 2D space\n * @returns {CAG} new CAG object\n */\nexport const fromPoints = (points: any): CAG => {\n  if (!points) {\n    throw new Error('points parameter must be defined');\n  }\n  if (!Array.isArray(points)) {\n    throw new Error('points parameter must be an array');\n  }\n  if (points[0].x !== undefined || typeof points[0][0] === 'number') {\n    return fromPointsArray(points);\n  }\n  if (typeof points[0][0] === 'object') {\n    return fromNestedPointsArray(points);\n  }\n  throw new Error('Unsupported points list format');\n};\n\n/**\n * Do not export the two following function (code splitting for fromPoints())\n * @param points\n */\nexport const fromPointsArray = (points: any) => {\n  if (points.length < 3) {\n    throw new Error('CAG shape needs at least 3 points');\n  }\n  const sides: any[] = [];\n  let prevvertex = new Vertex2(new Vector2(points[points.length - 1]));\n  points.map((point: any) => {\n    const vertex = new Vertex2(new Vector2(point));\n    sides.push(new Side(prevvertex, vertex));\n    prevvertex = vertex;\n  });\n  let result = fromSides(sides);\n  if (isSelfIntersecting(result)) {\n    throw new Error('Polygon is self intersecting!');\n  }\n  const area = result.area();\n  if (Math.abs(area) < areaEPS) {\n    throw new Error('Degenerate polygon!');\n  }\n  if (area < 0) {\n    result = result.flipped();\n  }\n  return result.canonicalized();\n};\n\n/**\n * From Nested Points Array\n * @param points\n */\nexport const fromNestedPointsArray = (points: any) => {\n  if (points.length === 1) {\n    return fromPoints(points[0]);\n  }\n  // First pass: create a collection of CAG paths\n  const paths: any = [];\n  points.forEach((_path: any) => {\n    paths.push(fromPointsArray(_path));\n  });\n  // Second pass: make a tree of paths\n  const tree: any = {};\n  // for each polygon extract parents and childs polygons\n  paths.forEach((p1: any, i: any) => {\n    // check for intersection\n    paths.forEach((p2: any, y: any) => {\n      if (p1 !== p2) {\n        // create default node\n        tree[i] || (tree[i] = {parents: [], isHole: false});\n        tree[y] || (tree[y] = {parents: [], isHole: false});\n        // check if polygon2 stay in poylgon1\n        if (contains(p2, p1)) {\n          // push parent and child; odd parents number ==> hole\n          tree[i].parents.push(y);\n          tree[i].isHole = !!(tree[i].parents.length % 2);\n          tree[y].isHole = !!(tree[y].parents.length % 2);\n        }\n      }\n    });\n  });\n  // Third pass: subtract holes\n  let path = null;\n\n  // tslint:disable-next-line:forin\n  for (const key in tree) {\n    path = tree[key];\n    if (path.isHole) {\n      delete tree[key]; // remove holes for final pass\n      path.parents.forEach((parentKey: any) => {\n        paths[parentKey] = difference(paths[parentKey], paths[key]);\n      });\n    }\n  }\n  // Fourth and last pass: create final CAG object\n  let cag = fromSides([]);\n\n  // tslint:disable-next-line:forin\n  for (const key in tree) {\n    cag = union(cag, paths[key]);\n  }\n  return cag;\n};\n\n/**\n * Reconstruct a CAG from an object with identical property names.\n * @param {Object} obj - anonymous object, typically from JSON\n * @returns {CAG} new CAG object\n */\nexport const fromObject = (obj: any) => {\n\n  const sides = obj.sides.map((s: any) => {\n    return Side.fromObject(s);\n  });\n\n  const cag = fromSides(sides);\n  cag.isCanonicalized = obj.isCanonicalized;\n\n  return cag;\n};\n\n/**\n * Construct a CAG from a list of points (a polygon).\n * Like fromPoints() but does not check if the result is a valid polygon.\n * The points MUST rotate counter clockwise.\n * The points can define a convex or a concave polygon.\n * The polygon must not self intersect.\n * @param {points[]} points - list of points in 2D space\n * @returns {CAG} new CAG object\n */\nexport const fromPointsNoCheck = (points: any) => {\n  const sides: any[] = [];\n  const prevpoint = new Vector2(points[points.length - 1]);\n\n  let prevvertex = new Vertex2(prevpoint);\n\n  points.map((p: any) => {\n    const point = new Vector2(p);\n    const vertex = new Vertex2(point);\n    const side = new Side(prevvertex, vertex);\n    sides.push(side);\n    prevvertex = vertex;\n  });\n  return fromSides(sides);\n};\n\n/**\n * Construct a CAG from a 2d-path (a closed sequence of points).\n * Like fromPoints() but does not check if the result is a valid polygon.\n * @param {path} Path2 - a Path2 path\n * @returns {CAG} new CAG object\n */\nexport const fromPath2 = (path: any) => {\n  if (!path.isClosed()) throw new Error('The path should be closed!');\n  return fromPoints(path.getPoints());\n};\n\n/**\n * Reconstruct a CAG from the output of toCompactBinary().\n * @param {CompactBinary} bin - see toCompactBinary()\n * @returns {CAG} new CAG object\n */\nexport const fromCompactBinary = (bin: any) => {\n  if (bin.class !== 'CAG') throw new Error('Not a CAG');\n  const vertices = [];\n  const vertexData = bin.vertexData;\n  const numvertices = vertexData.length / 2;\n  let arrayindex = 0;\n  for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n    const x = vertexData[arrayindex++];\n    const y = vertexData[arrayindex++];\n    const pos = new Vector2(x, y);\n    const vertex = new Vertex2(pos);\n    vertices.push(vertex);\n  }\n  const sides = [];\n  const numsides = bin.sideVertexIndices.length / 2;\n  arrayindex = 0;\n  for (let sideindex = 0; sideindex < numsides; sideindex++) {\n    const vertexindex0 = bin.sideVertexIndices[arrayindex++];\n    const vertexindex1 = bin.sideVertexIndices[arrayindex++];\n    const side = new Side(vertices[vertexindex0], vertices[vertexindex1]);\n    sides.push(side);\n  }\n  const cag = fromSides(sides);\n  cag.isCanonicalized = true;\n  return cag;\n};\n","import {Connector} from './Connector';\nimport {Matrix4x4, OrthoNormalBasis, Polygon3, Side, TransformationMethods, Vector2, Vector3, Vertex2, Vertex3} from './math';\n\nimport {fromPolygons} from './CSGFactories';\nimport {fromCompactBinary, fromFakeCSG, fromObject, fromPath2, fromPoints, fromPointsNoCheck, fromSides} from './CAGFactories';\n\nimport {canonicalize} from './utils/canonicalize';\nimport {reTessellate} from './utils/reTessellate';\nimport {hasPointInside, isCAGValid, isSelfIntersecting} from './utils/cagValidation';\nimport {area, getBounds} from './utils/cagMeasurements';\n// all of these are good candidates for elimination in this scope, since they are part of a functional api\nimport {overCutInsideCorners} from '@api/ops-cnc';\nimport {extrude, extrudeInOrthonormalBasis, extrudeInPlane, rotateExtrude} from '@modifiers/extrusions/';\nimport {cagOutlinePaths} from '@api/cagOutlinePaths';\nimport {centerHelper} from '@api/centerHelper';\nimport {contract, expand, expandedShellOfCAG} from '@modifiers/expansions';\n\nimport {circle, ellipse, rectangle, roundedRectangle} from '@primitives/csg/primitives2d';\nimport {IRotateExtrude} from '@modifiers/extrusions/rotateExtrude';\n\n/**\n * Holds a solid area geometry like CSG but 2D.\n * Each area consists of a number of sides.\n * Each side is a line between 2 points.\n * @class CAG\n * @constructor\n */\nexport class CAG extends TransformationMethods {\n  sides: Side[] = [];\n  isCanonicalized = false;\n\n  /**\n   * Union\n   * @param cag\n   */\n  union(cag: CAG | CAG[]) {\n    const cags = Array.isArray(cag) ? cag : [cag];\n    let r = this._toCSGWall(-1, 1);\n    r = r.union(\n      cags.map((cagItem) => {\n        return cagItem._toCSGWall(-1, 1).reTesselated();\n      }),\n    );\n    return fromFakeCSG(r).canonicalized();\n  }\n\n  /**\n   * Subtract\n   * @param cag\n   */\n  subtract(cag: CAG | CAG[]) {\n    const cags = Array.isArray(cag) ? cag : [cag];\n    let r = this._toCSGWall(-1, 1);\n\n    cags.forEach((cagItem) => {\n      r = r.subtractSub(cagItem._toCSGWall(-1, 1), false, false);\n    });\n\n    r = r.reTesselated();\n    r = r.canonicalized();\n\n    let rc = fromFakeCSG(r);\n    rc = rc.canonicalized();\n    return rc;\n  }\n\n  /**\n   * Intersect\n   * @param cag\n   */\n  intersect(cag: CAG | CAG []) {\n    const cags = Array.isArray(cag) ? cag : [cag];\n    let r = this._toCSGWall(-1, 1);\n    cags.map((cagItem) => {\n      r = r.intersectSub(cagItem._toCSGWall(-1, 1), false, false);\n    });\n\n    r = r.reTesselated();\n    r = r.canonicalized();\n\n    let rc = fromFakeCSG(r);\n    rc = rc.canonicalized();\n    return rc;\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): CAG {\n    const ismirror = matrix4x4.isMirroring();\n    const newsides = this.sides.map((side) => {\n      return side.transform(matrix4x4);\n    });\n    let result = fromSides(newsides);\n    if (ismirror) {\n      result = result.flipped();\n    }\n    return result;\n  }\n\n  /**\n   * get Flipped\n   */\n  flipped() {\n    const newsides = this.sides.map((side) => {\n      return side.flipped();\n    });\n    newsides.reverse();\n    return fromSides(newsides);\n  }\n\n  /**\n   * Center\n   * @alias center\n   * @param axes\n   */\n  center(axes: [boolean, boolean, boolean]) {\n    return centerHelper({axes}, [this as CAG]);\n  }\n\n  /**\n   * Expanded Shell\n   * @alias expandedShellOfCAG\n   * @param radius\n   * @param resolution\n   */\n  expandedShell(radius: number, resolution: number) {\n    return expandedShellOfCAG(this, radius, resolution);\n  }\n\n  /**\n   * Expand\n   * @alias expand\n   * @param radius\n   * @param resolution\n   */\n  expand(radius: number, resolution: number) {\n    return expand(this, radius, resolution);\n  }\n\n  /**\n   * Contract\n   * @alias contract\n   * @param radius\n   * @param resolution\n   */\n  contract(radius: number, resolution: number) {\n    return contract(this, radius, resolution);\n  }\n\n  /**\n   * get Area\n   * @alias area\n   */\n  area() {\n    return area(this);\n  }\n\n  /**\n   * get Bounds\n   * @alias getBounds\n   */\n  getBounds() {\n    return getBounds(this);\n  }\n\n  /**\n   * Is self intersecting\n   * @alias isSelfIntersecting\n   * @param debug\n   */\n  isSelfIntersecting(debug?: boolean) {\n    return isSelfIntersecting(this, debug);\n  }\n\n  /**\n   * Extrude In OrthonormalBasis\n   * extrusion: all aliases to simple functions\n   * @alias extrudeInOrthonormalBasis\n   * @param orthonormalbasis\n   * @param depth\n   * @param options\n   */\n  extrudeInOrthonormalBasis(orthonormalbasis: OrthoNormalBasis, depth: number, options?: any) {\n    return extrudeInOrthonormalBasis(this, orthonormalbasis, depth, options);\n  }\n\n  /**\n   * Extrude In Plane\n   * @alias extrudeInPlane\n   * @param axis1\n   * @param axis2\n   * @param depth\n   * @param options\n   */\n  extrudeInPlane(axis1: string, axis2: string, depth: number, options: any) {\n    return extrudeInPlane(this, axis1, axis2, depth, options);\n  }\n\n  /**\n   * Extrude\n   * @alias extrude\n   * @param options\n   */\n  extrude(options?: any) {\n    return extrude(this, options);\n  }\n\n  /**\n   * Rotate Extrude\n   * @alias rotateExtrude\n   * @param options\n   */\n  rotateExtrude(options?: Partial<IRotateExtrude>) { // FIXME options should be optional\n    return rotateExtrude(this, options);\n  }\n\n  /**\n   * Check\n   * @alias isCAGValid\n   */\n  check() {\n    return isCAGValid(this);\n  }\n\n  /**\n   * Canonicalized\n   * @alias canonicalize\n   */\n  canonicalized() {\n    return canonicalize(this);\n  }\n\n  // todo fix me\n  /**\n   * reTessellated\n   * @alias reTessellate\n   */\n  reTesselated() {\n    return reTessellate(this as any);\n  }\n\n  /**\n   * getOutlinePaths\n   * @alias cagOutlinePaths\n   */\n  getOutlinePaths() {\n    return cagOutlinePaths(this);\n  }\n\n  /**\n   * Over Cut Inside Corners\n   * @alias overCutInsideCorners\n   * @param cutterradius\n   */\n  overCutInsideCorners(cutterradius: number) {\n    return overCutInsideCorners(this, cutterradius);\n  }\n\n  /**\n   * Has Point Inside\n   * @param point\n   */\n  hasPointInside(point: Vector2) {\n    return hasPointInside(this, point);\n  }\n\n  /**\n   * To String helper\n   */\n  toString() {\n    let result = 'CAG (' + this.sides.length + ' sides):\\n';\n    this.sides.map((side) => {\n      result += '  ' + side.toString() + '\\n';\n    });\n    return result;\n  }\n\n  /**\n   * _toCSGWall\n   * @param z0\n   * @param z1\n   * @private\n   */\n  _toCSGWall(z0: number, z1: number) {\n    const polygons = this.sides.map((side) => {\n      return side.toPolygon3D(z0, z1);\n    });\n    return fromPolygons(polygons);\n  }\n\n  /**\n   * _toVector3DPairs\n   * @param m\n   * @private\n   */\n  _toVector3DPairs(m: Matrix4x4) {\n    // transform m\n    let pairs: Vector3[][] = this.sides.map((side) => {\n      const p0 = side.vertex0.pos;\n      const p1 = side.vertex1.pos;\n      return [\n        Vector3.Create(p0.x, p0.y, 0),\n        Vector3.Create(p1.x, p1.y, 0),\n      ];\n    });\n    if (typeof m !== 'undefined') {\n      pairs = pairs.map((pair) => {\n        return pair.map((v) => {\n          return v.transform(m);\n        });\n      });\n    }\n    return pairs;\n  }\n\n  /**\n   * _toPlanePolygons\n   * transform a cag into the polygons of a corresponding 3d plane, positioned per options\n   * Accepts a connector for plane positioning, or optionally\n   * single translation, axisVector, normalVector arguments\n   * (toConnector has precedence over single arguments if provided)\n   * @param options\n   * @private\n   */\n  _toPlanePolygons(options: any) {\n    const defaults = {\n      flipped: false,\n    };\n    options = Object.assign({}, defaults, options);\n    const {flipped} = options;\n    // reference connector for transformation\n    const origin = [0, 0, 0];\n    const defaultAxis = [0, 0, 1];\n    const defaultNormal = [0, 1, 0];\n    const thisConnector = new Connector(origin, defaultAxis, defaultNormal);\n    // translated connector per options\n    const translation = options.translation || origin;\n    const axisVector = options.axisVector || defaultAxis;\n    const normalVector = options.normalVector || defaultNormal;\n    // will override above if options has toConnector\n    const toConnector = options.toConnector ||\n      new Connector(translation, axisVector, normalVector);\n    // resulting transform\n    const m = thisConnector.getTransformationTo(toConnector, false, 0);\n    // create plane as a (partial non-closed) CSG in XY plane\n    const bounds = this.getBounds();\n    bounds[0] = bounds[0].minus(new Vector2(1, 1));\n    bounds[1] = bounds[1].plus(new Vector2(1, 1));\n    const csgshell = this._toCSGWall(-1, 1);\n    let csgplane = fromPolygons([\n      new Polygon3(\n        [\n          new Vertex3(new Vector3(bounds[0].x, bounds[0].y, 0)),\n          new Vertex3(new Vector3(bounds[1].x, bounds[0].y, 0)),\n          new Vertex3(new Vector3(bounds[1].x, bounds[1].y, 0)),\n          new Vertex3(new Vector3(bounds[0].x, bounds[1].y, 0)),\n        ],\n      ),\n    ]);\n    if (flipped) {\n      csgplane = csgplane.invert();\n    }\n    // intersectSub -> prevent premature reTessellate/canonicalize\n    csgplane = csgplane.intersectSub(csgshell);\n    // only keep the polygons in the z plane:\n    const polys = csgplane.polygons.filter((polygon) => {\n      return Math.abs(polygon.plane.normal.z) > 0.99;\n    });\n    // add uv vectors, corresponding with the x and y coordinates of the\n    // points defining the original CAG\n    polys.forEach((poly) => {\n      poly.vertices.forEach((vertex) => {\n        vertex.uv = new Vector2(vertex.pos.x, vertex.pos.y);\n      });\n    });\n\n    // finally, position the plane per passed transformations\n    return polys.map((poly) => {\n      return poly.transform(m);\n    });\n  }\n\n  /**\n   * _toWallPolygons\n   * given 2 connectors, this returns all polygons of a \"wall\" between 2\n   * copies of this cag, positioned in 3d space as \"bottom\" and\n   * \"top\" plane per connectors toConnector1, and toConnector2, respectively\n   * @param options\n   * @param iteration\n   * @private\n   */\n  _toWallPolygons(options: any, iteration = 0) {\n    // normals are going to be correct as long as toConn2.point - toConn1.point\n    // points into cag normal direction (check in caller)\n    // arguments: options.toConnector1, options.toConnector2, options.cag\n    //     walls go from toConnector1 to toConnector2\n    //     optionally, target cag to point to - cag needs to have same number of sides as this!\n    const origin = [0, 0, 0];\n    const defaultAxis = [0, 0, 1];\n    const defaultNormal = [0, 1, 0];\n    const thisConnector = new Connector(origin, defaultAxis, defaultNormal);\n    // arguments:\n    const toConnector1 = options.toConnector1;\n    // let toConnector2 = new Connector([0, 0, -30], defaultAxis, defaultNormal);\n    const toConnector2 = options.toConnector2;\n    if (!(toConnector1 instanceof Connector && toConnector2 instanceof Connector)) {\n      throw new Error('could not parse Connector arguments toConnector1 or toConnector2');\n    }\n    if (options.cag) {\n      if (options.cag.sides.length !== this.sides.length) {\n        throw new Error('target cag needs same sides count as start cag');\n      }\n    }\n    // target cag is same as this unless specified\n    const toCag = options.cag || this;\n    const m1 = thisConnector.getTransformationTo(toConnector1, toConnector1.axisvector.z < 0, 0);\n    const m2 = thisConnector.getTransformationTo(toConnector2, toConnector2.axisvector.z < 0, 0);\n    const vps1 = this._toVector3DPairs(m1);\n    let vps2 = toCag._toVector3DPairs(m2);\n    const hasMirroredNormals = toConnector1.axisvector.z < 0;\n\n    // group the Vector3DPairs by 2D polygon in case of multi-array cag\n    const vps1List: Vector3[][][] = [];\n    const vps2List: Vector3[][][] = [];\n    let vps1Temp: Vector3[][] = [vps1[0]];\n    let vps2Temp: Vector3[][] = [vps2[0]];\n    let i = 0;\n    for (i = 1; i < vps1.length; ++i) {\n      if (!(vps1[i][1].equals(vps1[i - 1][0]) || vps1[i][0].equals(vps1[i - 1][1]))) {\n        vps1List.push(vps1Temp);\n        vps1Temp = [];\n        vps2List.push(vps2Temp);\n        vps2Temp = [];\n      }\n      vps1Temp.push(vps1[i]);\n      vps2Temp.push(vps2[i]);\n    }\n    vps1List.push(vps1Temp);\n    vps2List.push(vps2Temp);\n\n    // calculate UV coordinates for each extruded side\n    const polygons: Polygon3[] = [];\n    vps1List.forEach((vps1Item, idx) => {\n      let xbot0 = 0;\n      let xtop0 = 0;\n      vps2 = vps2List[idx];\n      vps1Item.forEach((vp1, j) => {\n        const xbot1 = xbot0 + vp1[0].distanceTo(vp1[1]);\n        const xtop1 = xtop0 + vps2[j][0].distanceTo(vps2[j][1]);\n        const y0 = vp1[0].distanceTo(vps2[j][0]);\n        const y1 = vp1[1].distanceTo(vps2[j][1]);\n        const polygon1 = new Polygon3(\n          [\n            Vertex3.fromPosAndUV(vps2[j][1], new Vector2(xtop1, y1 * (1 + iteration))),\n            Vertex3.fromPosAndUV(vps2[j][0], new Vector2(xtop0, y0 * (1 + iteration))),\n            Vertex3.fromPosAndUV(vp1[0], new Vector2(xbot0, y0 * iteration)),\n          ]);\n        const polygon2 = new Polygon3(\n          [\n            Vertex3.fromPosAndUV(vps2[j][1], new Vector2(xtop1, y1 * (1 + iteration))),\n            Vertex3.fromPosAndUV(vp1[0], new Vector2(xbot0, y0 * iteration)),\n            Vertex3.fromPosAndUV(vp1[1], new Vector2(xbot1, y1 * iteration)),\n          ]);\n        if (hasMirroredNormals) {\n          polygon1.plane = polygon1.plane.flipped();\n          polygon2.plane = polygon2.plane.flipped();\n        }\n        polygons.push(polygon1);\n        polygons.push(polygon2);\n        xbot0 = xbot1;\n        xtop0 = xtop1;\n      });\n    });\n    return polygons;\n  }\n\n  /**\n   * Convert to a list of points.\n   * @return {points[]} list of points in 2D space\n   */\n  toPoints() {\n    const points = this.sides.map((side) => {\n      const v0 = side.vertex0;\n      // let v1 = side.vertex1\n      return v0.pos;\n    });\n    // due to the logic of fromPoints()\n    // move the first point to the last\n    if (points.length > 0) {\n      points.push(points.shift()!);\n    }\n    return points;\n  }\n\n  /**\n   * Convert to compact binary form.\n   * See fromCompactBinary.\n   * @return {CompactBinary}\n   */\n  toCompactBinary() {\n    const cag = this.canonicalized();\n    const numsides = cag.sides.length;\n    const vertexmap: {\n      [tag: number]: number;\n    } = {};\n    const vertices: Vertex2[] = [];\n    let numvertices = 0;\n    const sideVertexIndices = new Uint32Array(2 * numsides);\n    let sidevertexindicesindex = 0;\n    cag.sides.map((side) => {\n      [side.vertex0, side.vertex1].map((v) => {\n        const vertextag = v.getTag();\n        let vertexindex;\n        if (!(vertextag in vertexmap)) {\n          vertexindex = numvertices++;\n          vertexmap[vertextag] = vertexindex;\n          vertices.push(v);\n        } else {\n          vertexindex = vertexmap[vertextag];\n        }\n        sideVertexIndices[sidevertexindicesindex++] = vertexindex;\n      });\n    });\n    const vertexData = new Float64Array(numvertices * 2);\n    let verticesArrayIndex = 0;\n    vertices.map((v) => {\n      const pos = v.pos;\n      vertexData[verticesArrayIndex++] = pos._x;\n      vertexData[verticesArrayIndex++] = pos._y;\n    });\n    const result = {\n      'class': 'CAG',\n      sideVertexIndices,\n      vertexData,\n    };\n    return result;\n  }\n\n  // eek ! all this is kept for backwards compatibility...for now\n  static Vertex = Vertex2;\n  static Side = Side;\n\n  static circle = circle;\n  static ellipse = ellipse;\n  static rectangle = rectangle;\n  static roundedRectangle = roundedRectangle;\n\n  static fromSides = fromSides;\n  static fromObject = fromObject;\n  static fromPoints = fromPoints;\n  static fromPointsNoCheck = fromPointsNoCheck;\n  static fromPath2 = fromPath2;\n  static fromFakeCSG = fromFakeCSG;\n  static fromCompactBinary = fromCompactBinary;\n}\n","import {Line3D, Matrix4x4, OrthoNormalBasis, Plane, TransformationMethods, TVector3Universal, Vector3} from '@core/math';\n\n/**\n * A connector allows to attach two objects at predefined positions\n * For example a servo motor and a servo horn:\n * Both can have a Connector called 'shaft'\n * The horn can be moved and rotated such that the two connectors match\n * and the horn is attached to the servo motor at the proper position.\n * Connectors are stored in the properties of a CSG solid so they are\n * ge the same transformations applied as the solid\n */\nexport class Connector extends TransformationMethods {\n  point: Vector3;\n  axisvector: Vector3;\n  normalvector: Vector3;\n\n  /**\n   * Connector Constructor\n   */\n  constructor(point: TVector3Universal, axisvector: TVector3Universal, normalvector: TVector3Universal) {\n    super();\n    this.point = new Vector3(point);\n    this.axisvector = new Vector3(axisvector).unit();\n    this.normalvector = new Vector3(normalvector).unit();\n  }\n\n  /**\n   * get normalized Connector\n   */\n  normalized() {\n    const axisvector = this.axisvector.unit();\n    // make the normal vector truly normal:\n    const n = this.normalvector.cross(axisvector).unit();\n    const normalvector = axisvector.cross(n);\n    return new Connector(this.point, axisvector, normalvector);\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Connector {\n    const point = this.point.multiply4x4(matrix4x4);\n    const axisvector = this.point.plus(this.axisvector).multiply4x4(matrix4x4).minus(point);\n    const normalvector = this.point.plus(this.normalvector).multiply4x4(matrix4x4).minus(point);\n    return new Connector(point, axisvector, normalvector);\n  }\n\n  /**\n   * Get the transformation matrix to connect this Connector to another connector\n   * other: a Connector to which this connector should be connected\n   * @param other\n   * @param mirror -\n   *    false: the 'axis' vectors of the connectors should point in the same direction\n   *     true: the 'axis' vectors of the connectors should point in opposite direction\n   * @param normalrotation - degrees of rotation between the 'normal' vectors of the two connectors\n   */\n  getTransformationTo(other: Connector, mirror: boolean, normalrotation: number) {\n    mirror = mirror ? true : false;\n    normalrotation = normalrotation ? Number(normalrotation) : 0;\n    const us = this.normalized();\n    other = other.normalized();\n    // shift to the origin:\n    let transformation = Matrix4x4.translation(this.point.negated());\n    // construct the plane crossing through the origin and the two axes:\n    const axesplane = Plane.anyPlaneFromVector3Ds(\n      new Vector3(0, 0, 0), us.axisvector, other.axisvector);\n    const axesbasis = new OrthoNormalBasis(axesplane);\n    let angle1 = axesbasis.to2D(us.axisvector).angle();\n    let angle2 = axesbasis.to2D(other.axisvector).angle();\n    let rotation = 180.0 * (angle2 - angle1) / Math.PI;\n    if (mirror) rotation += 180.0;\n    transformation = transformation.multiply(axesbasis.getProjectionMatrix());\n    transformation = transformation.multiply(Matrix4x4.rotationZ(rotation));\n    transformation = transformation.multiply(axesbasis.getInverseProjectionMatrix());\n    const usAxesAligned = us.transform(transformation);\n    // Now we have done the transformation for aligning the axes.\n    // We still need to align the normals:\n    const normalsplane = Plane.fromNormalAndPoint(other.axisvector, new Vector3(0, 0, 0));\n    const normalsbasis = new OrthoNormalBasis(normalsplane);\n    angle1 = normalsbasis.to2D(usAxesAligned.normalvector).angle();\n    angle2 = normalsbasis.to2D(other.normalvector).angle();\n    rotation = 180.0 * (angle2 - angle1) / Math.PI;\n    rotation += normalrotation;\n    transformation = transformation.multiply(normalsbasis.getProjectionMatrix());\n    transformation = transformation.multiply(Matrix4x4.rotationZ(rotation));\n    transformation = transformation.multiply(normalsbasis.getInverseProjectionMatrix());\n    // and translate to the destination point:\n    transformation = transformation.multiply(Matrix4x4.translation(other.point));\n    // let usAligned = us.transform(transformation);\n    return transformation;\n  }\n\n  /**\n   * Axis Line\n   */\n  axisLine() {\n    return new Line3D(this.point, this.axisvector);\n  }\n\n  /**\n   * creates a new Connector, with the connection point moved in the direction of the axisvector\n   * @param distance\n   */\n  extend(distance: number) {\n    const newpoint = this.point.plus(this.axisvector.unit().times(distance));\n    return new Connector(newpoint, this.axisvector, this.normalvector);\n  }\n}\n","import {Vector2, Vector3} from '@core/math';\n\n/**\n * Parse an option from the options object\n * If the option is not present, return the default value\n * @param options\n * @param optionname\n * @param defaultvalue\n */\nexport const parseOption = (options: any, optionname: string, defaultvalue: any) => {\n  let result = defaultvalue;\n  if (options && optionname in options) {\n    result = options[optionname];\n  }\n  return result;\n};\n\n/**\n * Parse an option and force into a Vector3. If a scalar is passed it is converted\n * into a vector with equal x,y,z\n * @param options\n * @param optionname\n * @param defaultvalue\n */\nexport const parseOptionAs3DVector = (options: any, optionname: string, defaultvalue: any) => {\n  let result = parseOption(options, optionname, defaultvalue);\n  result = new Vector3(result);\n  return result;\n};\n\n/**\n * Parse an option and force into a Vector3 List.\n * @param options\n * @param optionname\n * @param defaultvalue\n */\nexport const parseOptionAs3DVectorList = (options: any, optionname: string, defaultvalue: any) => {\n  const result = parseOption(options, optionname, defaultvalue);\n  return result.map((res: any) => {\n    return new Vector3(res);\n  });\n};\n\n/**\n * Parse an option and force into a Vector2. If a scalar is passed it is converted\n * into a vector with equal x,y\n * @param options\n * @param optionname\n * @param defaultvalue\n */\nexport const parseOptionAs2DVector = (options: any, optionname: string, defaultvalue: any) => {\n  let result = parseOption(options, optionname, defaultvalue);\n  result = new Vector2(result);\n  return result;\n};\n\n/**\n * Parse an option and force into a Float.\n * @param options\n * @param optionname\n * @param defaultvalue\n */\nexport const parseOptionAsFloat = (options: any, optionname: string, defaultvalue: any) => {\n  let result = parseOption(options, optionname, defaultvalue);\n  if (typeof (result) === 'string') {\n    result = Number(result);\n  }\n  if (isNaN(result) || typeof (result) !== 'number') {\n    throw new Error('Parameter ' + optionname + ' should be a number');\n  }\n  return result;\n};\n\n/**\n * Parse an option and force into a Integer.\n * @param options\n * @param optionname\n * @param defaultvalue\n */\nexport const parseOptionAsInt = (options: any, optionname: string, defaultvalue: any) => {\n  let result = parseOption(options, optionname, defaultvalue);\n  result = Number(Math.floor(result));\n  if (isNaN(result)) {\n    throw new Error('Parameter ' + optionname + ' should be a number');\n  }\n  return result;\n};\n\n/**\n * Parse an option and force into a Boolean.\n * @param options\n * @param optionname\n * @param defaultvalue\n */\nexport const parseOptionAsBool = (options: any, optionname: string, defaultvalue: any) => {\n  let result = parseOption(options, optionname, defaultvalue);\n  if (typeof (result) === 'string') {\n    if (result === 'true') result = true;\n    else if (result === 'false') result = false;\n    else if (result === '0') result = false;\n  }\n  result = !!result;\n  return result;\n};\n","// -- 3D transformations (OpenSCAD like notion)\n\nexport * from './translate';\nexport * from './scale';\nexport * from './rotate';\nexport * from './transform';\nexport * from './center';\nexport * from './mirror';\nexport * from './expand';\nexport * from './contract';\nexport * from './minkowski';\nexport * from './hull';\nexport * from './chain_hull';\n","/**\n * Is CAG object\n * @param object\n */\nexport function isCAG(object: any) {\n  // objects[i] instanceof CAG => NOT RELIABLE\n  // 'instanceof' causes huge issues when using objects from\n  // two different versions of CSG.js as they are not reckonized as one and the same\n  // so DO NOT use instanceof to detect matching types for CSG/CAG\n  if (!('sides' in object)) {\n    return false;\n  }\n\n  if (!('length' in object.sides)) {\n    return false;\n  }\n\n  return true;\n}\n","import {Tree} from '@core/Tree';\nimport {Line2D, Line3D, Matrix4x4, OrthoNormalBasis, Path2D, Plane, Polygon2D, Polygon3, PolygonShared, TransformationMethods, TVector3Universal, Vector2, Vector3, Vertex3} from '@core/math';\n\nimport {Properties} from '@core/Properties';\nimport {fixTJunctions} from '@core/utils/fixTJunctions';\nimport {canonicalize as canonicalizeFunc} from '@core/utils/canonicalize';\nimport {reTessellate} from '@core/utils/reTessellate';\nimport {bounds} from '@core/utils/csgMeasurements';\nimport {projectToOrthoNormalBasis} from '@core/utils/csgProjections';\n\nimport {getTransformationAndInverseTransformationToFlatLying, getTransformationToFlatLying, lieFlat} from '@api/ops-cnc';\nimport {cutByPlane, sectionCut} from '@api/ops-cuts';\nimport {centerHelper} from '@api/centerHelper';\nimport {contract, expand, expandedShellOfCCSG} from '@modifiers/expansions';\n\nimport {_CSGDEBUG, all, angleEPS, areaEPS, back, bottom, defaultResolution2D, defaultResolution3D, EPS, front, getTag, left, right, staticTag, top} from '@core/constants';\nimport {cube, cylinder, cylinderElliptic, polyhedron, roundedCube, roundedCylinder, sphere} from '@primitives/csg/primitives3d';\nimport {fromCompactBinary, fromObject, fromPolygons} from './CSGFactories';\nimport * as optionsParsers from '@api/optionParsers';\nimport {Connector} from '@core/Connector';\nimport {ConnectorList} from '@core/ConnectorList';\nimport {fromSlices} from './utils/solidFromSlices';\n\n/**\n * Holds a binary space partition tree representing a 3D solid. Two solids can\n * be combined using the `union()`, `subtract()`, and `intersect()` methods.\n * @class CSG\n * @constructor\n */\nexport class CSG extends TransformationMethods {\n  polygons: Polygon3[] = [];\n  properties = new Properties();\n  isCanonicalized = true;\n  isRetesselated = true;\n  cachedBoundingBox?: [Vector3, Vector3];\n\n  /**\n   * Return a new CSG solid representing the space in either this solid or\n   * in the given solids. Neither this solid nor the given solids are modified.\n   * @param {CSG[]} csg - list of CSG objects\n   * @returns {CSG} new CSG object\n   * @example\n   * let C = A.union(B)\n   * @example\n   * +-------+            +-------+\n   * |       |            |       |\n   * |   A   |            |       |\n   * |    +--+----+   =   |       +----+\n   * +----+--+    |       +----+       |\n   *      |   B   |            |       |\n   *      |       |            |       |\n   *      +-------+            +-------+\n   */\n  union(csg: CSG | CSG[]) {\n    let csgs;\n    if (csg instanceof Array) {\n      csgs = csg.slice(0);\n      csgs.push(this);\n    } else {\n      csgs = [this, csg];\n    }\n\n    let i;\n    // combine csg pairs in a way that forms a balanced binary tree pattern\n    for (i = 1; i < csgs.length; i += 2) {\n      csgs.push(csgs[i - 1].unionSub(csgs[i]));\n    }\n    return csgs[i - 1].reTesselated().canonicalized();\n  }\n\n  /**\n   * Union Sub\n   * @param csg\n   * @param retesselate\n   * @param canonicalize\n   */\n  unionSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean) {\n    if (!this.mayOverlap(csg)) {\n      return this.unionForNonIntersecting(csg);\n    } else {\n      const a = new Tree(this.polygons);\n      const b = new Tree(csg.polygons);\n      a.clipTo(b, false);\n\n      // b.clipTo(a, true); // ERROR: this doesn't work\n      b.clipTo(a);\n      b.invert();\n      b.clipTo(a);\n      b.invert();\n\n      const newpolygons = a.allPolygons().concat(b.allPolygons());\n      let result = fromPolygons(newpolygons);\n      result.properties = this.properties._merge(csg.properties);\n      if (retesselate) result = result.reTesselated();\n      if (canonicalize) result = result.canonicalized();\n      return result;\n    }\n  }\n\n  /**\n   * unionForNonIntersecting\n   * Like union, but when we know that the two solids are not intersecting\n   * Do not use if you are not completely sure that the solids do not intersect!\n   * @param csg\n   */\n  unionForNonIntersecting(csg: CSG) {\n    const newpolygons = this.polygons.concat(csg.polygons);\n    const result = fromPolygons(newpolygons);\n    result.properties = this.properties._merge(csg.properties);\n    result.isCanonicalized = this.isCanonicalized && csg.isCanonicalized;\n    result.isRetesselated = this.isRetesselated && csg.isRetesselated;\n    return result;\n  }\n\n  /**\n   * Return a new CSG solid representing space in this solid but\n   * not in the given solids. Neither this solid nor the given solids are modified.\n   * @param {CSG[]} csg - list of CSG objects\n   * @returns {CSG} new CSG object\n   * @example\n   * let C = A.subtract(B)\n   * @example\n   * +-------+            +-------+\n   * |       |            |       |\n   * |   A   |            |       |\n   * |    +--+----+   =   |    +--+\n   * +----+--+    |       +----+\n   *      |   B   |\n   *      |       |\n   *      +-------+\n   */\n  subtract(csg: CSG | CSG[]) {\n    let csgs;\n    if (csg instanceof Array) {\n      csgs = csg;\n    } else {\n      csgs = [csg];\n    }\n    let result: CSG = this;\n    for (let i = 0; i < csgs.length; i++) {\n      const islast = (i === (csgs.length - 1));\n      result = result.subtractSub(csgs[i], islast, islast);\n    }\n    return result;\n  }\n\n  /**\n   * Subtract Sub\n   * @param csg\n   * @param retesselate\n   * @param canonicalize\n   */\n  subtractSub(csg: CSG, retesselate?: boolean, canonicalize?: boolean) {\n    const a = new Tree(this.polygons);\n    const b = new Tree(csg.polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a, true);\n    a.addPolygons(b.allPolygons());\n    a.invert();\n    let result = fromPolygons(a.allPolygons());\n    result.properties = this.properties._merge(csg.properties);\n    if (retesselate) result = result.reTesselated();\n    if (canonicalize) result = result.canonicalized();\n    return result;\n  }\n\n  /**\n   * Return a new CSG solid representing space in both this solid and\n   * in the given solids. Neither this solid nor the given solids are modified.\n   * @param {CSG[]} csg - list of CSG objects\n   * @returns {CSG} new CSG object\n   * @example\n   * let C = A.intersect(B)\n   * @example\n   * +-------+\n   * |       |\n   * |   A   |\n   * |    +--+----+   =   +--+\n   * +----+--+    |       +--+\n   *      |   B   |\n   *      |       |\n   *      +-------+\n   */\n  intersect(csg: CSG | CSG[]) {\n    let csgs;\n    if (csg instanceof Array) {\n      csgs = csg;\n    } else {\n      csgs = [csg];\n    }\n    let result: CSG = this;\n    for (let i = 0; i < csgs.length; i++) {\n      const islast = (i === (csgs.length - 1));\n      result = result.intersectSub(csgs[i], islast, islast);\n    }\n    return result;\n  }\n\n  /**\n   * Intersect Sub\n   * @param csg\n   * @param _reTessellate\n   * @param canonicalize\n   */\n  intersectSub(csg: CSG, _reTessellate?: boolean, canonicalize?: boolean) {\n    const a = new Tree(this.polygons);\n    const b = new Tree(csg.polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.addPolygons(b.allPolygons());\n    a.invert();\n    let result = fromPolygons(a.allPolygons());\n    result.properties = this.properties._merge(csg.properties);\n    if (_reTessellate) {\n      result = result.reTesselated();\n    }\n    if (canonicalize) {\n      result = result.canonicalized();\n    }\n    return result;\n  }\n\n  /**\n   * Return a new CSG solid with solid and empty space switched.\n   * This solid is not modified.\n   * @returns {CSG} new CSG object\n   * @example\n   * let B = A.invert()\n   */\n  invert() {\n    const flippedpolygons = this.polygons.map((p) => {\n      return p.flipped();\n    });\n    return fromPolygons(flippedpolygons);\n    // TODO: flip properties?\n  }\n\n  /**\n   * Affine transformation of CSG object. Returns a new CSG object\n   * @param matrix4x4\n   */\n  transform1(matrix4x4: Matrix4x4) {\n    const newpolygons = this.polygons.map((p) => {\n      return p.transform(matrix4x4);\n    });\n    const result = fromPolygons(newpolygons);\n    result.properties = this.properties._transform(matrix4x4);\n    result.isRetesselated = this.isRetesselated;\n    return result;\n  }\n\n  /**\n   * Return a new CSG solid that is transformed using the given Matrix.\n   * Several matrix transformations can be combined before transforming this solid.\n   * @param {CSG.Matrix4x4} matrix4x4 - matrix to be applied\n   * @returns {CSG} new CSG object\n   * @example\n   * var m = new CSG.Matrix4x4()\n   * m = m.multiply(CSG.Matrix4x4.rotationX(40))\n   * m = m.multiply(CSG.Matrix4x4.translation([-.5, 0, 0]))\n   * let B = A.transform(m)\n   */\n  transform(matrix4x4: Matrix4x4): CSG {\n    const ismirror = matrix4x4.isMirroring();\n    const transformedvertices: { [tag: number]: Vertex3 } = {};\n    const transformedplanes: { [tag: number]: Plane } = {};\n\n    const newpolygons = this.polygons.map((p) => {\n      let newplane;\n      const plane = p.plane;\n      const planetag = plane.getTag();\n      if (planetag in transformedplanes) {\n        newplane = transformedplanes[planetag];\n      } else {\n        newplane = plane.transform(matrix4x4);\n        transformedplanes[planetag] = newplane;\n      }\n      const newvertices = p.vertices.map((v) => {\n        let newvertex;\n        const vertextag = v.getTag();\n        if (vertextag in transformedvertices) {\n          newvertex = transformedvertices[vertextag];\n        } else {\n          newvertex = v.transform(matrix4x4);\n          transformedvertices[vertextag] = newvertex;\n        }\n        return newvertex;\n      });\n      if (ismirror) newvertices.reverse();\n      return new Polygon3(newvertices, p.shared, newplane);\n    });\n\n    const result = fromPolygons(newpolygons);\n    result.properties = this.properties._transform(matrix4x4);\n    result.isRetesselated = this.isRetesselated;\n    result.isCanonicalized = this.isCanonicalized;\n    return result;\n  }\n\n  /**\n   * Center\n   * @alias center\n   * @param axes\n   */\n  center(axes: [boolean, boolean, boolean]) {\n    return centerHelper({axes}, [this as CSG]);\n  }\n\n  /**\n   * Expand\n   * @alias expand\n   * @param radius\n   * @param resolution\n   */\n  expand(radius: number, resolution: number) {\n    return expand(this, radius, resolution);\n  }\n\n  /**\n   * Contract\n   * @alias contract\n   * @param radius\n   * @param resolution\n   */\n  contract(radius: number, resolution: number) {\n    return contract(this, radius, resolution);\n  }\n\n  /**\n   * Expanded Shell Of CCSG\n   * @alias expandedShellOfCCSG\n   * @param radius\n   * @param resolution\n   * @param unionWithThis\n   */\n  expandedShell(radius: number, resolution: number, unionWithThis?: boolean) {\n    return expandedShellOfCCSG(this, radius, resolution, unionWithThis);\n  }\n\n  /**\n   * Stretch At Plane\n   * cut the solid at a plane, and stretch the cross-section found along plane normal\n   * note: only used in roundedCube() internally\n   * @param normal\n   * @param point\n   * @param length\n   */\n  stretchAtPlane(normal: TVector3Universal, point: TVector3Universal, length: number) {\n    const plane = Plane.fromNormalAndPoint(normal, point);\n    const onb = new OrthoNormalBasis(plane);\n    const crosssect = this.sectionCut(onb);\n    const midpiece = crosssect.extrudeInOrthonormalBasis(onb, length);\n    const piece1 = this.cutByPlane(plane);\n    const piece2 = this.cutByPlane(plane.flipped());\n    const result = piece1.union([midpiece, piece2.translate(plane.normal.times(length))]);\n    return result;\n  }\n\n  /**\n   * canonicalized\n   * @alias canonicalizeFunc\n   */\n  canonicalized() {\n    return canonicalizeFunc(this);\n  }\n\n  /**\n   * reTessellated\n   * @alias reTessellate\n   */\n  reTesselated() {\n    return reTessellate(this);\n  }\n\n  /**\n   * Fix TJunctions\n   * @alias fixTJunctions\n   */\n  fixTJunctions() {\n    return fixTJunctions(fromPolygons, this);\n  }\n\n  /**\n   * getBounds\n   * @alias bounds\n   */\n  getBounds() {\n    return bounds(this);\n  }\n\n  /**\n   * May Overlap\n   * Returns true if there is a possibility that the two solids overlap\n   * returns false if we can be sure that they do not overlap\n   * NOTE: this is critical as it is used in UNIONs\n   * @param  {CSG} csg\n   */\n  mayOverlap(csg: CSG) {\n    if ((this.polygons.length === 0) || (csg.polygons.length === 0)) {\n      return false;\n    } else {\n      const mybounds = bounds(this);\n      const otherbounds = bounds(csg);\n      if (mybounds[1].x < otherbounds[0].x) return false;\n      if (mybounds[0].x > otherbounds[1].x) return false;\n      if (mybounds[1].y < otherbounds[0].y) return false;\n      if (mybounds[0].y > otherbounds[1].y) return false;\n      if (mybounds[1].z < otherbounds[0].z) return false;\n      if (mybounds[0].z > otherbounds[1].z) return false;\n      return true;\n    }\n  }\n\n  /**\n   * Cut By Plane\n   * @alias cutByPlane\n   * @param plane\n   */\n  cutByPlane(plane: Plane) {\n    return cutByPlane(this, plane);\n  }\n\n  /**\n   * Connect a solid to another solid, such that two Connectors become connected\n   * @param  {Connector} myConnector a Connector of this solid\n   * @param  {Connector} otherConnector a Connector to which myConnector should be connected\n   * @param  {Boolean} mirror false: the 'axis' vectors of the connectors should point in the same direction\n   * true: the 'axis' vectors of the connectors should point in opposite direction\n   * @param  {Float} normalrotation degrees of rotation between the 'normal' vectors of the two\n   * connectors\n   * @returns {CSG} this csg, tranformed accordingly\n   */\n  connectTo(myConnector: Connector, otherConnector: Connector, mirror: boolean, normalrotation: number) {\n    const matrix = myConnector.getTransformationTo(otherConnector, mirror, normalrotation);\n    return this.transform(matrix);\n  }\n\n  /**\n   * set the .shared property of all polygons\n   * @param  {Object} shared\n   * @returns {CSG} Returns a new CSG solid, the original is unmodified!\n   */\n  setShared(shared: PolygonShared) {\n    const polygons = this.polygons.map((p) => {\n      return new Polygon3(p.vertices, shared, p.plane);\n    });\n    const result = fromPolygons(polygons);\n    result.properties = this.properties; // keep original properties\n    result.isRetesselated = this.isRetesselated;\n    result.isCanonicalized = this.isCanonicalized;\n    return result;\n  }\n\n  /**\n   * sets the color of this csg: non mutating, returns a new CSG\n   * @param  {Object} args\n   * @returns {CSG} a copy of this CSG, with the given color\n   */\n  setColor(...args: any[]) {\n    const newshared = Polygon3.Shared.fromColor(...args);\n    return this.setShared(newshared);\n  }\n\n  /**\n   * Get Transformation And Inverse Transformation To Flat Lying\n   * @alias getTransformationAndInverseTransformationToFlatLying\n   */\n  getTransformationAndInverseTransformationToFlatLying() {\n    return getTransformationAndInverseTransformationToFlatLying(this);\n  }\n\n  /**\n   * Get Transformation To Flat Lying\n   * @alias getTransformationToFlatLying\n   */\n  getTransformationToFlatLying() {\n    return getTransformationToFlatLying(this);\n  }\n\n  /**\n   * Lie Flat\n   * @alias lieFlat\n   */\n  lieFlat() {\n    return lieFlat(this);\n  }\n\n  /**\n   * Project the 3D CSG onto a plane\n   * This returns a 2D CAG with the 'shadow' shape of the 3D solid when projected onto the\n   * plane represented by the orthonormal basis\n   * @param orthobasis\n   */\n  projectToOrthoNormalBasis(orthobasis: OrthoNormalBasis) {\n    // FIXME:  DEPENDS ON CAG !!\n    return projectToOrthoNormalBasis(this, orthobasis);\n  }\n\n  // FIXME: not finding any uses within our code ?\n  /**\n   * Section Cut\n   * @alias sectionCut\n   * @param orthobasis\n   */\n  sectionCut(orthobasis: OrthoNormalBasis) {\n    return sectionCut(this, orthobasis);\n  }\n\n  /**\n   * Returns an array of values for the requested features of this solid.\n   * Supported Features: 'volume', 'area'\n   * @param {string[]} inFeatures - list of features to calculate\n   * @returns {number[]} values\n   * @example\n   * let volume = A.getFeatures('volume')\n   * let values = A.getFeatures('area','volume')\n   */\n  getFeatures(inFeatures: string | string[]) {\n    const features = Array.isArray(inFeatures) ? inFeatures : [inFeatures];\n\n    const result = this.toTriangles()\n      .map((triPoly) => {\n        return triPoly.getTetraFeatures(features);\n      })\n      // @ts-ignore TODO FIX ME\n      .reduce((pv, v) => {\n          return v.map((feat: number, i: number) => {\n            // @ts-ignore TODO FIX ME\n            return feat + (pv === 0 ? 0 : pv[i]);\n          });\n        },\n        0);\n    return (result.length === 1) ? result[0] : result;\n  }\n\n  /**\n   * To Polygons\n   * @return {Polygon[]} The list of polygons.\n   */\n  toPolygons() {\n    return this.polygons;\n  }\n\n  /**\n   * To String helper\n   */\n  toString() {\n    let result = 'CSG solid:\\n';\n    this.polygons.map((p) => {\n      result += p.toString();\n    });\n    return result;\n  }\n\n  /**\n   * Returns a compact binary representation of this csg\n   * usually used to transfer CSG objects to/from webworkes\n   * NOTE: very interesting compact format, with a lot of reusable ideas\n   * @returns {Object} compact binary representation of a CSG\n   */\n  toCompactBinary() {\n    const csg = this.canonicalized();\n    const numpolygons = csg.polygons.length;\n    let numpolygonvertices = 0;\n\n    let numvertices = 0;\n    const vertexmap: {\n      [tag: number]: number;\n    } = {};\n    const vertices: Vertex3[] = [];\n\n    let numplanes = 0;\n    const planemap: {\n      [tag: number]: number;\n    } = {};\n    const planes: Plane[] = [];\n\n    const shareds: PolygonShared[] = [];\n    const sharedmap: {\n      [tag: number]: number;\n    } = {};\n    let numshared = 0;\n    // for (let i = 0, iMax = csg.polygons.length; i < iMax; i++) {\n    //  let p = csg.polygons[i];\n    //  for (let j = 0, jMax = p.length; j < jMax; j++) {\n    //      ++numpolygonvertices;\n    //      let vertextag = p[j].getTag();\n    //      if(!(vertextag in vertexmap)) {\n    //          vertexmap[vertextag] = numvertices++;\n    //          vertices.push(p[j]);\n    //      }\n    //  }\n    csg.polygons.map((polygon) => {\n      // FIXME: why use map if we do not return anything ?\n      // either for... or forEach\n      polygon.vertices.map((vertex) => {\n        ++numpolygonvertices;\n        const vertextag = vertex.getTag();\n        if (!(vertextag in vertexmap)) {\n          vertexmap[vertextag] = numvertices++;\n          vertices.push(vertex);\n        }\n      });\n\n      const planetag = polygon.plane.getTag();\n      if (!(planetag in planemap)) {\n        planemap[planetag] = numplanes++;\n        planes.push(polygon.plane);\n      }\n      const sharedtag = polygon.shared.getTag();\n      if (!(sharedtag in sharedmap)) {\n        sharedmap[sharedtag] = numshared++;\n        shareds.push(polygon.shared);\n      }\n    });\n\n    const numVerticesPerPolygon = new Uint32Array(numpolygons);\n    const polygonSharedIndexes = new Uint32Array(numpolygons);\n    const polygonVertices = new Uint32Array(numpolygonvertices);\n    const polygonPlaneIndexes = new Uint32Array(numpolygons);\n    const vertexData = new Float64Array(numvertices * 3);\n    const planeData = new Float64Array(numplanes * 4);\n    let polygonVerticesIndex = 0;\n\n    // FIXME: doublecheck : why does it go through the whole polygons again?\n    // can we optimise that ? (perhap due to needing size to init buffers above)\n    for (let polygonindex = 0; polygonindex < numpolygons; ++polygonindex) {\n      const polygon = csg.polygons[polygonindex];\n      numVerticesPerPolygon[polygonindex] = polygon.vertices.length;\n      polygon.vertices.map((vertex) => {\n        const vertextag = vertex.getTag();\n        const vertexindex = vertexmap[vertextag];\n        polygonVertices[polygonVerticesIndex++] = vertexindex;\n      });\n      const planetag = polygon.plane.getTag();\n      const planeindex = planemap[planetag];\n      polygonPlaneIndexes[polygonindex] = planeindex;\n      const sharedtag = polygon.shared.getTag();\n      const sharedindex = sharedmap[sharedtag];\n      polygonSharedIndexes[polygonindex] = sharedindex;\n    }\n    let verticesArrayIndex = 0;\n    vertices.map((vertex) => {\n      const pos = vertex.pos;\n      vertexData[verticesArrayIndex++] = pos._x;\n      vertexData[verticesArrayIndex++] = pos._y;\n      vertexData[verticesArrayIndex++] = pos._z;\n    });\n    let planesArrayIndex = 0;\n    planes.map((plane) => {\n      const normal = plane.normal;\n      planeData[planesArrayIndex++] = normal._x;\n      planeData[planesArrayIndex++] = normal._y;\n      planeData[planesArrayIndex++] = normal._z;\n      planeData[planesArrayIndex++] = plane.w;\n    });\n\n    const result = {\n      'class': 'CSG',\n      numPolygons: numpolygons,\n      numVerticesPerPolygon,\n      polygonPlaneIndexes,\n      polygonSharedIndexes,\n      polygonVertices,\n      vertexData,\n      planeData,\n      shared: shareds,\n    };\n    return result;\n  }\n\n  /**\n   * Returns the triangles of this csg\n   * @returns {Polygon3[]} triangulated polygons\n   */\n  toTriangles() {\n    const polygons: Polygon3[] = [];\n    this.polygons.forEach((poly) => {\n      const firstVertex = poly.vertices[0];\n      for (let i = poly.vertices.length - 3; i >= 0; i--) {\n        polygons.push(new Polygon3(\n          [\n            firstVertex,\n            poly.vertices[i + 1],\n            poly.vertices[i + 2],\n          ],\n          poly.shared,\n          poly.plane));\n      }\n    });\n    return polygons;\n  }\n\n// eek ! all this is kept for backwards compatibility...for now\n\n// FIXME: how many are actual useful to be exposed as API ?? looks like a code smell\n  static Vector2D = Vector2;\n  static Vector3D = Vector3;\n  static Vertex = Vertex3;\n  static Plane = Plane;\n  static Polygon = Polygon3;\n  static Polygon2D = Polygon2D;\n  static Line2D = Line2D;\n  static Line3D = Line3D;\n  static Path2D = Path2D;\n  static OrthoNormalBasis = OrthoNormalBasis;\n  static Matrix4x4 = Matrix4x4;\n  static Connector = Connector;\n  static ConnectorList = ConnectorList;\n  static Properties = Properties;\n\n  static _CSGDEBUG = _CSGDEBUG;\n  static defaultResolution2D = defaultResolution2D;\n  static defaultResolution3D = defaultResolution3D;\n  static EPS = EPS;\n  static angleEPS = angleEPS;\n  static areaEPS = areaEPS;\n  static all = all;\n  static top = top;\n  static bottom = bottom;\n  static left = left;\n  static right = right;\n  static front = front;\n  static back = back;\n  static staticTag = staticTag;\n  static getTag = getTag;\n\n  static sphere = sphere;\n  static cube = cube;\n  static roundedCube = roundedCube;\n  static cylinder = cylinder;\n  static roundedCylinder = roundedCylinder;\n  static cylinderElliptic = cylinderElliptic;\n  static polyhedron = polyhedron;\n\n// injecting factories\n  static fromCompactBinary = fromCompactBinary;\n  static fromObject = fromObject;\n  static fromSlices = fromSlices;\n  static fromPolygons = fromPolygons;\n\n  static parseOptionAs2DVector = optionsParsers.parseOptionAs2DVector;\n  static parseOptionAs3DVector = optionsParsers.parseOptionAs3DVector;\n  static parseOptionAs3DVectorList = optionsParsers.parseOptionAs3DVectorList;\n  static parseOptionAsBool = optionsParsers.parseOptionAsBool;\n  static parseOptionAsFloat = optionsParsers.parseOptionAsFloat;\n  static parseOptionAsInt = optionsParsers.parseOptionAsInt;\n}\n","import {parseOption, parseOptionAs2DVector, parseOptionAs3DVector, parseOptionAs3DVectorList, parseOptionAsFloat, parseOptionAsInt} from '@api/optionParsers';\nimport {defaultResolution2D, defaultResolution3D, EPS} from '@core/constants';\nimport {fromPolygons} from '@core/CSGFactories';\n\nimport {Polygon3, Vector3, Vertex3} from '@core/math';\nimport {Connector} from '@core/Connector';\nimport {Properties} from '@core/Properties';\n\n/**\n * Construct an axis-aligned solid cuboid.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.center=[0,0,0]] - center of cube\n * @param {Vector3} [options.radius=[1,1,1]] - radius of cube, single scalar also possible\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cube = CSG.cube({\n *   center: [5, 5, 5],\n *   radius: 5, // scalar radius\n * });\n */\nexport const cube = (options?: any) => {\n  let c: any;\n  let r: any;\n  let corner1;\n  let corner2;\n  options = options || {};\n  if (('corner1' in options) || ('corner2' in options)) {\n    if (('center' in options) || ('radius' in options)) {\n      throw new Error('cube: should either give a radius and center parameter, or a corner1 and corner2 parameter');\n    }\n    corner1 = parseOptionAs3DVector(options, 'corner1', [0, 0, 0]);\n    corner2 = parseOptionAs3DVector(options, 'corner2', [1, 1, 1]);\n    c = corner1.plus(corner2).times(0.5);\n    r = corner2.minus(corner1).times(0.5);\n  } else {\n    c = parseOptionAs3DVector(options, 'center', [0, 0, 0]);\n    r = parseOptionAs3DVector(options, 'radius', [1, 1, 1]);\n  }\n  r = r.abs(); // negative radii make no sense\n  const result = fromPolygons([\n    [\n      [0, 4, 6, 2],\n      [-1, 0, 0],\n    ],\n    [\n      [1, 3, 7, 5],\n      [+1, 0, 0],\n    ],\n    [\n      [0, 1, 5, 4],\n      [0, -1, 0],\n    ],\n    [\n      [2, 6, 7, 3],\n      [0, +1, 0],\n    ],\n    [\n      [0, 2, 3, 1],\n      [0, 0, -1],\n    ],\n    [\n      [4, 5, 7, 6],\n      [0, 0, +1],\n    ],\n  ].map((info) => {\n    const vertices = info[0].map((i) => {\n      const pos = new Vector3(\n        c.x + r.x * (2 * +!!(i & 1) - 1), c.y + r.y * (2 * +!!(i & 2) - 1), c.z + r.z * (2 * +!!(i & 4) - 1));\n      return new Vertex3(pos);\n    });\n    return new Polygon3(vertices, null /* , plane */);\n  }));\n\n  result.properties.cube = new Properties();\n  result.properties.cube.center = new Vector3(c);\n  // add 6 connectors, at the centers of each face:\n  result.properties.cube.facecenters = [\n    new Connector(new Vector3([r.x, 0, 0]).plus(c), [1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([-r.x, 0, 0]).plus(c), [-1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, r.y, 0]).plus(c), [0, 1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, -r.y, 0]).plus(c), [0, -1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, 0, r.z]).plus(c), [0, 0, 1], [1, 0, 0]),\n    new Connector(new Vector3([0, 0, -r.z]).plus(c), [0, 0, -1], [1, 0, 0]),\n  ];\n  return result;\n};\n\n/**\n * Construct a solid sphere\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.center=[0,0,0]] - center of sphere\n * @param {Number} [options.radius=1] - radius of sphere\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @param {Array} [options.axes] -  an array with 3 vectors for the x, y and z base vectors\n * @returns {CSG} new 3D solid\n *\n *\n * @example\n * let sphere = CSG.sphere({\n *   center: [0, 0, 0],\n *   radius: 2,\n *   resolution: 32,\n * });\n */\nexport const sphere = (options?: any) => {\n  options = options || {};\n  const center = parseOptionAs3DVector(options, 'center', [0, 0, 0]);\n  const radius = parseOptionAsFloat(options, 'radius', 1);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n  let xvector;\n  let yvector;\n  let zvector;\n  if ('axes' in options) {\n    xvector = options.axes[0].unit().times(radius);\n    yvector = options.axes[1].unit().times(radius);\n    zvector = options.axes[2].unit().times(radius);\n  } else {\n    xvector = new Vector3([1, 0, 0]).times(radius);\n    yvector = new Vector3([0, -1, 0]).times(radius);\n    zvector = new Vector3([0, 0, 1]).times(radius);\n  }\n  if (resolution < 4) resolution = 4;\n  const qresolution = Math.round(resolution / 4);\n  let prevcylinderpoint;\n  const polygons = [];\n  for (let slice1 = 0; slice1 <= resolution; slice1++) {\n    const angle = Math.PI * 2.0 * slice1 / resolution;\n    const cylinderpoint = xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));\n    if (slice1 > 0) {\n      // cylinder vertices:\n      let vertices = [];\n      let prevcospitch;\n      let prevsinpitch;\n      for (let slice2 = 0; slice2 <= qresolution; slice2++) {\n        const pitch = 0.5 * Math.PI * slice2 / qresolution;\n        const cospitch = Math.cos(pitch);\n        const sinpitch = Math.sin(pitch);\n        if (slice2 > 0) {\n          vertices = [];\n          vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));\n          vertices.push(new Vertex3(center.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));\n          if (slice2 < qresolution) {\n            vertices.push(new Vertex3(center.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));\n          }\n          vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));\n          polygons.push(new Polygon3(vertices));\n          vertices = [];\n          vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));\n          vertices.push(new Vertex3(center.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));\n          if (slice2 < qresolution) {\n            vertices.push(new Vertex3(center.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));\n          }\n          vertices.push(new Vertex3(center.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));\n          vertices.reverse();\n          polygons.push(new Polygon3(vertices));\n        }\n        prevcospitch = cospitch;\n        prevsinpitch = sinpitch;\n      }\n    }\n    prevcylinderpoint = cylinderpoint;\n  }\n  const result = fromPolygons(polygons);\n  result.properties.sphere = new Properties();\n  result.properties.sphere.center = new Vector3(center);\n  result.properties.sphere.facepoint = center.plus(xvector);\n  return result;\n};\n\n/**\n * Construct a solid cylinder.\n * @param {Object} [options] - options for construction\n * @param {Vector} [options.start=[0,-1,0]] - start point of cylinder\n * @param {Vector} [options.end=[0,1,0]] - end point of cylinder\n * @param {Number} [options.radius=1] - radius of cylinder, must be scalar\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cylinder = CSG.cylinder({\n *   start: [0, -10, 0],\n *   end: [0, 10, 0],\n *   radius: 10,\n *   resolution: 16\n * });\n */\nexport const cylinder = (options?: any) => {\n  const s = parseOptionAs3DVector(options, 'start', [0, -1, 0]);\n  const e = parseOptionAs3DVector(options, 'end', [0, 1, 0]);\n  const r = parseOptionAsFloat(options, 'radius', 1);\n  const rEnd = parseOptionAsFloat(options, 'radiusEnd', r);\n  const rStart = parseOptionAsFloat(options, 'radiusStart', r);\n  let alpha = parseOptionAsFloat(options, 'sectorAngle', 360);\n  alpha = alpha > 360 ? alpha % 360 : alpha;\n\n  if ((rEnd < 0) || (rStart < 0)) {\n    throw new Error('Radius should be non-negative');\n  }\n  if ((rEnd === 0) && (rStart === 0)) {\n    throw new Error('Either radiusStart or radiusEnd should be positive');\n  }\n\n  const slices = parseOptionAsInt(options, 'resolution', defaultResolution2D); // FIXME is this 3D?\n  const ray = e.minus(s);\n  const axisZ = ray.unit(); // , isY = (Math.abs(axisZ.y) > 0.5);\n  const axisX = axisZ.randomNonParallelVector().unit();\n\n  //  let axisX = new Vector3(isY, !isY, 0).cross(axisZ).unit();\n  const axisY = axisX.cross(axisZ).unit();\n  const start = new Vertex3(s);\n  const end = new Vertex3(e);\n  const polygons = [];\n\n  function point(stack: number, slice: number, radius: number) {\n    const angle = slice * Math.PI * alpha / 180;\n    const out = axisX.times(Math.cos(angle)).plus(axisY.times(Math.sin(angle)));\n    const pos = s.plus(ray.times(stack)).plus(out.times(radius));\n    return new Vertex3(pos);\n  }\n\n  if (alpha > 0) {\n    for (let i = 0; i < slices; i++) {\n      const t0 = i / slices;\n      const t1 = (i + 1) / slices;\n      if (rEnd === rStart) {\n        polygons.push(new Polygon3([start, point(0, t0, rEnd), point(0, t1, rEnd)]));\n        polygons.push(new Polygon3([point(0, t1, rEnd), point(0, t0, rEnd), point(1, t0, rEnd), point(1, t1, rEnd)]));\n        polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));\n      } else {\n        if (rStart > 0) {\n          polygons.push(new Polygon3([start, point(0, t0, rStart), point(0, t1, rStart)]));\n          polygons.push(new Polygon3([point(0, t0, rStart), point(1, t0, rEnd), point(0, t1, rStart)]));\n        }\n        if (rEnd > 0) {\n          polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));\n          polygons.push(new Polygon3([point(1, t0, rEnd), point(1, t1, rEnd), point(0, t1, rStart)]));\n        }\n      }\n    }\n    if (alpha < 360) {\n      polygons.push(new Polygon3([start, end, point(0, 0, rStart)]));\n      polygons.push(new Polygon3([point(0, 0, rStart), end, point(1, 0, rEnd)]));\n      polygons.push(new Polygon3([start, point(0, 1, rStart), end]));\n      polygons.push(new Polygon3([point(0, 1, rStart), point(1, 1, rEnd), end]));\n    }\n  }\n  const result = fromPolygons(polygons);\n  result.properties.cylinder = new Properties();\n  result.properties.cylinder.start = new Connector(s, axisZ.negated(), axisX);\n  result.properties.cylinder.end = new Connector(e, axisZ, axisX);\n  const cylCenter = s.plus(ray.times(0.5));\n  const fptVec = axisX.rotate(s, axisZ, -alpha / 2).times((rStart + rEnd) / 2);\n  const fptVec90 = fptVec.cross(axisZ);\n  // note this one is NOT a face normal for a cone. - It's horizontal from cyl perspective\n  result.properties.cylinder.facepointH = new Connector(cylCenter.plus(fptVec), fptVec, axisZ);\n  result.properties.cylinder.facepointH90 = new Connector(cylCenter.plus(fptVec90), fptVec90, axisZ);\n  return result;\n};\n\n/**\n * Construct a cylinder with rounded ends.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.start=[0,-1,0]] - start point of cylinder\n * @param {Vector3} [options.end=[0,1,0]] - end point of cylinder\n * @param {Number} [options.radius=1] - radius of rounded ends, must be scalar\n * @param {Vector3} [options.normal] - vector determining the starting angle for tesselation. Should be non-parallel to start.minus(end)\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cylinder = CSG.roundedCylinder({\n *   start: [0, -10, 0],\n *   end: [0, 10, 0],\n *   radius: 2,\n *   resolution: 16\n * });\n */\nexport const roundedCylinder = (options?: any) => {\n  const p1 = parseOptionAs3DVector(options, 'start', [0, -1, 0]);\n  const p2 = parseOptionAs3DVector(options, 'end', [0, 1, 0]);\n  const radius = parseOptionAsFloat(options, 'radius', 1);\n  const direction = p2.minus(p1);\n  let defaultnormal;\n  if (Math.abs(direction.x) > Math.abs(direction.y)) {\n    defaultnormal = new Vector3(0, 1, 0);\n  } else {\n    defaultnormal = new Vector3(1, 0, 0);\n  }\n  const normal = parseOptionAs3DVector(options, 'normal', defaultnormal);\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n  if (resolution < 4) resolution = 4;\n  const polygons = [];\n  const qresolution = Math.floor(0.25 * resolution);\n  const length = direction.length();\n  if (length < EPS) {\n    return sphere({\n      center: p1,\n      radius,\n      resolution,\n    });\n  }\n  const zvector = direction.unit().times(radius);\n  const xvector = zvector.cross(normal).unit().times(radius);\n  const yvector = xvector.cross(zvector).unit().times(radius);\n  let prevcylinderpoint;\n  for (let slice1 = 0; slice1 <= resolution; slice1++) {\n    const angle = Math.PI * 2.0 * slice1 / resolution;\n    const cylinderpoint = xvector.times(Math.cos(angle)).plus(yvector.times(Math.sin(angle)));\n    if (slice1 > 0) {\n      // cylinder vertices:\n      let vertices = [];\n      vertices.push(new Vertex3(p1.plus(cylinderpoint)));\n      vertices.push(new Vertex3(p1.plus(prevcylinderpoint)));\n      vertices.push(new Vertex3(p2.plus(prevcylinderpoint)));\n      vertices.push(new Vertex3(p2.plus(cylinderpoint)));\n      polygons.push(new Polygon3(vertices));\n      let prevcospitch;\n      let prevsinpitch;\n      for (let slice2 = 0; slice2 <= qresolution; slice2++) {\n        const pitch = 0.5 * Math.PI * slice2 / qresolution;\n        // let pitch = Math.asin(slice2/qresolution);\n        const cospitch = Math.cos(pitch);\n        const sinpitch = Math.sin(pitch);\n        if (slice2 > 0) {\n          vertices = [];\n          vertices.push(new Vertex3(p1.plus(prevcylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));\n          vertices.push(new Vertex3(p1.plus(cylinderpoint.times(prevcospitch).minus(zvector.times(prevsinpitch)))));\n          if (slice2 < qresolution) {\n            vertices.push(new Vertex3(p1.plus(cylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));\n          }\n          vertices.push(new Vertex3(p1.plus(prevcylinderpoint.times(cospitch).minus(zvector.times(sinpitch)))));\n          polygons.push(new Polygon3(vertices));\n          vertices = [];\n          vertices.push(new Vertex3(p2.plus(prevcylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));\n          vertices.push(new Vertex3(p2.plus(cylinderpoint.times(prevcospitch).plus(zvector.times(prevsinpitch)))));\n          if (slice2 < qresolution) {\n            vertices.push(new Vertex3(p2.plus(cylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));\n          }\n          vertices.push(new Vertex3(p2.plus(prevcylinderpoint.times(cospitch).plus(zvector.times(sinpitch)))));\n          vertices.reverse();\n          polygons.push(new Polygon3(vertices));\n        }\n        prevcospitch = cospitch;\n        prevsinpitch = sinpitch;\n      }\n    }\n    prevcylinderpoint = cylinderpoint;\n  }\n  const result = fromPolygons(polygons);\n  const ray = zvector.unit();\n  const axisX = xvector.unit();\n  result.properties.roundedCylinder = new Properties();\n  result.properties.roundedCylinder.start = new Connector(p1, ray.negated(), axisX);\n  result.properties.roundedCylinder.end = new Connector(p2, ray, axisX);\n  result.properties.roundedCylinder.facepoint = p1.plus(xvector);\n  return result;\n};\n\n/**\n * Construct an elliptic cylinder.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.start=[0,-1,0]] - start point of cylinder\n * @param {Vector3} [options.end=[0,1,0]] - end point of cylinder\n * @param {Vector2D} [options.radius=[1,1]] - radius of rounded ends, must be two dimensional array\n * @param {Vector2D} [options.radiusStart=[1,1]] - OPTIONAL radius of rounded start, must be two dimensional array\n * @param {Vector2D} [options.radiusEnd=[1,1]] - OPTIONAL radius of rounded end, must be two dimensional array\n * @param {Number} [options.resolution=defaultResolution2D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n *     let cylinder = CSG.cylinderElliptic({\n *       start: [0, -10, 0],\n *       end: [0, 10, 0],\n *       radiusStart: [10,5],\n *       radiusEnd: [8,3],\n *       resolution: 16\n *     });\n */\n\nexport const cylinderElliptic = (options?: any) => {\n  const s = parseOptionAs3DVector(options, 'start', [0, -1, 0]);\n  const e = parseOptionAs3DVector(options, 'end', [0, 1, 0]);\n  const r = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  const rEnd = parseOptionAs2DVector(options, 'radiusEnd', r);\n  const rStart = parseOptionAs2DVector(options, 'radiusStart', r);\n\n  if ((rEnd._x < 0) || (rStart._x < 0) || (rEnd._y < 0) || (rStart._y < 0)) {\n    throw new Error('Radius should be non-negative');\n  }\n  if ((rEnd._x === 0 || rEnd._y === 0) && (rStart._x === 0 || rStart._y === 0)) {\n    throw new Error('Either radiusStart or radiusEnd should be positive');\n  }\n\n  const slices = parseOptionAsInt(options, 'resolution', defaultResolution2D); // FIXME is this correct?\n  const ray = e.minus(s);\n  const axisZ = ray.unit(); // , isY = (Math.abs(axisZ.y) > 0.5);\n  const axisX = axisZ.randomNonParallelVector().unit();\n\n  //  let axisX = new Vector3(isY, !isY, 0).cross(axisZ).unit();\n  const axisY = axisX.cross(axisZ).unit();\n  const start = new Vertex3(s);\n  const end = new Vertex3(e);\n  const polygons = [];\n\n  function point(stack: number, slice: number, radius: any) {\n    const angle = slice * Math.PI * 2;\n    const out = axisX.times(radius._x * Math.cos(angle)).plus(axisY.times(radius._y * Math.sin(angle)));\n    const pos = s.plus(ray.times(stack)).plus(out);\n    return new Vertex3(pos);\n  }\n\n  for (let i = 0; i < slices; i++) {\n    const t0 = i / slices;\n    const t1 = (i + 1) / slices;\n\n    if (rEnd._x === rStart._x && rEnd._y === rStart._y) {\n      polygons.push(new Polygon3([start, point(0, t0, rEnd), point(0, t1, rEnd)]));\n      polygons.push(new Polygon3([point(0, t1, rEnd), point(0, t0, rEnd), point(1, t0, rEnd), point(1, t1, rEnd)]));\n      polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));\n    } else {\n      if (rStart._x > 0) {\n        polygons.push(new Polygon3([start, point(0, t0, rStart), point(0, t1, rStart)]));\n        polygons.push(new Polygon3([point(0, t0, rStart), point(1, t0, rEnd), point(0, t1, rStart)]));\n      }\n      if (rEnd._x > 0) {\n        polygons.push(new Polygon3([end, point(1, t1, rEnd), point(1, t0, rEnd)]));\n        polygons.push(new Polygon3([point(1, t0, rEnd), point(1, t1, rEnd), point(0, t1, rStart)]));\n      }\n    }\n  }\n  const result = fromPolygons(polygons);\n  result.properties.cylinder = new Properties();\n  result.properties.cylinder.start = new Connector(s, axisZ.negated(), axisX);\n  result.properties.cylinder.end = new Connector(e, axisZ, axisX);\n  result.properties.cylinder.facepoint = s.plus(axisX.times(rStart));\n  return result;\n};\n\n/**\n * Construct an axis-aligned solid rounded cuboid.\n * @param {Object} [options] - options for construction\n * @param {Vector3} [options.center=[0,0,0]] - center of rounded cube\n * @param {Vector3} [options.radius=[1,1,1]] - radius of rounded cube, single scalar is possible\n * @param {Number} [options.roundradius=0.2] - radius of rounded edges\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n *\n * @example\n * let cube = CSG.roundedCube({\n *   center: [2, 0, 2],\n *   radius: 15,\n *   roundradius: 2,\n *   resolution: 36,\n * });\n */\nexport const roundedCube = (options?: any) => {\n  const minRR = 1e-2; // minroundradius 1e-3 gives rounding errors already\n  let center;\n  let cuberadius;\n  let corner1;\n  let corner2;\n  options = options || {};\n  if (('corner1' in options) || ('corner2' in options)) {\n    if (('center' in options) || ('radius' in options)) {\n      throw new Error('roundedCube: should either give a radius and center parameter, or a corner1 and corner2 parameter');\n    }\n    corner1 = parseOptionAs3DVector(options, 'corner1', [0, 0, 0]);\n    corner2 = parseOptionAs3DVector(options, 'corner2', [1, 1, 1]);\n    center = corner1.plus(corner2).times(0.5);\n    cuberadius = corner2.minus(corner1).times(0.5);\n  } else {\n    center = parseOptionAs3DVector(options, 'center', [0, 0, 0]);\n    cuberadius = parseOptionAs3DVector(options, 'radius', [1, 1, 1]);\n  }\n  cuberadius = cuberadius.abs(); // negative radii make no sense\n  let resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n  if (resolution < 4) resolution = 4;\n  if (resolution % 2 === 1 && resolution < 8) resolution = 8; // avoid ugly\n  let roundradius = parseOptionAs3DVector(options, 'roundradius', [0.2, 0.2, 0.2]);\n  // slight hack for now - total radius stays ok\n  roundradius = Vector3.Create(Math.max(roundradius.x, minRR), Math.max(roundradius.y, minRR), Math.max(roundradius.z, minRR));\n  const innerradius = cuberadius.minus(roundradius);\n  if (innerradius.x < 0 || innerradius.y < 0 || innerradius.z < 0) {\n    throw new Error('roundradius <= radius!');\n  }\n  let res = sphere({radius: 1, resolution});\n  res = res.scale(roundradius);\n  innerradius.x > EPS && (res = res.stretchAtPlane([1, 0, 0], [0, 0, 0], 2 * innerradius.x));\n  innerradius.y > EPS && (res = res.stretchAtPlane([0, 1, 0], [0, 0, 0], 2 * innerradius.y));\n  innerradius.z > EPS && (res = res.stretchAtPlane([0, 0, 1], [0, 0, 0], 2 * innerradius.z));\n  res = res.translate([-innerradius.x + center.x, -innerradius.y + center.y, -innerradius.z + center.z]);\n  res = res.reTesselated();\n  res.properties.roundedCube = new Properties();\n  res.properties.roundedCube.center = new Vertex3(center);\n  res.properties.roundedCube.facecenters = [\n    new Connector(new Vector3([cuberadius.x, 0, 0]).plus(center), [1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([-cuberadius.x, 0, 0]).plus(center), [-1, 0, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, cuberadius.y, 0]).plus(center), [0, 1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, -cuberadius.y, 0]).plus(center), [0, -1, 0], [0, 0, 1]),\n    new Connector(new Vector3([0, 0, cuberadius.z]).plus(center), [0, 0, 1], [1, 0, 0]),\n    new Connector(new Vector3([0, 0, -cuberadius.z]).plus(center), [0, 0, -1], [1, 0, 0]),\n  ];\n  return res;\n};\n\n/**\n * Create a polyhedron using Openscad style arguments.\n * Define face vertices clockwise looking from outside.\n * @param {Object} [options] - options for construction\n * @returns {CSG} new 3D solid\n */\nexport const polyhedron = (options: any) => {\n  options = options || {};\n  if (('points' in options) !== ('faces' in options)) {\n    throw new Error('polyhedron needs \\'points\\' and \\'faces\\' arrays');\n  }\n  const vertices = parseOptionAs3DVectorList(options, 'points', [\n    [1, 1, 0],\n    [1, -1, 0],\n    [-1, -1, 0],\n    [-1, 1, 0],\n    [0, 0, 1],\n  ])\n    .map((pt: any) => {\n      return new Vertex3(pt);\n    });\n  const faces = parseOption(options, 'faces', [\n    [0, 1, 4],\n    [1, 2, 4],\n    [2, 3, 4],\n    [3, 0, 4],\n    [1, 0, 3],\n    [2, 1, 3],\n  ]);\n  // Openscad convention defines inward normals - so we have to invert here\n  faces.forEach((face: any) => {\n    face.reverse();\n  });\n  const polygons = faces.map((face: any) => {\n    return new Polygon3(face.map((idx: any) => {\n      return vertices[idx];\n    }));\n  });\n\n  // TODO: facecenters as connectors? probably overkill. Maybe centroid\n  // the re-tesselation here happens because it's so easy for a user to\n  // create parametrized polyhedrons that end up with 1-2 dimensional polygons.\n  // These will create infinite loops at CSG.Tree()\n  return fromPolygons(polygons).reTesselated();\n};\n","/**\n * solve2Linear\n * @param a\n * @param b\n * @param c\n * @param d\n * @param u\n * @param v\n */\nexport const solve2Linear = (a: number, b: number, c: number, d: number, u: number, v: number): [number, number] => {\n  const det = a * d - b * c;\n  const invdet = 1.0 / det;\n  let x = u * d - b * v;\n  let y = -u * c + a * v;\n  x *= invdet;\n  y *= invdet;\n  return [x, y];\n};\n","// boolean operations\n\n// FIXME should this be lazy ? in which case, how do we deal with 2D/3D combined\n// TODO we should have an option to set behaviour as first parameter\n\nexport * from './union';\nexport * from './difference';\nexport * from './intersection';\n","/**\n * Number sort\n * @param a\n * @param b\n */\nexport function fnNumberSort(a: number, b: number) {\n  return a - b;\n}\n\n/**\n * Sort objects by index\n * @param a\n * @param b\n */\nexport function fnSortByIndex<T extends { index: number }>(a: T, b: T) {\n  return a.index - b.index;\n}\n","import {EPS} from '@core/constants';\nimport {Polygon3, Vertex3} from '@core/math';\nimport {CSG} from '@core/CSG';\nimport {fromPolygons} from '@core/CSGFactories';\nimport {sphere as CSGsphere} from '@primitives/csg/primitives3d';\nimport {fnNumberSort} from '@core/utils/sortHelpers';\n\n/**\n * Create the expanded shell of the solid:\n * All faces are extruded to get a thickness of 2*radius\n * Cylinders are constructed around every side\n * Spheres are placed on every vertex\n * unionWithThis: if true, the resulting solid will be united with 'this' solid;\n * the result is a true expansion of the solid\n * If false, returns only the shell\n * @param  {Float} radius\n * @param  {Integer} resolution\n * @param  {Boolean} unionWithThis\n */\nexport const expandedShellOfCCSG = (_csg: CSG, radius: number, resolution: number, unionWithThis?: boolean) => {\n  const csg = _csg.reTesselated();\n  let result: any;\n  if (unionWithThis) {\n    result = csg;\n  } else {\n    result = new CSG();\n  }\n\n  // first extrude all polygons:\n  csg.polygons.map((polygon: any) => {\n    const extrudevector = polygon.plane.normal.unit().times(2 * radius);\n    const translatedpolygon = polygon.translate(extrudevector.times(-0.5));\n    const extrudedface = translatedpolygon.extrude(extrudevector);\n    result = result.unionSub(extrudedface, false, false);\n  });\n\n  // Make a list of all unique vertex pairs (i.e. all sides of the solid)\n  // For each vertex pair we collect the following:\n  //   v1: first coordinate\n  //   v2: second coordinate\n  //   planenormals: array of normal vectors of all planes touching this side\n  const vertexpairs: any = {}; // map of 'vertex pair tag' to {v1, v2, planenormals}\n  csg.polygons.map((polygon: any) => {\n    const numvertices = polygon.vertices.length;\n    let prevvertex = polygon.vertices[numvertices - 1];\n    let prevvertextag = prevvertex.getTag();\n    for (let i = 0; i < numvertices; i++) {\n      const vertex = polygon.vertices[i];\n      const vertextag = vertex.getTag();\n      let vertextagpair;\n      if (vertextag < prevvertextag) {\n        vertextagpair = vertextag + '-' + prevvertextag;\n      } else {\n        vertextagpair = prevvertextag + '-' + vertextag;\n      }\n      let obj;\n      if (vertextagpair in vertexpairs) {\n        obj = vertexpairs[vertextagpair];\n      } else {\n        obj = {\n          v1: prevvertex,\n          v2: vertex,\n          planenormals: [],\n        };\n        vertexpairs[vertextagpair] = obj;\n      }\n      obj.planenormals.push(polygon.plane.normal);\n\n      prevvertextag = vertextag;\n      prevvertex = vertex;\n    }\n  });\n\n  // now construct a cylinder on every side\n  // The cylinder is always an approximation of a true cylinder: it will have <resolution> polygons\n  // around the sides. We will make sure though that the cylinder will have an edge at every\n  // face that touches this side. This ensures that we will get a smooth fill even\n  // if two edges are at, say, 10 degrees and the resolution is low.\n  // Note: the result is not retesselated yet but it really should be!\n\n  // tslint:disable-next-line:forin\n  for (const vertextagpair in vertexpairs) {\n    const vertexpair = vertexpairs[vertextagpair];\n    const startpoint = vertexpair.v1.pos;\n    const endpoint = vertexpair.v2.pos;\n    // our x,y and z vectors:\n    const zbase = endpoint.minus(startpoint).unit();\n    const xbase = vertexpair.planenormals[0].unit();\n    const ybase = xbase.cross(zbase);\n\n    // make a list of angles that the cylinder should traverse:\n    let angles = [];\n\n    // first of all equally spaced around the cylinder:\n    for (let i = 0; i < resolution; i++) {\n      angles.push(i * Math.PI * 2 / resolution);\n    }\n\n    // and also at every normal of all touching planes:\n    for (let i = 0, iMax = vertexpair.planenormals.length; i < iMax; i++) {\n      const planenormal = vertexpair.planenormals[i];\n      const si = ybase.dot(planenormal);\n      const co = xbase.dot(planenormal);\n      let angle = Math.atan2(si, co);\n\n      if (angle < 0) angle += Math.PI * 2;\n      angles.push(angle);\n      angle = Math.atan2(-si, -co);\n      if (angle < 0) angle += Math.PI * 2;\n      angles.push(angle);\n    }\n\n    // this will result in some duplicate angles but we will get rid of those later.\n    // Sort:\n    angles = angles.sort(fnNumberSort);\n\n    // Now construct the cylinder by traversing all angles:\n    const numangles = angles.length;\n    let prevp1;\n    let prevp2;\n    const startfacevertices = [];\n    const endfacevertices = [];\n    const polygons = [];\n    for (let i = -1; i < numangles; i++) {\n      const angle = angles[(i < 0) ? (i + numangles) : i];\n      const si = Math.sin(angle);\n      const co = Math.cos(angle);\n      const p = xbase.times(co * radius).plus(ybase.times(si * radius));\n      const p1 = startpoint.plus(p);\n      const p2 = endpoint.plus(p);\n      let skip = false;\n      if (i >= 0) {\n        if (p1.distanceTo(prevp1) < EPS) {\n          skip = true;\n        }\n      }\n      if (!skip) {\n        if (i >= 0) {\n          startfacevertices.push(new Vertex3(p1));\n          endfacevertices.push(new Vertex3(p2));\n          const polygonvertices = [\n            new Vertex3(prevp2),\n            new Vertex3(p2),\n            new Vertex3(p1),\n            new Vertex3(prevp1),\n          ];\n          const polygon = new Polygon3(polygonvertices);\n          polygons.push(polygon);\n        }\n        prevp1 = p1;\n        prevp2 = p2;\n      }\n    }\n    endfacevertices.reverse();\n    polygons.push(new Polygon3(startfacevertices));\n    polygons.push(new Polygon3(endfacevertices));\n    const cylinder = fromPolygons(polygons);\n    result = result.unionSub(cylinder, false, false);\n  }\n\n  // make a list of all unique vertices\n  // For each vertex we also collect the list of normals of the planes touching the vertices\n  const vertexmap: any = {};\n  csg.polygons.map((polygon: any) => {\n    polygon.vertices.map((vertex: any) => {\n      const vertextag = vertex.getTag();\n      let obj;\n      if (vertextag in vertexmap) {\n        obj = vertexmap[vertextag];\n      } else {\n        obj = {\n          pos: vertex.pos,\n          normals: [],\n        };\n        vertexmap[vertextag] = obj;\n      }\n      obj.normals.push(polygon.plane.normal);\n    });\n  });\n\n  // and build spheres at each vertex\n  // We will try to set the x and z axis to the normals of 2 planes\n  // This will ensure that our sphere tesselation somewhat matches 2 planes\n\n  // tslint:disable-next-line:forin\n  for (const vertextag in vertexmap) {\n    const vertexobj = vertexmap[vertextag];\n    // use the first normal to be the x axis of our sphere:\n    const xaxis = vertexobj.normals[0].unit();\n    // and find a suitable z axis. We will use the normal which is most perpendicular to the x axis:\n    let bestzaxis = null;\n    let bestzaxisorthogonality = 0;\n    for (let i = 1; i < vertexobj.normals.length; i++) {\n      const normal = vertexobj.normals[i].unit();\n      const cross = xaxis.cross(normal);\n      const crosslength = cross.length();\n      if (crosslength > 0.05) {\n        if (crosslength > bestzaxisorthogonality) {\n          bestzaxisorthogonality = crosslength;\n          bestzaxis = normal;\n        }\n      }\n    }\n    if (!bestzaxis) {\n      bestzaxis = xaxis.randomNonParallelVector();\n    }\n    const yaxis = xaxis.cross(bestzaxis).unit();\n    const zaxis = yaxis.cross(xaxis);\n    const _sphere = CSGsphere({\n      center: vertexobj.pos,\n      radius,\n      resolution,\n      axes: [xaxis, yaxis, zaxis],\n    });\n    result = result.unionSub(_sphere, false, false);\n  }\n\n  return result;\n};\n","import {angleEPS, EPS} from '@core/constants';\nimport {Vector2} from '@core/math';\nimport {fromPoints, fromPointsNoCheck} from '@core/CAGFactories';\nimport {CAG} from '@core/CAG';\n\n/**\n * Expanded Shell Of CAG\n * @param _cag\n * @param radius\n * @param resolution\n */\nexport const expandedShellOfCAG = (_cag: CAG, radius: number, resolution: number) => {\n  resolution = resolution || 8;\n  if (resolution < 4) resolution = 4;\n  const cags = [];\n  const pointmap: any = {};\n  const cag = _cag.canonicalized();\n  cag.sides.map((side: any) => {\n    let d = side.vertex1.pos.minus(side.vertex0.pos);\n    const dl = d.length();\n    if (dl > EPS) {\n      d = d.times(1.0 / dl);\n      const normal = d.normal().times(radius);\n      const shellpoints = [\n        side.vertex1.pos.plus(normal),\n        side.vertex1.pos.minus(normal),\n        side.vertex0.pos.minus(normal),\n        side.vertex0.pos.plus(normal),\n      ];\n      //      let newcag = fromPointsNoCheck(shellpoints);\n      const newcag = fromPoints(shellpoints);\n      cags.push(newcag);\n      for (let step = 0; step < 2; step++) {\n        const p1 = (step === 0) ? side.vertex0.pos : side.vertex1.pos;\n        const p2 = (step === 0) ? side.vertex1.pos : side.vertex0.pos;\n        const tag = p1.x + ' ' + p1.y;\n        if (!(tag in pointmap)) {\n          pointmap[tag] = [];\n        }\n        pointmap[tag].push({\n          'p1': p1,\n          'p2': p2,\n        });\n      }\n    }\n  });\n\n  // tslint:disable-next-line:forin\n  for (const tag in pointmap) {\n    const m = pointmap[tag];\n\n    let angle1;\n    let angle2;\n\n    const pcenter = m[0].p1;\n    if (m.length === 2) {\n      const end1 = m[0].p2;\n      const end2 = m[1].p2;\n      angle1 = end1.minus(pcenter).angleDegrees();\n      angle2 = end2.minus(pcenter).angleDegrees();\n      if (angle2 < angle1) angle2 += 360;\n      if (angle2 >= (angle1 + 360)) angle2 -= 360;\n      if (angle2 < angle1 + 180) {\n        const t = angle2;\n        angle2 = angle1 + 360;\n        angle1 = t;\n      }\n      angle1 += 90;\n      angle2 -= 90;\n    } else {\n      angle1 = 0;\n      angle2 = 360;\n    }\n    const fullcircle = (angle2 > angle1 + 359.999);\n    if (fullcircle) {\n      angle1 = 0;\n      angle2 = 360;\n    }\n    if (angle2 > (angle1 + angleEPS)) {\n      const points = [];\n      if (!fullcircle) {\n        points.push(pcenter);\n      }\n      let numsteps = Math.round(resolution * (angle2 - angle1) / 360);\n      if (numsteps < 1) numsteps = 1;\n      for (let step = 0; step <= numsteps; step++) {\n        let angle = angle1 + step / numsteps * (angle2 - angle1);\n        if (step === numsteps) angle = angle2; // prevent rounding errors\n        const point = pcenter.plus(Vector2.fromAngleDegrees(angle).times(radius));\n        if ((!fullcircle) || (step > 0)) {\n          points.push(point);\n        }\n      }\n      const newcag = fromPointsNoCheck(points);\n      cags.push(newcag);\n    }\n  }\n  let result = new CAG();\n  result = result.union(cags);\n  return result;\n};\n","/**\n * Is CSG object\n * @param object\n */\nexport function isCSG(object: any) {\n  // objects[i] instanceof CSG => NOT RELIABLE\n  // 'instanceof' causes huge issues when using objects from\n  // two different versions of CSG.js as they are not reckonized as one and the same\n  // so DO NOT use instanceof to detect matching types for CSG/CAG\n  if (!('polygons' in object)) {\n    return false;\n  }\n\n  if (!('length' in object.polygons)) {\n    return false;\n  }\n\n  return true;\n}\n","export * from './extrudeInOrthonormalBasis';\nexport * from './extrudeInPlane';\nexport * from './extrude';\nexport * from './rotateExtrude';\nexport * from './linear_extrude';\nexport * from './rotate_extrude';\nexport * from './rectangular_extrude';\n","import {vectorParams} from './vectorParams';\nimport {IVectorTextOptions} from '@root/text/types/VectorTextTypes';\n\n/**\n * Represents a character as segments\n * @typedef {Object} VectorCharObject\n * @property {number} width - character width\n * @property {number} height - character height (uppercase)\n * @property {Array} segments - character segments [[[x, y], ...], ...]\n */\n\n/**\n * Construct a {@link VectorCharObject} from a ascii character whose code is between 31 and 127,\n * if the character is not supported it is replaced by a question mark.\n * @param {Object|String} [options] - options for construction or ascii character\n * @param {Float} [options.xOffset=0] - x offset\n * @param {Float} [options.yOffset=0] - y offset\n * @param {Float} [options.height=21] - font size (uppercase height)\n * @param {Float} [options.extrudeOffset=0] - width of the extrusion that will be applied (manually) after the creation of the character\n * @param {String} [options.input='?'] - ascii character (ignored/overwrited if provided as seconds parameter)\n * @param {String} [char='?'] - ascii character\n * @returns {VectorCharObject}\n *\n * @example\n * let vectorCharObject = vectorChar()\n * or\n * let vectorCharObject = vectorChar('A')\n * or\n * let vectorCharObject = vectorChar({ xOffset: 57 }, 'C')\n * or\n * let vectorCharObject = vectorChar({ xOffset: 78, input: '!' })\n */\nexport function vectorChar(options?: Partial<IVectorTextOptions> | string, char: string = '?') {\n  const {\n    xOffset, yOffset, input, font, height, extrudeOffset,\n  } = vectorParams(options, char);\n\n  let code = input.charCodeAt(0);\n  if (!code || !font[code]) {\n    code = 63; // 63 => ?\n  }\n\n  const glyph = [...font[code]];\n  const ratio = (height - extrudeOffset) / font.height;\n  const extrudeYOffset = (extrudeOffset / 2);\n  const width = glyph.shift() * ratio;\n  const segments = [];\n  let polyline = [];\n  for (let i = 0, il = glyph.length; i < il; i += 2) {\n    const gx = ratio * glyph[i] + xOffset;\n    const gy = ratio * glyph[i + 1] + yOffset + extrudeYOffset;\n    if (glyph[i] !== undefined) {\n      polyline.push([gx, gy]);\n      continue;\n    }\n    segments.push(polyline);\n    polyline = [];\n    i--;\n  }\n  if (polyline.length) {\n    segments.push(polyline);\n  }\n  return {width, height, segments};\n}\n","import {hersheyFont as defaultFont} from './fonts/single-line/hershey/simplex';\nimport {IVectorTextOptions, TEXT_ALIGN} from '@root/text/types/VectorTextTypes';\n\nexport const defaultsVectorParams: IVectorTextOptions = {\n  xOffset: 0,\n  yOffset: 0,\n  input: '?',\n  align: TEXT_ALIGN.LEFT,\n  font: defaultFont,\n  height: 14, // == old vector_xxx simplex font height\n  lineSpacing: 2.142857142857143, // == 30/14 == old vector_xxx ratio\n  letterSpacing: 1,\n  extrudeOffset: 0,\n};\n\n// vectorsXXX parameters handler\nexport const vectorParams = (options?: Partial<IVectorTextOptions> | string, input: string = '?') => ({\n  ...defaultsVectorParams,\n  ...({input}),\n  ...(typeof options === 'string' ? {input: options} : options),\n});\n\n","// Primitives 2D\nexport * from './square';\nexport * from './circle';\nexport * from './polygon';\nexport * from './triangle';\n\n// Primitives 3D\nexport * from './cube';\nexport * from './sphere';\nexport * from './geodesicSphere';\nexport * from './cylinder';\nexport * from './torus';\nexport * from './polyhedron';\n","import {areaEPS} from '@core/constants';\nimport {Vector2} from '@core/math';\nimport {CAG} from '@core/CAG';\nimport {linesIntersect} from '@core/utils/linesIntersect';\n\n/**\n * Check if we are a valid CAG (for debugging)\n * NOTE(bebbi) uneven side count doesn't work because rounding with EPS isn't taken into account\n * @param cag\n */\nexport const isCAGValid = (cag: CAG) => {\n  const errors = [];\n  if (cag.isSelfIntersecting(true)) {\n    errors.push('Self intersects');\n  }\n\n  const pointcount: { [tagName: string]: number } = {};\n\n  const mappoint = (p: Vector2) => {\n    const tag = p.x + ' ' + p.y;\n    if (!(tag in pointcount)) {\n      pointcount[tag] = 0;\n    }\n    pointcount[tag]++;\n  };\n\n  cag.sides.map((side) => {\n    mappoint(side.vertex0.pos);\n    mappoint(side.vertex1.pos);\n  });\n\n  // tslint:disable-next-line:forin\n  for (const tag in pointcount) {\n    const count = pointcount[tag];\n    if (count & 1) {\n      errors.push('Uneven number of sides (' + count + ') for point ' + tag);\n    }\n  }\n\n  const area = cag.area();\n  if (area < areaEPS) {\n    errors.push('Area is ' + area);\n  }\n\n  if (errors.length > 0) {\n    let ertxt = '';\n    errors.map((err) => {\n      ertxt += err + '\\n';\n    });\n    throw new Error(ertxt);\n  }\n};\n\n/**\n * Is Self Intersecting\n * @param cag\n * @param debug\n */\nexport const isSelfIntersecting = (cag: CAG, debug?: boolean) => {\n  const numsides = cag.sides.length;\n  for (let i = 0; i < numsides; i++) {\n    const side0 = cag.sides[i];\n    for (let ii = i + 1; ii < numsides; ii++) {\n      const side1 = cag.sides[ii];\n      if (linesIntersect(side0.vertex0.pos, side0.vertex1.pos, side1.vertex0.pos, side1.vertex1.pos)) {\n        if (debug) {\n          // tslint:disable-next-line:no-console\n          console.log('side ' + i + ': ' + side0);\n          // tslint:disable-next-line:no-console\n          console.log('side ' + ii + ': ' + side1);\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Check if the point stay inside the CAG shape\n * ray-casting algorithm based on :\n * https://github.com/substack/point-in-polygon/blob/master/index.js\n * http://www.ecse.rp1.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n * originaly writed for https://github.com/lautr3k/SLAcer.js/blob/dev/js/slacer/slicer.js#L82\n * @param {CAG} cag - CAG object\n * @param {Object} p0 - Vertex2 like object\n * @returns {Boolean}\n */\nexport const hasPointInside = (cag: CAG, p0: Vector2) => {\n  let p1 = null;\n  let p2 = null;\n  let inside = false;\n  cag.sides.forEach((side: any) => {\n    p1 = side.vertex0.pos;\n    p2 = side.vertex1.pos;\n    if (hasPointInside.c1(p0, p1, p2) && hasPointInside.c2(p0, p1, p2)) {\n      inside = !inside;\n    }\n  });\n  return inside;\n};\n\nhasPointInside.c1 = (p0: any, p1: any, p2: any) => (p1.y > p0.y) !== (p2.y > p0.y);\nhasPointInside.c2 = (p0: any, p1: any, p2: any) => (p0.x < (p2.x - p1.x) * (p0.y - p1.y) / (p2.y - p1.y) + p1.x);\n\n/**\n * Check if all points from one CAG stay inside another CAG\n * @param {CAG} cag1 - CAG object\n * @param {Object} cag2 - CAG object\n * @returns {Boolean}\n */\nexport const contains = (cag1: CAG, cag2: CAG) => {\n  for (let i = 0, il = cag2.sides.length; i < il; i++) {\n    if (!hasPointInside(cag1, cag2.sides[i].vertex0.pos)) {\n      return false;\n    }\n  }\n  return true;\n};\n","import {Polygon3, PolygonShared, Vertex3} from '@core/math';\nimport {fromPolygons} from '@core/CSGFactories';\nimport {fnSortByIndex} from '@core/utils/sortHelpers';\n\n// FIXME: WHY is this for 3D polygons and not for 2D shapes ?\n\nexport interface ISolidFromSlices {\n  loop: boolean;\n  numslices: number;\n  callback: any;\n}\n\n/**\n * Construct a CSG solid from a list of pre-generated slices.\n * See Polygon.prototype.solidFromSlices() for details.\n * @param {Object} options - options passed to solidFromSlices()\n * @returns {CSG} new CSG object\n */\nexport function fromSlices(options: any) {\n  return solidFromSlices(Polygon3.createFromPoints([\n    [0, 0, 0],\n    [1, 0, 0],\n    [1, 1, 0],\n    [0, 1, 0],\n  ]), options);\n}\n\n/**\n * Creates solid from slices (Polygon) by generating walls\n * @param polygon\n * @param {Object} options Solid generating options\n *  - numslices {Number} Number of slices to be generated\n *  - callback(t, slice) {Function} Callback function generating slices.\n *          arguments: t = [0..1], slice = [0..numslices - 1]\n *          return: Polygon or null to skip\n *  - loop {Boolean} no flats, only walls, it's used to generate solids like a tor\n */\nexport const solidFromSlices = (polygon: Polygon3, options: Partial<ISolidFromSlices>) => {\n  const polygons: Polygon3[] = [];\n  let csg = null;\n  let prev = null;\n  let bottom: Polygon3 = null!;\n  let top: Polygon3 = null!;\n  let numSlices = 2;\n  let bLoop = false;\n  let fnCallback;\n  let flipped: boolean | null = null;\n\n  if (options) {\n    bLoop = Boolean(options.loop);\n\n    if (options.numslices) {\n      numSlices = options.numslices;\n    }\n\n    if (options.callback) {\n      fnCallback = options.callback;\n    }\n  }\n  if (!fnCallback) {\n    const square = Polygon3.createFromPoints([\n      [0, 0, 0],\n      [1, 0, 0],\n      [1, 1, 0],\n      [0, 1, 0],\n    ]);\n    fnCallback = (t: number/* , slice */) => {\n      return t === 0 || t === 1 ? square.translate([0, 0, t]) : null;\n    };\n  }\n  for (let i = 0, iMax = numSlices - 1; i <= iMax; i++) {\n    csg = fnCallback.call(polygon, i / iMax, i);\n    if (csg) {\n      if (!(csg instanceof Polygon3)) {\n        throw new Error('Polygon.solidFromSlices callback error: Polygon expected');\n      }\n      csg.checkIfConvex();\n\n      if (prev) { // generate walls\n        if (flipped === null) { // not generated yet\n          flipped = prev.plane.signedDistanceToPoint(csg.vertices[0].pos) < 0;\n        }\n        _addWalls(polygons, prev, csg, flipped);\n      } else { // the first - will be a bottom\n        bottom = csg;\n      }\n      prev = csg;\n    } // callback can return null to skip that slice\n  }\n  top = csg;\n\n  if (bLoop) {\n    const bSameTopBottom = bottom.vertices.length === top.vertices.length &&\n      bottom.vertices.every((v, index) => {\n        return v.pos.equals(top.vertices[index].pos);\n      });\n    // if top and bottom are not the same -\n    // generate walls between them\n    if (!bSameTopBottom) {\n      _addWalls(polygons, top, bottom, Boolean(flipped));\n    } // else - already generated\n  } else {\n    // save top and bottom\n    // TODO: flip if necessary\n    polygons.unshift(flipped ? bottom : bottom.flipped());\n    polygons.push(flipped ? top.flipped() : top);\n  }\n  return fromPolygons(polygons);\n};\n\n/**\n * @param walls Array of wall polygons\n * @param bottom Bottom polygon\n * @param top Top polygon\n */\nconst _addWalls = (walls: Polygon3[], bottom: Polygon3, top: Polygon3, bFlipped: boolean) => {\n  let bottomPoints = bottom.vertices.slice(0); // make a copy\n  let topPoints = top.vertices.slice(0); // make a copy\n  const color = top.shared || null;\n\n  // check if bottom perimeter is closed\n  if (!bottomPoints[0].pos.equals(bottomPoints[bottomPoints.length - 1].pos)) {\n    bottomPoints.push(bottomPoints[0]);\n  }\n\n  // check if top perimeter is closed\n  if (!topPoints[0].pos.equals(topPoints[topPoints.length - 1].pos)) {\n    topPoints.push(topPoints[0]);\n  }\n  if (bFlipped) {\n    bottomPoints = bottomPoints.reverse();\n    topPoints = topPoints.reverse();\n  }\n\n  const iTopLen = topPoints.length - 1;\n  const iBotLen = bottomPoints.length - 1;\n  const iExtra = iTopLen - iBotLen;// how many extra triangles we need\n  const bMoreTops = iExtra > 0;\n  const bMoreBottoms = iExtra < 0;\n\n  const aMin: any = []; // indexes to start extra triangles (polygon with minimal square)\n  // init - we need exactly /iExtra/ small triangles\n  for (let i = Math.abs(iExtra); i > 0; i--) {\n    aMin.push({\n      len: Infinity,\n      index: -1,\n    });\n  }\n\n  let len;\n  if (bMoreBottoms) {\n    for (let i = 0; i < iBotLen; i++) {\n      len = bottomPoints[i].pos.distanceToSquared(bottomPoints[i + 1].pos);\n      // find the element to replace\n      for (let j = aMin.length - 1; j >= 0; j--) {\n        if (aMin[j].len > len) {\n          aMin[j].len = len;\n          aMin.index = j; // todo !! fix me\n          break;\n        }\n      } // for\n    }\n  } else if (bMoreTops) {\n    for (let i = 0; i < iTopLen; i++) {\n      len = topPoints[i].pos.distanceToSquared(topPoints[i + 1].pos);\n      // find the element to replace\n      for (let j = aMin.length - 1; j >= 0; j--) {\n        if (aMin[j].len > len) {\n          aMin[j].len = len;\n          aMin.index = j;\n          break;\n        }\n      } // for\n    }\n  } // if\n  // sort by index\n  aMin.sort(fnSortByIndex);\n  const getTriangle = (pointA: Vertex3, pointB: Vertex3, pointC: Vertex3, triColor: PolygonShared | null) => { // function addWallsPutTriangle\n    return new Polygon3([pointA, pointB, pointC], triColor);\n    // return bFlipped ? triangle.flipped() : triangle;\n  };\n\n  let bpoint = bottomPoints[0];\n  let tpoint = topPoints[0];\n  let secondPoint;\n  let nBotFacet;\n  let nTopFacet; // length of triangle facet side\n  for (let iB = 0, iT = 0, iMax = iTopLen + iBotLen; iB + iT < iMax;) {\n    if (aMin.length) {\n      if (bMoreTops && iT === aMin[0].index) { // one vertex is on the bottom, 2 - on the top\n        secondPoint = topPoints[++iT];\n        // console.log('<<< extra top: ' + secondPoint + ', ' + tpoint + ', bottom: ' + bpoint);\n        walls.push(getTriangle(\n          secondPoint, tpoint, bpoint, color,\n        ));\n        tpoint = secondPoint;\n        aMin.shift();\n        continue;\n      } else if (bMoreBottoms && iB === aMin[0].index) {\n        secondPoint = bottomPoints[++iB];\n        walls.push(getTriangle(\n          tpoint, bpoint, secondPoint, color,\n        ));\n        bpoint = secondPoint;\n        aMin.shift();\n        continue;\n      }\n    }\n    // choose the shortest path\n    if (iB < iBotLen) { // one vertex is on the top, 2 - on the bottom\n      nBotFacet = tpoint.pos.distanceToSquared(bottomPoints[iB + 1].pos);\n    } else {\n      nBotFacet = Infinity;\n    }\n    if (iT < iTopLen) { // one vertex is on the bottom, 2 - on the top\n      nTopFacet = bpoint.pos.distanceToSquared(topPoints[iT + 1].pos);\n    } else {\n      nTopFacet = Infinity;\n    }\n    if (nBotFacet <= nTopFacet) {\n      secondPoint = bottomPoints[++iB];\n      walls.push(getTriangle(\n        tpoint, bpoint, secondPoint, color,\n      ));\n      bpoint = secondPoint;\n    } else if (iT < iTopLen) { // nTopFacet < Infinity\n      secondPoint = topPoints[++iT];\n      // console.log('<<< top: ' + secondPoint + ', ' + tpoint + ', bottom: ' + bpoint);\n      walls.push(getTriangle(\n        secondPoint, tpoint, bpoint, color,\n      ));\n      tpoint = secondPoint;\n    }\n  }\n  return walls;\n};\n","import {Vector2, Vector3} from '../math';\n\n/**\n * Calc Interpolation Factor\n * @param pointa\n * @param pointb\n * @param intermediatePoint\n */\nfunction calcInterpolationFactor(pointa: Vector2, pointb: Vector2, intermediatePoint: Vector2): number;\nfunction calcInterpolationFactor(pointa: Vector3, pointb: Vector3, intermediatePoint: Vector3): number;\nfunction calcInterpolationFactor(pointa: any, pointb: any, intermediatePoint: any): number {\n  return pointa.distanceTo(intermediatePoint) / pointa.distanceTo(pointb);\n}\n\nexport {calcInterpolationFactor};\n","import {Matrix4x4} from '@core/math';\n\n/**\n * @class Properties\n * This class is used to store properties of a solid\n * A property can for example be a Vertex, a Plane or a Line3D\n * Whenever an affine transform is applied to the CSG solid, all its properties are\n * transformed as well.\n * The properties can be stored in a complex nested structure (using arrays and objects)\n */\nexport class Properties {\n  // todo: replace it with states (setState/getState)\n  [key: string]: any;\n\n  /**\n   * Transform Obj\n   * @param source\n   * @param result\n   * @param matrix4x4\n   */\n  static transformObj(source: any, result: any, matrix4x4: Matrix4x4) {\n    for (const propertyName in source) {\n      if (propertyName === '_transform') continue;\n      if (propertyName === '_merge') continue;\n      const propertyValue = source[propertyName];\n      let transformed = propertyValue;\n      if (typeof (propertyValue) === 'object') {\n        if (('transform' in propertyValue) && (typeof (propertyValue.transform) === 'function')) {\n          transformed = propertyValue.transform(matrix4x4);\n        } else if (propertyValue instanceof Array) {\n          transformed = [];\n          Properties.transformObj(propertyValue, transformed, matrix4x4);\n        } else if (propertyValue instanceof Properties) {\n          transformed = new Properties();\n          Properties.transformObj(propertyValue, transformed, matrix4x4);\n        }\n      }\n      result[propertyName] = transformed;\n    }\n  }\n\n  /**\n   * Clone Obj\n   * @param source\n   * @param result\n   */\n  static cloneObj(source: any, result: any) {\n    for (const propertyName in source) {\n      if (propertyName === '_transform') continue;\n      if (propertyName === '_merge') continue;\n      const propertyValue = source[propertyName];\n      let cloned = propertyValue;\n      if (typeof (propertyValue) === 'object') {\n        if (propertyValue instanceof Array) {\n          cloned = [];\n\n          // tslint:disable-next-line:prefer-for-of\n          for (let i = 0; i < propertyValue.length; i++) {\n            cloned.push(propertyValue[i]);\n          }\n        } else if (propertyValue instanceof Properties) {\n          cloned = new Properties();\n          Properties.cloneObj(propertyValue, cloned);\n        }\n      }\n      result[propertyName] = cloned;\n    }\n  }\n\n  /**\n   * Add From\n   * @param result\n   * @param otherproperties\n   */\n  static addFrom(result: any, otherproperties: any) {\n    for (const propertyName in otherproperties) {\n      if (propertyName === '_transform') continue;\n      if (propertyName === '_merge') continue;\n      if ((propertyName in result) &&\n        (typeof (result[propertyName]) === 'object') &&\n        (result[propertyName] instanceof Properties) &&\n        (typeof (otherproperties[propertyName]) === 'object') &&\n        (otherproperties[propertyName] instanceof Properties)) {\n        Properties.addFrom(result[propertyName], otherproperties[propertyName]);\n      } else if (!(propertyName in result)) {\n        result[propertyName] = otherproperties[propertyName];\n      }\n    }\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   * @private\n   */\n  _transform(matrix4x4: Matrix4x4) {\n    const result = new Properties();\n    Properties.transformObj(this, result, matrix4x4);\n    return result;\n  }\n\n  /**\n   * Merge helper\n   * @param otherproperties\n   * @private\n   */\n  _merge(otherproperties: any) {\n    const result = new Properties();\n    Properties.cloneObj(this, result);\n    Properties.addFrom(result, otherproperties);\n    return result;\n  }\n}\n","import {EPS} from '@core/constants';\nimport {FuzzyCSGFactory} from '@core/FuzzyFactory3d';\nimport {FuzzyCAGFactory} from '@core/FuzzyFactory2d';\nimport {fromPolygons} from '@core/CSGFactories';\nimport {fromSides} from '@core/CAGFactories';\nimport {CSG} from '@core/CSG';\nimport {CAG} from '@core/CAG';\nimport {Polygon3} from '@core/math';\n\n/**\n * Returns a cannoicalized version of the input csg/cag : ie every very close\n * points get deduplicated\n * @returns {CSG|CAG}\n * @example\n * let rawInput = someCSGORCAGMakingFunction()\n * let canonicalized = canonicalize(rawInput)\n */\nfunction canonicalize(csg: CSG, options?: any): CSG;\nfunction canonicalize(cag: CAG, options?: any): CAG;\nfunction canonicalize(csgOrCAG: any, options?: any) {\n  if (csgOrCAG.isCanonicalized) {\n    return csgOrCAG;\n  } else {\n    if ('sides' in csgOrCAG) {\n      return canonicalizeCAG(csgOrCAG, options);\n    } else {\n      return canonicalizeCSG(csgOrCAG, options);\n    }\n  }\n}\n\nexport {canonicalize};\n\n/**\n * Returns a cannoicalized version of the input csg : ie every very close\n * points get deduplicated\n * @returns {CSG}\n * @example\n * let rawCSG = someCSGMakingFunction()\n * let canonicalizedCSG = canonicalize(rawCSG)\n */\nconst canonicalizeCSG = (csg: CSG, options?: any) => {\n  if (csg.isCanonicalized) {\n    return csg;\n  } else {\n    const factory = new FuzzyCSGFactory();\n    const result = CSGFromCSGFuzzyFactory(factory, csg);\n    result.isCanonicalized = true;\n    result.isRetesselated = csg.isRetesselated;\n    result.properties = csg.properties; // keep original properties\n    return result;\n  }\n};\n\n/**\n * Returns a cannoicalized version of the input cag\n * @param cag\n * @param options\n */\nconst canonicalizeCAG = (cag: CAG, options?: any) => {\n  if (cag.isCanonicalized) {\n    return cag;\n  } else {\n    const factory = new FuzzyCAGFactory();\n    const result = CAGFromCAGFuzzyFactory(factory, cag);\n    result.isCanonicalized = true;\n    return result;\n  }\n};\n\n/**\n * CSGFromCSGFuzzyFactory\n * @param factory\n * @param sourcecsg\n * @constructor\n */\nconst CSGFromCSGFuzzyFactory = (factory: FuzzyCSGFactory, sourcecsg: CSG) => {\n  const _this = factory;\n  const newpolygons: Polygon3[] = [];\n\n  sourcecsg.polygons\n    .forEach((polygon) => {\n      const newpolygon = _this.getPolygon(polygon);\n      // see getPolygon above: we may get a polygon with no vertices, discard it:\n      if (newpolygon.vertices.length >= 3) {\n        newpolygons.push(newpolygon);\n      }\n    });\n\n  return fromPolygons(newpolygons);\n};\n\n/**\n * CAGFromCAGFuzzyFactory\n * @param factory\n * @param sourcecag\n * @constructor\n */\nconst CAGFromCAGFuzzyFactory = (factory: FuzzyCAGFactory, sourcecag: CAG) => {\n  const _this = factory;\n\n  const newsides = sourcecag.sides\n    .map((side) => {\n      return _this.getSide(side);\n    })\n    // remove bad sides (mostly a user input issue)\n    .filter((side) => {\n      return side.length() > EPS;\n    });\n\n  return fromSides(newsides);\n};\n","import {EPS} from '@core/constants';\nimport {Plane, Polygon3, PolygonShared, Vertex3} from '@core/math';\nimport {FuzzyFactory} from '@core/FuzzyFactory';\n\n/**\n * Class FuzzyCSGFactory\n */\nexport class FuzzyCSGFactory {\n  vertexfactory = new FuzzyFactory(5, EPS);\n  planefactory = new FuzzyFactory(4, EPS);\n  polygonsharedfactory: { [hash: string]: PolygonShared } = {};\n\n  /**\n   * Get Polygon Shared\n   * @param sourceshared\n   */\n  getPolygonShared(sourceshared: PolygonShared) {\n    const hash = sourceshared.getHash();\n    if (hash in this.polygonsharedfactory) {\n      return this.polygonsharedfactory[hash];\n    } else {\n      this.polygonsharedfactory[hash] = sourceshared;\n      return sourceshared;\n    }\n  }\n\n  /**\n   * Get Vertex\n   * @param sourcevertex\n   */\n  getVertex(sourcevertex: Vertex3) {\n    const elements = [\n      sourcevertex.pos._x, sourcevertex.pos._y, sourcevertex.pos._z,\n      sourcevertex.uv._x, sourcevertex.uv._y,\n    ];\n    const result = this.vertexfactory.lookupOrCreate(elements, (els) => {\n      return sourcevertex;\n    });\n    return result;\n  }\n\n  /**\n   * Get Plane\n   * @param sourceplane\n   */\n  getPlane(sourceplane: Plane) {\n    const elements = [\n      sourceplane.normal._x, sourceplane.normal._y, sourceplane.normal._z,\n      sourceplane.w,\n    ];\n    const result = this.planefactory.lookupOrCreate(elements, (els) => {\n      return sourceplane;\n    });\n    return result;\n  }\n\n  /**\n   * Get Polygon\n   * @param sourcepolygon\n   */\n  getPolygon(sourcepolygon: Polygon3) {\n    const newplane = this.getPlane(sourcepolygon.plane);\n    const newshared = this.getPolygonShared(sourcepolygon.shared);\n    const _this = this;\n    const newvertices = sourcepolygon.vertices.map((vertex) => {\n      return _this.getVertex(vertex);\n    });\n    // two vertices that were originally very close may now have become\n    // truly identical (referring to the same Vertex object).\n    // Remove duplicate vertices:\n    let newverticesDedup: Vertex3[] = [];\n    if (newvertices.length > 0) {\n      let prevvertextag = newvertices[newvertices.length - 1].getTag();\n      newvertices.forEach((vertex) => {\n        const vertextag = vertex.getTag();\n        if (vertextag !== prevvertextag) {\n          newverticesDedup.push(vertex);\n        }\n        prevvertextag = vertextag;\n      });\n    }\n    // If it's degenerate, remove all vertices:\n    if (newverticesDedup.length < 3) {\n      newverticesDedup = [];\n    }\n    return new Polygon3(newverticesDedup, newshared, newplane);\n  }\n}\n\n","/**\n * ## class FuzzyFactory\n * This class acts as a factory for objects. We can search for an object with approximately\n * the desired properties (say a rectangle with width 2 and height 1)\n * The lookupOrCreate() method looks for an existing object (for example it may find an existing rectangle\n * with width 2.0001 and height 0.999. If no object is found, the user supplied callback is\n * called, which should generate a new object. The new object is inserted into the database\n * so it can be found by future lookupOrCreate() calls.\n * Constructor:\n * numdimensions: the number of parameters for each object\n * for example for a 2D rectangle this would be 2\n * tolerance: The maximum difference for each parameter allowed to be considered a match\n */\nexport class FuzzyFactory {\n  lookuptable: any = {};\n  multiplier = 1;\n\n  /**\n   * Fuzzy Constructor\n   */\n  constructor(numdimensions: number, tolerance: number) {\n    this.multiplier = 1.0 / tolerance;\n  }\n\n  /**\n   * let obj = f.lookupOrCreate([el1, el2, el3], function(elements) { ... create the new object ... });\n   * Performs a fuzzy lookup of the object with the specified elements.\n   * If found, returns the existing object\n   * If not found, calls the supplied callback function which should create a new object with\n   * the specified properties. This object is inserted in the lookup database.\n   * @param els\n   * @param creatorCallback\n   */\n  lookupOrCreate(els: number[], creatorCallback: (els: number[]) => any) {\n    const {multiplier} = this;\n\n    let hash = '';\n\n    els.forEach((el: any) => {\n      const valueQuantized = Math.round(el * multiplier);\n      hash += valueQuantized + '/';\n    });\n\n    if (hash in this.lookuptable) {\n      return this.lookuptable[hash];\n    } else {\n      const object = creatorCallback(els);\n      const hashparts = els.map((el: any) => {\n        const q0 = Math.floor(el * multiplier);\n        const q1 = q0 + 1;\n        return ['' + q0 + '/', '' + q1 + '/'];\n      });\n      const numelements = els.length;\n      const numhashes = 1 << numelements;\n      for (let hashmask = 0; hashmask < numhashes; ++hashmask) {\n        let hashmaskShifted = hashmask;\n        hash = '';\n        hashparts.forEach((hashpart: any) => {\n          hash += hashpart[hashmaskShifted & 1];\n          hashmaskShifted >>= 1;\n        });\n        this.lookuptable[hash] = object;\n      }\n      return object;\n    }\n  }\n}\n","import {FuzzyCSGFactory} from '@core/FuzzyFactory3d';\nimport {Polygon3} from '@core/math';\nimport {fromPolygons} from '@core/CSGFactories';\nimport {CSG} from '@core/CSG';\nimport {reTessellateCoplanarPolygons} from '@core/utils/reTessellateCoplanarPolygons';\n\n/**\n * Re-Tessellate\n * @param csg\n */\nexport const reTessellate = (csg: CSG) => {\n  if (csg.isRetesselated) {\n    return csg;\n  } else {\n    const polygonsPerPlane: {\n      [tagHash: string]: Polygon3[]\n    } = {};\n    const isCanonicalized = csg.isCanonicalized;\n    const fuzzyfactory = new FuzzyCSGFactory();\n\n    csg.polygons.map((polygon) => {\n\n      let plane = polygon.plane;\n      let shared = polygon.shared;\n\n      if (!isCanonicalized) {\n        // in order to identify polygons having the same plane, we need to canonicalize the planes\n        // We don't have to do a full canonizalization (including vertices), to save time only do the planes and the shared data:\n        plane = fuzzyfactory.getPlane(plane);\n        shared = fuzzyfactory.getPolygonShared(shared);\n      }\n\n      const tag = plane.getTag() + '/' + shared.getTag();\n      if (!(tag in polygonsPerPlane)) {\n        polygonsPerPlane[tag] = [polygon];\n      } else {\n        polygonsPerPlane[tag].push(polygon);\n      }\n\n    });\n\n    let destpolygons: Polygon3[] = [];\n\n    // tslint:disable-next-line:forin\n    for (const planetag in polygonsPerPlane) {\n      const sourcepolygons = polygonsPerPlane[planetag];\n      if (sourcepolygons.length < 2) {\n        destpolygons = destpolygons.concat(sourcepolygons);\n      } else {\n        const retesselayedpolygons: Polygon3[] = [];\n        reTessellateCoplanarPolygons(sourcepolygons, retesselayedpolygons);\n        destpolygons = destpolygons.concat(retesselayedpolygons);\n      }\n    }\n\n    const result = fromPolygons(destpolygons);\n    result.isRetesselated = true;\n    // result = result.canonicalized();\n    result.properties = csg.properties; // keep original properties\n    return result;\n  }\n};\n","import {CSG} from '@core/CSG';\nimport {Matrix4x4, Vector2, Vector3} from '@core/math';\nimport {Connector} from '@core/Connector';\nimport {fromPoints} from '@core/CAGFactories';\n\n/**\n * Get the transformation that transforms this CSG such that it is lying on the z=0 plane,\n * as flat as possible (i.e. the least z-height).\n * So that it is in an orientation suitable for CNC milling\n * @param _csg\n */\nexport const getTransformationAndInverseTransformationToFlatLying = (_csg: CSG) => {\n  if (_csg.polygons.length === 0) {\n    const m = new Matrix4x4(); // unity\n    return [m, m];\n  } else {\n    // get a list of unique planes in the CSG:\n    const csg = _csg.canonicalized();\n    const planemap: any = {};\n    csg.polygons.map((polygon: any) => {\n      planemap[polygon.plane.getTag()] = polygon.plane;\n    });\n    // try each plane in the CSG and find the plane that, when we align it flat onto z=0,\n    // gives the least height in z-direction.\n    // If two planes give the same height, pick the plane that originally had a normal closest\n    // to [0,0,-1].\n    const xvector = new Vector3(1, 0, 0);\n    const yvector = new Vector3(0, 1, 0);\n    const zvector = new Vector3(0, 0, 1);\n    const z0connectorx = new Connector([0, 0, 0], [0, 0, -1], xvector);\n    const z0connectory = new Connector([0, 0, 0], [0, 0, -1], yvector);\n    let isfirst = true;\n    let minheight = 0;\n    let maxdotz = 0;\n    let besttransformation;\n    let bestinversetransformation;\n\n    // tslint:disable-next-line:forin\n    for (const planetag in planemap) {\n      const plane = planemap[planetag];\n      const pointonplane = plane.normal.times(plane.w);\n      let transformation;\n      let inversetransformation;\n      // We need a normal vecrtor for the transformation\n      // determine which is more perpendicular to the plane normal: x or y?\n      // we will align this as much as possible to the x or y axis vector\n      const xorthogonality = plane.normal.cross(xvector).length();\n      const yorthogonality = plane.normal.cross(yvector).length();\n      if (xorthogonality > yorthogonality) {\n        // x is better:\n        const planeconnector = new Connector(pointonplane, plane.normal, xvector);\n        transformation = planeconnector.getTransformationTo(z0connectorx, false, 0);\n        inversetransformation = z0connectorx.getTransformationTo(planeconnector, false, 0);\n      } else {\n        // y is better:\n        const planeconnector = new Connector(pointonplane, plane.normal, yvector);\n        transformation = planeconnector.getTransformationTo(z0connectory, false, 0);\n        inversetransformation = z0connectory.getTransformationTo(planeconnector, false, 0);\n      }\n      const transformedcsg = csg.transform(transformation);\n      const dotz = -plane.normal.dot(zvector);\n      const bounds = transformedcsg.getBounds();\n      const zheight = bounds[1].z - bounds[0].z;\n      let isbetter = isfirst;\n      if (!isbetter) {\n        if (zheight < minheight) {\n          isbetter = true;\n        } else if (zheight === minheight) {\n          if (dotz > maxdotz) isbetter = true;\n        }\n      }\n      if (isbetter) {\n        // translate the transformation around the z-axis and onto the z plane:\n        const translation = new Vector3([-0.5 * (bounds[1].x + bounds[0].x), -0.5 * (bounds[1].y + bounds[0].y), -bounds[0].z]);\n        transformation = transformation.multiply(Matrix4x4.translation(translation));\n        inversetransformation = Matrix4x4.translation(translation.negated()).multiply(inversetransformation);\n        minheight = zheight;\n        maxdotz = dotz;\n        besttransformation = transformation;\n        bestinversetransformation = inversetransformation;\n      }\n      isfirst = false;\n    }\n    return [besttransformation, bestinversetransformation];\n  }\n};\n\nexport const getTransformationToFlatLying = (csg: any) => {\n  const result = csg.getTransformationAndInverseTransformationToFlatLying();\n  return result[0];\n};\n\nexport const lieFlat = (csg: any) => {\n  const transformation = csg.getTransformationToFlatLying();\n  return csg.transform(transformation);\n};\n\n/**\n * cag = cag.overCutInsideCorners(cutterradius);\n * Using a CNC router it's impossible to cut out a true sharp inside corner. The inside corner\n * will be rounded due to the radius of the cutter. This function compensates for this by creating\n * an extra cutout at each inner corner so that the actual cut out shape will be at least as large\n * as needed.\n * @param {Object} _cag - input cag\n * @param {Float} cutterradius - radius to cut inside corners by\n * @returns {CAG} cag with overcutInsideCorners\n */\nexport const overCutInsideCorners = (_cag: any, cutterradius: number) => {\n  const cag = _cag.canonicalized();\n  // for each vertex determine the 'incoming' side and 'outgoing' side:\n  const pointmap: any = {}; // tag => {pos: coord, from: [], to: []}\n  cag.sides.map((side: any) => {\n    if (!(side.vertex0.getTag() in pointmap)) {\n      pointmap[side.vertex0.getTag()] = {\n        pos: side.vertex0.pos,\n        from: [],\n        to: [],\n      };\n    }\n    pointmap[side.vertex0.getTag()].to.push(side.vertex1.pos);\n    if (!(side.vertex1.getTag() in pointmap)) {\n      pointmap[side.vertex1.getTag()] = {\n        pos: side.vertex1.pos,\n        from: [],\n        to: [],\n      };\n    }\n    pointmap[side.vertex1.getTag()].from.push(side.vertex0.pos);\n  });\n  // overcut all sharp corners:\n  const cutouts = [];\n\n  // tslint:disable-next-line:forin\n  for (const pointtag in pointmap) {\n    const pointobj = pointmap[pointtag];\n    if ((pointobj.from.length === 1) && (pointobj.to.length === 1)) {\n      // ok, 1 incoming side and 1 outgoing side:\n      const fromcoord = pointobj.from[0];\n      const pointcoord = pointobj.pos;\n      const tocoord = pointobj.to[0];\n      const v1 = pointcoord.minus(fromcoord).unit();\n      const v2 = tocoord.minus(pointcoord).unit();\n      const crossproduct = v1.cross(v2);\n      const isInnerCorner = (crossproduct < 0.001);\n      if (isInnerCorner) {\n        // yes it's a sharp corner:\n        let alpha = v2.angleRadians() - v1.angleRadians() + Math.PI;\n        if (alpha < 0) {\n          alpha += 2 * Math.PI;\n        } else if (alpha >= 2 * Math.PI) {\n          alpha -= 2 * Math.PI;\n        }\n        const midvector = v2.minus(v1).unit();\n        const circlesegmentangle = 30 / 180 * Math.PI; // resolution of the circle: segments of 30 degrees\n        // we need to increase the radius slightly so that our imperfect circle will contain a perfect circle of cutterradius\n        const radiuscorrected = cutterradius / Math.cos(circlesegmentangle / 2);\n        const circlecenter = pointcoord.plus(midvector.times(radiuscorrected));\n        // we don't need to create a full circle; a pie is enough. Find the angles for the pie:\n        const startangle = alpha + midvector.angleRadians();\n        const deltaangle = 2 * (Math.PI - alpha);\n        const numsteps = 2 * Math.ceil(deltaangle / circlesegmentangle / 2); // should be even\n        // build the pie:\n        const points = [circlecenter];\n        for (let i = 0; i <= numsteps; i++) {\n          const angle = startangle + i / numsteps * deltaangle;\n          const p = Vector2.fromAngleRadians(angle).times(radiuscorrected).plus(circlecenter);\n          points.push(p);\n        }\n        cutouts.push(fromPoints(points));\n      }\n    }\n  }\n  return cag.subtract(cutouts);\n};\n","import {CSG} from '@core/CSG';\nimport {CAG} from '@core/CAG';\n\n/**\n * Center Options Interface\n */\nexport interface ICenterOptions {\n  axes: [boolean, boolean, boolean];\n  center: [number, number, number];\n}\n\n// TODO : Add addition 'methods' of centering; midpoint, centeriod\n/**\n * Center Default Values\n */\nconst defaults: ICenterOptions = {\n  axes: [true, true, true],\n  center: [0, 0, 0],\n};\n\n/**\n * Centers the given object(s) using the given options (if any)\n * @param {Object} [options] - options for centering\n * @param {Array} [options.axes=[true,true,true]] - axis of which to center, true or false\n * @param {Array} [options.center=[0,0,0]] - point of which to center the object upon\n * @param {Object|Array} objects - the shape(s) to center\n * @return {Object|Array} objects\n *\n * @example\n * let csg = center({axes: [true,false,false]}, sphere()) // center about the X axis\n */\nexport const centerHelper = <ObjectType extends CSG | CAG>(options: Partial<ICenterOptions>, objects: ObjectType | ObjectType[]): ObjectType | ObjectType[] => {\n  objects = Array.isArray(objects) ? objects : [objects];\n  options = {...defaults, ...options};\n\n  const {axes, center: [centerX, centerY, centerZ]} = options as ICenterOptions;\n\n  const results = objects.map((object) => {\n    const bounds = object.getBounds();\n    const offset = [0, 0, 0];\n\n    if (axes[0]) offset[0] = centerX - (bounds[0].x + ((bounds[1].x - bounds[0].x) / 2));\n    if (axes[1]) offset[1] = centerY - (bounds[0].y + ((bounds[1].y - bounds[0].y) / 2));\n    if (axes[2]) offset[2] = centerZ - (bounds[0].z + ((bounds[1].z - bounds[0].z) / 2));\n\n    return object.translate(offset);\n  });\n\n  // if there is more than one result, return them all , otherwise a single one\n  return results.length === 1 ? results[0] : results;\n};\n\n","export * from './expand';\nexport * from './contract';\nexport * from './expandedShellOfCAG';\nexport * from './expandedShellOfCCSG';\n","import {OrthoNormalBasis} from '@core/math';\nimport {parseOptionAsBool} from '@api/optionParsers';\n\n/**\n * Extrude the CAG in a certain plane.\n * Giving just a plane is not enough, multiple different extrusions in the same plane would be possible\n * by rotating around the plane's origin. An additional right-hand vector should be specified as well,\n * and this is exactly a OrthoNormalBasis.\n * @param  {CAG} cag the cag to extrude\n * @param  {Orthonormalbasis} orthonormalbasis characterizes the plane in which to extrude\n * @param  {Float} depth thickness of the extruded shape. Extrusion is done upwards from the plane\n *  (unless symmetrical option is set, see below)\n * @param  {Object} [options] - options for construction\n * @param {Boolean} [options.symmetrical=true] - extrude symmetrically in two directions about the plane\n */\nexport const extrudeInOrthonormalBasis = (cag: any, orthonormalbasis: any, depth: number, options: any) => {\n  // first extrude in the regular Z plane:\n  if (!(orthonormalbasis instanceof OrthoNormalBasis)) {\n    throw new Error('extrudeInPlane: the first parameter should be a OrthoNormalBasis');\n  }\n  let extruded = cag.extrude({\n    offset: [0, 0, depth],\n  });\n  if (parseOptionAsBool(options, 'symmetrical', false)) {\n    extruded = extruded.translate([0, 0, -depth / 2]);\n  }\n  const matrix = orthonormalbasis.getInverseProjectionMatrix();\n  extruded = extruded.transform(matrix);\n  return extruded;\n};\n","import {ConvexHull} from '@helpers/ConvexHull';\nimport {fromPoints} from '@core/CAGFactories';\nimport {isCAG} from '@core/utils/isCAG';\n\n/**\n * Create a convex hull of the given shapes\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to create a hull around\n * @returns {CSG} new CSG object , a hull around the given shapes\n *\n * @example\n * let hulled = hull(rect(), circle())\n */\nexport function hull(...objects: any[]) {\n  const pts = [];\n\n  let a = objects;\n  if (a[0].length) a = a[0];\n\n  const done: {\n    [hash: string]: number\n  } = {};\n\n  // tslint:disable-next-line:prefer-for-of\n  for (let i = 0; i < a.length; i++) {              // extract all points of the CAG in the argument list\n    const cag = a[i];\n    if (!isCAG(cag)) {\n      throw new Error('ERROR: hull() accepts only 2D forms / CAG');\n    }\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let j = 0; j < cag.sides.length; j++) {\n      const x = cag.sides[j].vertex0.pos.x;\n      const y = cag.sides[j].vertex0.pos.y;\n      // avoid some coord to appear multiple times\n      if (done['' + x + ',' + y]) {\n        continue;\n      }\n      pts.push({x, y});\n      done['' + x + ',' + y]++;\n      // echo(x,y);\n    }\n  }\n  // echo(pts.length+\" points in\",pts);\n  const convexHull = new ConvexHull();\n\n  convexHull.compute(pts);\n  const indices = convexHull.getIndices();\n\n  if (indices && indices.length > 0) {\n    const ch = [];\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < indices.length; i++) {\n      ch.push(pts[indices[i]]);\n    }\n    return fromPoints(ch);\n  }\n}\n","import {polyhedron} from './polyhedron';\nimport {scale} from '@modifiers/transforms';\n\nexport interface IGeodesicSphereOptions {\n  r: number;\n  fn: number;\n}\n\nconst defaults: IGeodesicSphereOptions = {\n  r: 1,\n  fn: 5,\n};\n\nconst ci = [ // hard-coded data of icosahedron (20 faces, all triangles)\n  [0.850651, 0.000000, -0.525731],\n  [0.850651, -0.000000, 0.525731],\n  [-0.850651, -0.000000, 0.525731],\n  [-0.850651, 0.000000, -0.525731],\n  [0.000000, -0.525731, 0.850651],\n  [0.000000, 0.525731, 0.850651],\n  [0.000000, 0.525731, -0.850651],\n  [0.000000, -0.525731, -0.850651],\n  [-0.525731, -0.850651, -0.000000],\n  [0.525731, -0.850651, -0.000000],\n  [0.525731, 0.850651, 0.000000],\n  [-0.525731, 0.850651, 0.000000]];\n\nconst ti = [\n  [0, 9, 1], [1, 10, 0], [6, 7, 0], [10, 6, 0], [7, 9, 0], [5, 1, 4], [4, 1, 9], [5, 10, 1], [2, 8, 3], [3, 11, 2],\n  [2, 5, 4], [4, 8, 2], [2, 11, 5], [3, 7, 6], [6, 11, 3], [8, 7, 3], [9, 8, 4], [11, 10, 5], [10, 11, 6], [8, 9, 7],\n];\n\nconst mix3 = (a: number[], b: number[], factor: number) => {\n  const factorInv = 1 - factor;\n  const cv: any = [];\n  for (let i = 0; i < 3; i++) {\n    cv[i] = a[i] * factorInv + b[i] * factor;\n  }\n  return cv;\n};\n\nconst geodesicSubDivide = (p: number[][], fn: number, offset: number) => {\n  const p1 = p[0];\n  const p2 = p[1];\n  const p3 = p[2];\n  let n = offset;\n\n  const c: number[][] = [];\n  const f: number[][] = [];\n\n  //           p3\n  //           /\\\n  //          /__\\     fn = 3\n  //      i  /\\  /\\\n  //        /__\\/__\\       total triangles = 9 (fn*fn)\n  //       /\\  /\\  /\\\n  //     0/__\\/__\\/__\\\n  //    p1 0   j      p2\n\n  for (let i = 0; i < fn; i++) {\n    for (let j = 0; j < fn - i; j++) {\n      const t0 = i / fn;\n      const t1 = (i + 1) / fn;\n      const s0 = j / (fn - i);\n      const s1 = (j + 1) / (fn - i);\n      const s2 = fn - i - 1 ? j / (fn - i - 1) : 1;\n      const q = [];\n\n      q[0] = mix3(mix3(p1, p2, s0), p3, t0);\n      q[1] = mix3(mix3(p1, p2, s1), p3, t0);\n      q[2] = mix3(mix3(p1, p2, s2), p3, t1);\n\n      // -- normalize\n      for (let k = 0; k < 3; k++) {\n        const rv = Math.sqrt(q[k][0] * q[k][0] + q[k][1] * q[k][1] + q[k][2] * q[k][2]);\n        for (let l = 0; l < 3; l++) {\n          q[k][l] /= rv;\n        }\n      }\n      c.push(q[0], q[1], q[2]);\n      f.push([n, n + 1, n + 2]);\n      n += 3;\n\n      if (j < fn - i - 1) {\n        const s3 = fn - i - 1 ? (j + 1) / (fn - i - 1) : 1;\n        q[0] = mix3(mix3(p1, p2, s1), p3, t0);\n        q[1] = mix3(mix3(p1, p2, s3), p3, t1);\n        q[2] = mix3(mix3(p1, p2, s2), p3, t1);\n\n        // -- normalize\n        for (let k = 0; k < 3; k++) {\n          const rv = Math.sqrt(q[k][0] * q[k][0] + q[k][1] * q[k][1] + q[k][2] * q[k][2]);\n          for (let l = 0; l < 3; l++) {\n            q[k][l] /= rv;\n          }\n        }\n        c.push(q[0], q[1], q[2]);\n        f.push([n, n + 1, n + 2]);\n        n += 3;\n      }\n    }\n  }\n  return {points: c, triangles: f, offset: n};\n};\n\n/**\n * Geodesic Sphere\n * @param {IGeodesicSphereOptions} options - options for construction\n * @param {number} options.r - radius of the sphere\n * @param {number} options.fn - segments of the sphere (ie quality/resolution)\n */\nexport function geodesicSphere(options?: Partial<IGeodesicSphereOptions>) {\n  const {r, fn} = {...defaults, ...options};\n  const fnValue = Math.max(1, Math.floor(fn / 6));\n\n  let c: number[][] = [];\n  let f: number[][] = [];\n  let offset = 0;\n\n  // tslint:disable-next-line:prefer-for-of\n  for (let i = 0; i < ti.length; i++) {\n    const g = geodesicSubDivide([ci[ti[i][0]], ci[ti[i][1]], ci[ti[i][2]]], fnValue, offset);\n    c = c.concat(g.points);\n    f = f.concat(g.triangles);\n    offset = g.offset;\n  }\n  return scale(r, polyhedron({points: c, triangles: f}));\n}\n","import {CSG} from '@core/CSG';\nimport {Polygon3, Vector3, Vertex3} from '@core/math';\nimport {fromPolygons} from '@core/CSGFactories';\n\n/**\n * Construct a polyhedron from the given triangles/ polygons/points\n * @param {Object} [options] - options for construction\n * @param {Array} [options.triangles] - triangles to build the polyhedron from\n * @param {Array} [options.polygons] - polygons to build the polyhedron from\n * @param {Array} [options.points] - points to build the polyhedron from\n * @param {Array} [options.colors] - colors to apply to the polyhedron\n * @returns {CSG} new polyhedron\n *\n * @example\n * let torus1 = polyhedron({\n *   points: [...]\n * })\n */\nexport function polyhedron(params: any) {\n  const pgs = [];\n  const ref = params.triangles || params.polygons;\n  const colors = params.colors || null;\n\n  for (let i = 0; i < ref.length; i++) {\n    const pp = [];\n    for (let j = 0; j < ref[i].length; j++) {\n      pp[j] = params.points[ref[i][j]];\n    }\n\n    const v = [];\n    for (let j = ref[i].length - 1; j >= 0; j--) { // --- we reverse order for examples of OpenSCAD work\n      v.push(new Vertex3(new Vector3(pp[j][0], pp[j][1], pp[j][2])));\n    }\n    let s = Polygon3.defaultShared;\n    if (colors && colors[i]) {\n      s = Polygon3.Shared.fromColor(colors[i]);\n    }\n    pgs.push(new Polygon3(v, s));\n  }\n\n  // forced to import here, otherwise out of order imports mess things up\n  return fromPolygons(pgs);\n}\n","import {cssColors3ub, TCssColorNames} from './colorTable/cssColors';\n\n/**\n * Converts an CSS color name to RGB color.\n *\n * @param   colorName       The CSS color name\n * @return  Array           The RGB representation, or [0,0,0] default\n */\nexport function css2rgb(colorName: TCssColorNames | string) {\n  const [r, g, b] = cssColors3ub[colorName.toLowerCase() as TCssColorNames] || [0, 0, 0];\n  return [r / 255, g / 255, b / 255];\n}\n","/**\n * Hue To RGB\n * @param p\n * @param q\n * @param t\n */\nexport function hue2rgb(p: number, q: number, t: number) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n","import {IVectorTextLine} from '@root/text/types/VectorTextTypes';\n\nexport interface ITranslateLineOptions {\n  x: number;\n  y: number;\n}\n\nconst defaults: ITranslateLineOptions = {\n  x: 0,\n  y: 0,\n};\n\n/**\n * Translate text line\n * @param options\n * @param line\n */\nexport function translateLine(options: Partial<ITranslateLineOptions>, line: IVectorTextLine) {\n  const {x, y} = {...defaults, ...options};\n  const segments = line.segments;\n\n  for (let i = 0, il = segments.length; i < il; i++) {\n    const segment = segments[i];\n    for (let j = 0, jl = segment.length; j < jl; j++) {\n      const point = segment[j];\n      segment[j] = [point[0] + x, point[1] + y];\n    }\n  }\n  return line;\n}\n","import {vectorParams} from './vectorParams';\nimport {vectorChar} from './vectorChar';\nimport {translateLine} from './translateLine';\nimport {IVectorTextLine, IVectorTextOptions, TEXT_ALIGN} from '@root/text/types/VectorTextTypes';\n\n/**\n * Construct an array of character segments from a ascii string whose characters code is between 31 and 127,\n * if one character is not supported it is replaced by a question mark.\n * @param {Object|String} [options] - options for construction or ascii string\n * @param {number} [options.xOffset=0] - x offset\n * @param {number} [options.yOffset=0] - y offset\n * @param {number} [options.height=21] - font size (uppercase height)\n * @param {number} [options.lineSpacing=1.4] - line spacing expressed as a percentage of font size\n * @param {number} [options.letterSpacing=1] - extra letter spacing expressed as a percentage of font size\n * @param {String} [options.align='left'] - multi-line text alignement: left, center or right\n * @param {number} [options.extrudeOffset=0] - width of the extrusion that will be applied (manually) after the creation of the character\n * @param {String} [options.input='?'] - ascii string (ignored/overwrited if provided as seconds parameter)\n * @param {String} [text='?'] - ascii string\n * @returns {Array} characters segments [[[x, y], ...], ...]\n *\n * @example\n * let textSegments = vectorText()\n * or\n * let textSegments = vectorText('OpenJSCAD')\n * or\n * let textSegments = vectorText({ yOffset: -50 }, 'OpenJSCAD')\n * or\n * let textSegments = vectorText({ yOffset: -80, input: 'OpenJSCAD' })\n */\nexport function vectorText(options?: Partial<IVectorTextOptions> | string, text: string = '?') {\n  const {\n    xOffset, yOffset, input, font, height, align, extrudeOffset, lineSpacing, letterSpacing,\n  } = vectorParams(options, text);\n  let [x, y] = [xOffset, yOffset];\n\n  let line: IVectorTextLine = {width: 0, segments: []};\n  const lines: IVectorTextLine[] = [];\n\n  let output: any[] = [];\n  let maxWidth = 0;\n  const lineStart = x;\n  const pushLine = () => {\n    lines.push(line);\n    maxWidth = Math.max(maxWidth, line.width);\n    line = {width: 0, segments: []};\n  };\n\n  for (let i = 0, il = input.length; i < il; i++) {\n    const char = input[i];\n    const vect = vectorChar({xOffset: x, yOffset: y, font, height, extrudeOffset}, char);\n    if (char === '\\n') {\n      x = lineStart;\n      y -= vect.height * lineSpacing;\n      pushLine();\n      continue;\n    }\n    const width = vect.width * letterSpacing;\n    line.width += width;\n    x += width;\n    if (char !== ' ') {\n      line.segments = line.segments.concat(vect.segments);\n    }\n  }\n\n  if (line.segments.length) {\n    pushLine();\n  }\n\n  for (let i = 0, il = lines.length; i < il; i++) {\n    line = lines[i];\n    if (maxWidth > line.width) {\n      const diff = maxWidth - line.width;\n      if (align === TEXT_ALIGN.RIGHT) {\n        line = translateLine({x: diff}, line);\n      } else if (align === TEXT_ALIGN.CENTER) {\n        line = translateLine({x: diff / 2}, line);\n      }\n    }\n    output = output.concat(line.segments);\n  }\n  return output;\n}\n","/*\n## License\n\nCopyright (c) 2014 bebbi (elghatta@gmail.com)\nCopyright (c) 2013 Eduard Bespalov (edwbes@gmail.com)\nCopyright (c) 2012 Joost Nieuwenhuijse (joost@newhouse.nl)\nCopyright (c) 2011 Evan Wallace (http://evanw.github.com/csg.js/)\nCopyright (c) 2012 Alexandre Girard (https://github.com/alx)\n\nAll code released under MIT license\n\n## Overview\n\nFor an overview of the CSG process see the original csg.js code:\nhttp://evanw.github.com/csg.js/\n\nCSG operations through BSP trees suffer from one problem: heavy fragmentation\nof polygons. If two CSG solids of n polygons are unified, the resulting solid may have\nin the order of n*n polygons, because each polygon is split by the planes of all other\npolygons. After a few operations the number of polygons explodes.\n\nThis version of CSG.js solves the problem in 3 ways:\n\n1. Every polygon split is recorded in a tree (CSG.PolygonTreeNode). This is a separate\ntree, not to be confused with the CSG tree. If a polygon is split into two parts but in\nthe end both fragments have not been discarded by the CSG operation, we can retrieve\nthe original unsplit polygon from the tree, instead of the two fragments.\n\nThis does not completely solve the issue though: if a polygon is split multiple times\nthe number of fragments depends on the order of subsequent splits, and we might still\nend up with unncessary splits:\nSuppose a polygon is first split into A and B, and then into A1, B1, A2, B2. Suppose B2 is\ndiscarded. We will end up with 2 polygons: A and B1. Depending on the actual split boundaries\nwe could still have joined A and B1 into one polygon. Therefore a second approach is used as well:\n\n2. After CSG operations all coplanar polygon fragments are joined by a retesselating\noperation. See CSG.reTesselated(). Retesselation is done through a\nlinear sweep over the polygon surface. The sweep line passes over the y coordinates\nof all vertices in the polygon. Polygons are split at each sweep line, and the fragments\nare joined horizontally and vertically into larger polygons (making sure that we\nwill end up with convex polygons).\nThis still doesn't solve the problem completely: due to floating point imprecisions\nwe may end up with small gaps between polygons, and polygons may not be exactly coplanar\nanymore, and as a result the retesselation algorithm may fail to join those polygons.\nTherefore:\n\n3. A canonicalization algorithm is implemented: it looks for vertices that have\napproximately the same coordinates (with a certain tolerance, say 1e-5) and replaces\nthem with the same vertex. If polygons share a vertex they will actually point to the\nsame CSG.Vertex instance. The same is done for polygon planes. See CSG.canonicalized().\n\nPerformance improvements to the original CSG.js:\n\nReplaced the flip() and invert() methods by flipped() and inverted() which don't\nmodify the source object. This allows to get rid of all clone() calls, so that\nmultiple polygons can refer to the same CSG.Plane instance etc.\n\nThe original union() used an extra invert(), clipTo(), invert() sequence just to remove the\ncoplanar front faces from b; this is now combined in a single b.clipTo(a, true) call.\n\nDetection whether a polygon is in front or in back of a plane: for each polygon\nwe are caching the coordinates of the bounding sphere. If the bounding sphere is\nin front or in back of the plane we don't have to check the individual vertices\nanymore.\n\nOther additions to the original CSG.js:\n\nCSG.Vector class has been renamed into CSG.Vector3D\n\nClasses for 3D lines, 2D vectors, 2D lines, and methods to find the intersection of\na line and a plane etc.\n\nTransformations: CSG.transform(), CSG.translate(), CSG.rotate(), CSG.scale()\n\nExpanding or contracting a solid: CSG.expand() and CSG.contract(). Creates nice\nsmooth corners.\n\nThe vertex normal has been removed since it complicates retesselation. It's not needed\nfor solid CAD anyway.\n*/\n\nimport {circle, cube, cylinder, geodesicSphere, polygon, polyhedron, sphere, square, torus, triangle} from '@root/primitives';\n\nexport * as color from './color';\n\nexport const primitives2d = {circle, square, polygon, triangle};\nexport const primitives3d = {cube, sphere, geodesicSphere, cylinder, torus, polyhedron};\n\nexport * as booleanOps from '@modifiers/booleans';\nexport * as transformations from '@modifiers/transforms';\nexport * as extrusions from '@modifiers/extrusions';\n\nexport * as maths from '@math/mathsHelpersAPI';\nexport * as text from './text';\n\n// these are 'external' to this api and we basically just re-export for old api compatibility\n// ...needs to be reviewed\nexport {CSG} from '@core/CSG';\nexport {CAG} from '@core/CAG';\n\nexport {isCSG} from '@core/utils/isCSG';\nexport {isCAG} from '@core/utils/isCAG';\n\ndeclare var __LIB_VERSION__: { build: string; date: string; stamp: number; };\nexport const version = __LIB_VERSION__;\n","import {CAG} from '@core/CAG'; // we have to import from top level otherwise prototypes are not complete..\n\nexport interface ISquareOptions {\n  center: boolean;\n  size: number | [number, number];\n}\n\nconst defaults: ISquareOptions = {\n  center: false,\n  size: [1, 1],\n};\n\n/**\n * Construct a square/rectangle\n * @param {ISquareOptions} options - options for construction\n * @param {number} options.size - size of the square, either as array or scalar\n * @param {boolean} options.center - whether to center the square/rectangle or not\n * @returns {CAG} new square\n *\n * @example\n * let square1 = square({\n *   size: 10\n * })\n */\nexport function square(options?: Partial<ISquareOptions> | number | [number, number]) {\n  const {center, size} = {\n    ...defaults,\n    ...(typeof options === 'number' ? {size: [options, options]} : (Array.isArray(options) ? {size: [...options]} : options)),\n  } as ISquareOptions;\n\n  const [halfWidth, halfHeight] = typeof size === 'number' ? [size / 2, size / 2] : [size[0] / 2, size[1] / 2];\n  const offset = center ? [0, 0] : [halfWidth, halfHeight];\n\n  return CAG.rectangle({center: offset, radius: [halfWidth, halfHeight]});\n}\n","import {Plane, Polygon3, PolygonShared, TVector3Universal, Vector3, Vertex3} from '.';\n\n/**\n * Create a polygon from the given points.\n *\n * @param {Array[]} points - list of points\n * @param {Polygon.Shared} [shared=defaultShared] - shared property to apply\n * @param {Plane} [plane] - plane of the polygon\n *\n * @example\n * const points = [\n *   [0,  0, 0],\n *   [0, 10, 0],\n *   [0, 10, 10]\n * ]\n * let polygon = CSG.Polygon.createFromPoints(points)\n */\nexport const fromPoints = (points: TVector3Universal[], shared?: PolygonShared, plane?: Plane) => {\n  const vertices: Vertex3[] = [];\n\n  points.map((p) => {\n    const vec = new Vector3(p);\n    const vertex = new Vertex3(vec);\n    vertices.push(vertex);\n  });\n\n  return new Polygon3(vertices, shared, plane);\n};\n","import {getTag} from '@core/constants';\n\n/**\n * Class Polygon.Shared\n * Holds the shared properties for each polygon (Currently only color).\n * @constructor\n * @param {Array[]} color - array containing RGBA values, or null\n *\n * @example\n *   let shared = new CSG.Polygon.Shared([0, 0, 0, 1])\n */\nexport class PolygonShared {\n  color: [number, number, number, number];\n  tag?: number;\n\n  /**\n   * make from object\n   * @param obj\n   */\n  static fromObject(obj: any) {\n    return new PolygonShared(obj.color);\n  };\n\n  /**\n   * Create Polygon.Shared from color values.\n   * @param {number} r - value of RED component\n   * @param {number} g - value of GREEN component\n   * @param {number} b - value of BLUE component\n   * @param {number} [a] - value of ALPHA component\n   * @param {Array[]} [color] - OR array containing RGB values (optional Alpha)\n   *\n   * @example\n   * let s1 = Polygon.Shared.fromColor(0,0,0)\n   * let s2 = Polygon.Shared.fromColor([0,0,0,1])\n   */\n  static fromColor(...args: any[]) {\n    let color;\n    if (args.length === 1) {\n      color = args[0].slice(); // make deep copy\n    } else {\n      color = [];\n\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < args.length; i++) {\n        color.push(args[i]);\n      }\n    }\n    if (color.length === 3) {\n      color.push(1);\n    } else if (color.length !== 4) {\n      throw new Error('setColor expects either an array with 3 or 4 elements, or 3 or 4 parameters.');\n    }\n    return new PolygonShared(color);\n  };\n\n  /**\n   * PolygonShared Constructor\n   */\n  constructor(color?: [number, number, number, number] | null) {\n    if (typeof color !== 'undefined' && color !== null) {\n      if (color.length !== 4) {\n        throw new Error('Expecting 4 element array');\n      }\n    }\n    this.color = color as any;\n  }\n\n  /**\n   * get Tag\n   */\n  getTag() {\n    let result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  }\n\n  /**\n   * get a string uniquely identifying this object\n   */\n  getHash() {\n    if (!this.color) return 'null';\n    return this.color.join('/');\n  }\n}\n","import {fromPoints} from '@core/CAGFactories';\n\n/**\n * 2D polygons are now supported through the CAG class.\n * With many improvements (see documentation):\n *  - shapes do no longer have to be convex\n *  - union/intersect/subtract is supported\n *  - expand / contract are supported\n *\n *  But we'll keep CSG.Polygon2D as a stub for backwards compatibility\n *\n * @param points\n * @constructor\n */\nexport function Polygon2D(points: any) {\n  return fromPoints(points);\n}\n","import {EPS} from '@core/constants';\nimport {solve2Linear} from '@core/utils/solve2Linear';\n\n/**\n * See if the line between p0start and p0end intersects with the line between p1start and p1end\n * returns true if the lines strictly intersect, the end points are not counted!\n * @param p0start\n * @param p0end\n * @param p1start\n * @param p1end\n */\nexport const linesIntersect = (p0start: any, p0end: any, p1start: any, p1end: any) => {\n  if (p0end.equals(p1start) || p1end.equals(p0start)) {\n    const d = p1end.minus(p1start).unit().plus(p0end.minus(p0start).unit()).length();\n    if (d < EPS) {\n      return true;\n    }\n  } else {\n    const d0 = p0end.minus(p0start);\n    const d1 = p1end.minus(p1start);\n    // FIXME These epsilons need review and testing\n    if (Math.abs(d0.cross(d1)) < 1e-9) return false; // lines are parallel\n    const alphas = solve2Linear(-d0.x, d1.x, -d0.y, d1.y, p0start.x - p1start.x, p0start.y - p1start.y);\n    if ((alphas[0] > 1e-6) && (alphas[0] < 0.999999) && (alphas[1] > 1e-5) && (alphas[1] < 0.999999)) return true;\n    // if( (alphas[0] >= 0) && (alphas[0] <= 1) && (alphas[1] >= 0) && (alphas[1] <= 1) ) return true;\n  }\n  return false;\n};\n","import {isCAG} from '@core/utils/isCAG';\n\n/**\n * Union / combine the given shapes\n * @param {Object(s)|Array} objects - objects to combine : can be given\n * - one by one: union(a,b,c) or\n * - as an array: union([a,b,c])\n * @returns {CSG} new CSG object, the union of all input shapes\n *\n * @example\n * let unionOfSphereAndCube = union(sphere(), cube())\n */\nexport const union = (...objects: any[]) => {\n  const defaults = {\n    extrude2d: false,\n  };\n\n  let options = {...defaults};\n  let o;\n  let i = 0;\n  let a = objects;\n\n  if (a[0].length) a = a[0];\n\n  if ('extrude2d' in a[0]) { // first parameter is options\n    options = Object.assign({}, defaults, a[0]);\n    o = a[i++];\n  }\n\n  o = a[i++];\n\n  // TODO: add option to be able to set this?\n  if ((typeof (a[i]) === 'object') && isCAG(a[i]) && options.extrude2d) {\n    o = a[i].extrude({offset: [0, 0, 0.1]}); // -- convert a 2D shape to a thin solid, note: do not a[i] = a[i].extrude()\n  }\n  for (; i < a.length; i++) {\n    let obj = a[i];\n\n    if ((typeof (a[i]) === 'object') && isCAG(a[i]) && options.extrude2d) {\n      obj = a[i].extrude({offset: [0, 0, 0.1]}); // -- convert a 2D shape to a thin solid:\n    }\n    o = o.union(obj);\n  }\n  return o;\n};\n","import {isCAG} from '@core/utils/isCAG';\n\n/**\n * Difference / Subtraction of the given shapes ie:\n * cut out C From B From A ie : a - b - c etc\n * @param {Object(s)|Array} objects - objects to subtract\n * can be given\n * - one by one: difference(a,b,c) or\n * - as an array: difference([a,b,c])\n * @returns {CSG} new CSG object, the difference of all input shapes\n *\n * @example\n * let differenceOfSphereAndCube = difference(sphere(), cube())\n */\nexport const difference = (...objects: any[]) => {\n  let object;\n  let i = 0;\n  let a = objects;\n  if (a[0].length) a = a[0];\n  for (object = a[i++]; i < a.length; i++) {\n    if (isCAG(a[i])) {\n      object = object.subtract(a[i]);\n    } else {\n      object = object.subtract(a[i].setColor(1, 1, 0)); // -- color the cuts\n    }\n  }\n  return object;\n};\n","import {isCAG} from '@core/utils/isCAG';\n\n/**\n * intersection of the given shapes: ie keep only the common parts between the given shapes\n * @param {Object(s)|Array} objects - objects to intersect\n * can be given\n * - one by one: intersection(a,b,c) or\n * - as an array: intersection([a,b,c])\n * @returns {CSG} new CSG object, the intersection of all input shapes\n *\n * @example\n * let intersectionOfSphereAndCube = intersection(sphere(), cube())\n */\nexport const intersection = (...objects: any[]) => {\n  let object;\n  let i = 0;\n  let a = objects;\n  if (a[0].length) a = a[0];\n  for (object = a[i++]; i < a.length; i++) {\n    if (isCAG(a[i])) {\n      object = object.intersect(a[i]);\n    } else {\n      object = object.intersect(a[i].setColor(1, 1, 0)); // -- color the cuts\n    }\n  }\n  return object;\n};\n","import {Matrix4x4, Plane, TVector3Universal, Vector3} from '.';\n\n/**\n * Extra Transformation Methods\n */\nexport abstract class TransformationMethods {\n  /**\n   * Transform helper\n   * @abstract\n   * @param mat\n   */\n  abstract transform(mat: Matrix4x4): any;\n\n  /**\n   * Get Mirrored\n   * @param plane\n   */\n  mirrored(plane: Plane) {\n    return this.transform(Matrix4x4.mirroring(plane));\n  }\n\n  /**\n   * Get Mirrored - X\n   */\n  mirroredX() {\n    const plane = new Plane(Vector3.Create(1, 0, 0), 0);\n    return this.mirrored(plane);\n  }\n\n  /**\n   * Get Mirrored - Y\n   */\n  mirroredY() {\n    const plane = new Plane(Vector3.Create(0, 1, 0), 0);\n    return this.mirrored(plane);\n  }\n\n  /**\n   * Get Mirrored - Z\n   */\n  mirroredZ() {\n    const plane = new Plane(Vector3.Create(0, 0, 1), 0);\n    return this.mirrored(plane);\n  }\n\n  /**\n   * Translate\n   * @param v\n   */\n  translate(v: TVector3Universal) {\n    return this.transform(Matrix4x4.translation(v));\n  }\n\n  /**\n   * Scale\n   * @param f\n   */\n  scale(f: TVector3Universal) {\n    return this.transform(Matrix4x4.scaling(f));\n  }\n\n  /**\n   * Rotate - X\n   * @param deg\n   */\n  rotateX(deg: number) {\n    return this.transform(Matrix4x4.rotationX(deg));\n  }\n\n  /**\n   * Rotate - Y\n   * @param deg\n   */\n  rotateY(deg: number) {\n    return this.transform(Matrix4x4.rotationY(deg));\n  }\n\n  /**\n   * Rotate - Z\n   * @param deg\n   */\n  rotateZ(deg: number) {\n    return this.transform(Matrix4x4.rotationZ(deg));\n  }\n\n  /**\n   * Rotate\n   * @param rotationCenter\n   * @param rotationAxis\n   * @param degrees\n   */\n  rotate(rotationCenter: any, rotationAxis: any, degrees: number) {\n    return this.transform(Matrix4x4.rotation(rotationCenter, rotationAxis, degrees));\n  }\n\n  /**\n   * Rotate Euler Angles\n   * @param alpha\n   * @param beta\n   * @param gamma\n   * @param position\n   */\n  rotateEulerAngles(alpha: number, beta: number, gamma: number, position: TVector3Universal) {\n    position = position || [0, 0, 0];\n\n    const Rz1 = Matrix4x4.rotationZ(alpha);\n    const Rx = Matrix4x4.rotationX(beta);\n    const Rz2 = Matrix4x4.rotationZ(gamma);\n    const T = Matrix4x4.translation(new Vector3(position));\n\n    return this.transform(Rz2.multiply(Rx).multiply(Rz1).multiply(T));\n  }\n\n  /**\n   * Rotate Euler XYZ\n   * @param alpha\n   * @param beta\n   * @param gamma\n   * @param position\n   */\n  rotateEulerXYZ(alpha: number, beta: number, gamma: number, position: TVector3Universal) {\n    position = position || [0, 0, 0];\n\n    const Rx = Matrix4x4.rotationX(alpha);\n    const Ry = Matrix4x4.rotationY(beta);\n    const Rz = Matrix4x4.rotationZ(gamma);\n    const T = Matrix4x4.translation(new Vector3(position));\n\n    return this.transform(Rz.multiply(Ry).multiply(Rx).multiply(T));\n  }\n}\n","import {solve2Linear} from '@core/utils/solve2Linear';\nimport {Matrix4x4, TransformationMethods, TVector2Universal, Vector2} from '.';\n\n/**\n * Line2D\n * Represents a directional line in 2D space\n * A line is parametrized by its normal vector (perpendicular to the line, rotated 90 degrees counter clockwise)\n * and w. The line passes through the point <normal>.times(w).\n * Equation: p is on line if normal.dot(p)==w\n *\n * @param {Vector2} normal normal must be a unit vector!\n * @returns {Line2D}\n */\nexport class Line2D extends TransformationMethods {\n  normal: Vector2;\n  w: number;\n\n  static fromPoints(_p1: TVector2Universal, _p2: TVector2Universal) {\n    const p1 = new Vector2(_p1);\n    const p2 = new Vector2(_p2);\n    const direction = p2.minus(p1);\n    const normal = direction.normal().negated().unit();\n    const w = p1.dot(normal);\n    return new Line2D(normal, w);\n  };\n\n  /**\n   * Line2D Constructor\n   */\n  constructor(_normal: TVector2Universal, w: number | string) {\n    super();\n    let normal = new Vector2(_normal);\n    w = typeof w === 'string' ? parseFloat(w) : w;\n    const l = normal.length();\n    // normalize:\n    w *= l;\n    normal = normal.times(1.0 / l);\n    this.normal = normal;\n    this.w = w;\n  }\n\n  /**\n   * Reverse\n   * same line but opposite direction:\n   */\n  reverse() {\n    return new Line2D(this.normal.negated(), -this.w);\n  }\n\n  /**\n   * Line-Line equals\n   * @param l\n   */\n  equals(l: Line2D) {\n    return (l.normal.equals(this.normal) && (l.w === this.w));\n  }\n\n  /**\n   * get Origin\n   */\n  origin() {\n    return this.normal.times(this.w);\n  }\n\n  /**\n   * get Direction\n   */\n  direction() {\n    return this.normal.normal();\n  }\n\n  /**\n   * get x at y\n   * @param y\n   */\n  xAtY(y: number) {\n    // (py == y) && (normal * p == w)\n    // -> px = (w - normal._y * y) / normal.x\n    const x = (this.w - this.normal._y * y) / this.normal.x;\n    return x;\n  }\n\n  /**\n   * |distance| to point\n   * @param point\n   */\n  absDistanceToPoint(point: Vector2 | [number, number]) {\n    point = new Vector2(point);\n    const pointProjected = point.dot(this.normal);\n    const distance = Math.abs(pointProjected - this.w);\n    return distance;\n  }\n\n  /* FIXME: has error - origin is not defined, the method is never used\n   closestPoint: function(point) {\n       point = new Vector2(point);\n       let vector = point.dot(this.direction());\n       return origin.plus(vector);\n   },\n   */\n\n  /**\n   * Intersection between two lines, returns point as Vector2\n   * @param line2d\n   */\n  intersectWithLine(line2d: Line2D) {\n    const point = solve2Linear(this.normal.x, this.normal.y, line2d.normal.x, line2d.normal.y, this.w, line2d.w);\n    return new Vector2(point);\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Line2D {\n    const origin = new Vector2(0, 0);\n    const pointOnPlane = this.normal.times(this.w);\n    const neworigin = origin.multiply4x4(matrix4x4);\n    const neworiginPlusNormal = this.normal.multiply4x4(matrix4x4);\n    const newnormal = neworiginPlusNormal.minus(neworigin);\n    const newpointOnPlane = pointOnPlane.multiply4x4(matrix4x4);\n    const neww = newnormal.dot(newpointOnPlane);\n    return new Line2D(newnormal, neww);\n  }\n}\n\n","import {EPS} from '@core/constants';\nimport {solve2Linear} from '@core/utils/solve2Linear';\nimport {Matrix4x4, Plane, TransformationMethods, TVector3Universal, Vector3} from '.';\n\n/**\n * Represents a line in 3D space\n * direction must be a unit vector\n * point is a random point on the line\n * @class Line3D\n */\nexport class Line3D extends TransformationMethods {\n  point: Vector3;\n  direction: Vector3;\n\n  /**\n   * Make Line3D from points\n   * @param _p1\n   * @param _p2\n   */\n  static fromPoints(_p1: TVector3Universal, _p2: TVector3Universal) {\n    const p1 = new Vector3(_p1);\n    const p2 = new Vector3(_p2);\n    const direction = p2.minus(p1);\n    return new Line3D(p1, direction);\n  }\n\n  /**\n   * Make Line3D from planes\n   * @param p1\n   * @param p2\n   */\n  static fromPlanes(p1: Plane, p2: Plane) {\n    let direction = p1.normal.cross(p2.normal);\n    const l = direction.length();\n    if (l < EPS) {\n      throw new Error('Parallel planes');\n    }\n    direction = direction.times(1.0 / l);\n\n    const mabsx = Math.abs(direction.x);\n    const mabsy = Math.abs(direction.y);\n    const mabsz = Math.abs(direction.z);\n    let origin;\n    if ((mabsx >= mabsy) && (mabsx >= mabsz)) {\n      // direction vector is mostly pointing towards x\n      // find a point p for which x is zero:\n      const r = solve2Linear(p1.normal.y, p1.normal.z, p2.normal.y, p2.normal.z, p1.w, p2.w);\n      origin = new Vector3(0, r[0], r[1]);\n    } else if ((mabsy >= mabsx) && (mabsy >= mabsz)) {\n      // find a point p for which y is zero:\n      const r = solve2Linear(p1.normal.x, p1.normal.z, p2.normal.x, p2.normal.z, p1.w, p2.w);\n      origin = new Vector3(r[0], 0, r[1]);\n    } else {\n      // find a point p for which z is zero:\n      const r = solve2Linear(p1.normal.x, p1.normal.y, p2.normal.x, p2.normal.y, p1.w, p2.w);\n      origin = new Vector3(r[0], r[1], 0);\n    }\n    return new Line3D(origin, direction);\n  }\n\n  /**\n   * Line3D Constructor\n   */\n  constructor(point: TVector3Universal, direction: TVector3Universal) {\n    super();\n    this.point = new Vector3(point);\n    this.direction = new Vector3(direction).unit();\n  }\n\n  /**\n   * Intersect with plane\n   * @param plane\n   */\n  intersectWithPlane(plane: Plane) {\n    // plane: plane.normal * p = plane.w\n    // line: p=line.point + labda * line.direction\n    const labda = (plane.w - plane.normal.dot(this.point)) / plane.normal.dot(this.direction);\n    const point = this.point.plus(this.direction.times(labda));\n    return point;\n  }\n\n  /**\n   * Clone\n   */\n  clone() {\n    return new Line3D(this.point.clone(), this.direction.clone());\n  }\n\n  /**\n   * Reverse\n   */\n  reverse() {\n    return new Line3D(this.point.clone(), this.direction.negated());\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Line3D {\n    const newpoint = this.point.multiply4x4(matrix4x4);\n    const pointPlusDirection = this.point.plus(this.direction);\n    const newPointPlusDirection = pointPlusDirection.multiply4x4(matrix4x4);\n    const newdirection = newPointPlusDirection.minus(newpoint);\n    return new Line3D(newpoint, newdirection);\n  }\n\n  /**\n   * Get closest point on line\n   * @param _point\n   */\n  closestPointOnLine(_point: TVector3Universal) {\n    const point = new Vector3(_point);\n    const t = point.minus(this.point).dot(this.direction) / this.direction.dot(this.direction);\n    const closestpoint = this.point.plus(this.direction.times(t));\n    return closestpoint;\n  }\n\n  /**\n   * Distance to point\n   * @param _point\n   */\n  distanceToPoint(_point: TVector3Universal) {\n    const point = new Vector3(_point);\n    const closestpoint = this.closestPointOnLine(point);\n    const distancevector = point.minus(closestpoint);\n    const distance = distancevector.length();\n    return distance;\n  }\n\n  /**\n   * Line-Line equals\n   * @param line3d\n   */\n  equals(line3d: Line3D) {\n    if (!this.direction.equals(line3d.direction)) return false;\n    const distance = this.distanceToPoint(line3d.point);\n\n    if (distance > EPS) {\n      return false;\n    }\n    return true;\n  }\n}\n","import {OrthoNormalBasis, Plane, TVector3Universal, Vector2, Vector3} from '.';\n\n/**\n * Represents a 4x4 matrix. Elements are specified in row order\n *\n * @class Matrix4x4\n */\nexport class Matrix4x4 {\n  /**\n   * Return the unity matrix\n   */\n  static unity() {\n    return new Matrix4x4();\n  };\n\n  /**\n   * Create a rotation matrix for rotating around the x axis\n   * @param degrees\n   */\n  static rotationX(degrees: number) {\n    const radians = degrees * Math.PI * (1.0 / 180.0);\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const els = [\n      1, 0, 0, 0, 0, cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1,\n    ];\n    return new Matrix4x4(els);\n  };\n\n  /**\n   * Create a rotation matrix for rotating around the y axis\n   * @param degrees\n   */\n  static rotationY(degrees: number) {\n    const radians = degrees * Math.PI * (1.0 / 180.0);\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const els = [\n      cos, 0, -sin, 0, 0, 1, 0, 0, sin, 0, cos, 0, 0, 0, 0, 1,\n    ];\n    return new Matrix4x4(els);\n  };\n\n  /**\n   * Create a rotation matrix for rotating around the z axis\n   * @param degrees\n   */\n  static rotationZ(degrees: number) {\n    const radians = degrees * Math.PI * (1.0 / 180.0);\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const els = [\n      cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,\n    ];\n    return new Matrix4x4(els);\n  };\n\n  /**\n   * Matrix for rotation about arbitrary point and axis\n   * @param _rotationCenter\n   * @param _rotationAxis\n   * @param degrees\n   */\n  static rotation(_rotationCenter: TVector3Universal, _rotationAxis: TVector3Universal, degrees: number) {\n    const rotationCenter = new Vector3(_rotationCenter);\n    const rotationAxis = new Vector3(_rotationAxis);\n    const rotationPlane = Plane.fromNormalAndPoint(rotationAxis, rotationCenter);\n    const orthobasis = new OrthoNormalBasis(rotationPlane);\n    let transformation = Matrix4x4.translation(rotationCenter.negated());\n    transformation = transformation.multiply(orthobasis.getProjectionMatrix());\n    transformation = transformation.multiply(Matrix4x4.rotationZ(degrees));\n    transformation = transformation.multiply(orthobasis.getInverseProjectionMatrix());\n    transformation = transformation.multiply(Matrix4x4.translation(rotationCenter));\n    return transformation;\n  };\n\n  /**\n   * Create an affine matrix for translation:\n   * @param v\n   */\n  static translation(v: TVector3Universal) {\n    // parse as Vector3, so we can pass an array or a Vector3\n    const vec = new Vector3(v);\n    const els = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, vec.x, vec.y, vec.z, 1];\n    return new Matrix4x4(els);\n  };\n\n  /**\n   * Create an affine matrix for mirroring into an arbitrary plane:\n   * @param plane\n   */\n  static mirroring(plane: Plane) {\n    const nx = plane.normal.x;\n    const ny = plane.normal.y;\n    const nz = plane.normal.z;\n    const w = plane.w;\n    const els = [\n      (1.0 - 2.0 * nx * nx), (-2.0 * ny * nx), (-2.0 * nz * nx), 0,\n      (-2.0 * nx * ny), (1.0 - 2.0 * ny * ny), (-2.0 * nz * ny), 0,\n      (-2.0 * nx * nz), (-2.0 * ny * nz), (1.0 - 2.0 * nz * nz), 0,\n      (2.0 * nx * w), (2.0 * ny * w), (2.0 * nz * w), 1,\n    ];\n    return new Matrix4x4(els);\n  };\n\n  /**\n   * Create an affine matrix for scaling:\n   * @param v\n   */\n  static scaling(v: TVector3Universal) {\n    // parse as Vector3, so we can pass an array or a Vector3\n    const vec = new Vector3(v);\n    const els = [\n      vec.x, 0, 0, 0, 0, vec.y, 0, 0, 0, 0, vec.z, 0, 0, 0, 0, 1,\n    ];\n    return new Matrix4x4(els);\n  };\n\n  /**\n   * Metrix4x4 Constructor\n   * @param elements\n   */\n  constructor(public elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) {\n  }\n\n  /**\n   * Plus\n   * @param m\n   */\n  plus(m: Matrix4x4) {\n    const r = [];\n    for (let i = 0; i < 16; i++) {\n      r[i] = this.elements[i] + m.elements[i];\n    }\n    return new Matrix4x4(r);\n  }\n\n  /**\n   * Minus\n   * @param m\n   */\n  minus(m: Matrix4x4) {\n    const r = [];\n    for (let i = 0; i < 16; i++) {\n      r[i] = this.elements[i] - m.elements[i];\n    }\n    return new Matrix4x4(r);\n  }\n\n  /**\n   * Right multiply by another 4x4 matrix:\n   * @param m\n   */\n  multiply(m: Matrix4x4) {\n    // cache elements in local variables, for speedup:\n    const this0 = this.elements[0];\n    const this1 = this.elements[1];\n    const this2 = this.elements[2];\n    const this3 = this.elements[3];\n    const this4 = this.elements[4];\n    const this5 = this.elements[5];\n    const this6 = this.elements[6];\n    const this7 = this.elements[7];\n    const this8 = this.elements[8];\n    const this9 = this.elements[9];\n    const this10 = this.elements[10];\n    const this11 = this.elements[11];\n    const this12 = this.elements[12];\n    const this13 = this.elements[13];\n    const this14 = this.elements[14];\n    const this15 = this.elements[15];\n    const m0 = m.elements[0];\n    const m1 = m.elements[1];\n    const m2 = m.elements[2];\n    const m3 = m.elements[3];\n    const m4 = m.elements[4];\n    const m5 = m.elements[5];\n    const m6 = m.elements[6];\n    const m7 = m.elements[7];\n    const m8 = m.elements[8];\n    const m9 = m.elements[9];\n    const m10 = m.elements[10];\n    const m11 = m.elements[11];\n    const m12 = m.elements[12];\n    const m13 = m.elements[13];\n    const m14 = m.elements[14];\n    const m15 = m.elements[15];\n\n    const result = [];\n    result[0] = this0 * m0 + this1 * m4 + this2 * m8 + this3 * m12;\n    result[1] = this0 * m1 + this1 * m5 + this2 * m9 + this3 * m13;\n    result[2] = this0 * m2 + this1 * m6 + this2 * m10 + this3 * m14;\n    result[3] = this0 * m3 + this1 * m7 + this2 * m11 + this3 * m15;\n    result[4] = this4 * m0 + this5 * m4 + this6 * m8 + this7 * m12;\n    result[5] = this4 * m1 + this5 * m5 + this6 * m9 + this7 * m13;\n    result[6] = this4 * m2 + this5 * m6 + this6 * m10 + this7 * m14;\n    result[7] = this4 * m3 + this5 * m7 + this6 * m11 + this7 * m15;\n    result[8] = this8 * m0 + this9 * m4 + this10 * m8 + this11 * m12;\n    result[9] = this8 * m1 + this9 * m5 + this10 * m9 + this11 * m13;\n    result[10] = this8 * m2 + this9 * m6 + this10 * m10 + this11 * m14;\n    result[11] = this8 * m3 + this9 * m7 + this10 * m11 + this11 * m15;\n    result[12] = this12 * m0 + this13 * m4 + this14 * m8 + this15 * m12;\n    result[13] = this12 * m1 + this13 * m5 + this14 * m9 + this15 * m13;\n    result[14] = this12 * m2 + this13 * m6 + this14 * m10 + this15 * m14;\n    result[15] = this12 * m3 + this13 * m7 + this14 * m11 + this15 * m15;\n    return new Matrix4x4(result);\n  }\n\n  /**\n   * Clone\n   */\n  clone() {\n    return new Matrix4x4([...this.elements]);\n  }\n\n  /**\n   * Right multiply the matrix by a Vector3 (interpreted as 3 row, 1 column)\n   * (result = M*v)\n   * Fourth element is taken as 1\n   * @param v\n   */\n  rightMultiply1x3Vector(v: Vector3) {\n    const v0 = v._x;\n    const v1 = v._y;\n    const v2 = v._z;\n    const v3 = 1;\n    let x = v0 * this.elements[0] + v1 * this.elements[1] + v2 * this.elements[2] + v3 * this.elements[3];\n    let y = v0 * this.elements[4] + v1 * this.elements[5] + v2 * this.elements[6] + v3 * this.elements[7];\n    let z = v0 * this.elements[8] + v1 * this.elements[9] + v2 * this.elements[10] + v3 * this.elements[11];\n    const w = v0 * this.elements[12] + v1 * this.elements[13] + v2 * this.elements[14] + v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      const invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector3(x, y, z);\n  }\n\n  /**\n   * Multiply a Vector3 (interpreted as 3 column, 1 row) by this matrix\n   * (result = v*M)\n   * Fourth element is taken as 1\n   * @param v\n   */\n  leftMultiply1x3Vector(v: Vector3) {\n    const v0 = v._x;\n    const v1 = v._y;\n    const v2 = v._z;\n    const v3 = 1;\n    let x = v0 * this.elements[0] + v1 * this.elements[4] + v2 * this.elements[8] + v3 * this.elements[12];\n    let y = v0 * this.elements[1] + v1 * this.elements[5] + v2 * this.elements[9] + v3 * this.elements[13];\n    let z = v0 * this.elements[2] + v1 * this.elements[6] + v2 * this.elements[10] + v3 * this.elements[14];\n    const w = v0 * this.elements[3] + v1 * this.elements[7] + v2 * this.elements[11] + v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      const invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector3(x, y, z);\n  }\n\n  /**\n   * Right multiply the matrix by a Vector2 (interpreted as 2 row, 1 column)\n   * (result = M*v)\n   * Fourth element is taken as 1\n   * @param v\n   */\n  rightMultiply1x2Vector(v: Vector2) {\n    const v0 = v.x;\n    const v1 = v.y;\n    const v2 = 0;\n    const v3 = 1;\n    let x = v0 * this.elements[0] + v1 * this.elements[1] + v2 * this.elements[2] + v3 * this.elements[3];\n    let y = v0 * this.elements[4] + v1 * this.elements[5] + v2 * this.elements[6] + v3 * this.elements[7];\n    let z = v0 * this.elements[8] + v1 * this.elements[9] + v2 * this.elements[10] + v3 * this.elements[11];\n    const w = v0 * this.elements[12] + v1 * this.elements[13] + v2 * this.elements[14] + v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      const invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector2(x, y);\n  }\n\n  /**\n   * Multiply a Vector2 (interpreted as 2 column, 1 row) by this matrix\n   * (result = v*M)\n   * Fourth element is taken as 1\n   * @param v\n   */\n  leftMultiply1x2Vector(v: Vector2) {\n    const v0 = v.x;\n    const v1 = v.y;\n    const v2 = 0;\n    const v3 = 1;\n    let x = v0 * this.elements[0] + v1 * this.elements[4] + v2 * this.elements[8] + v3 * this.elements[12];\n    let y = v0 * this.elements[1] + v1 * this.elements[5] + v2 * this.elements[9] + v3 * this.elements[13];\n    let z = v0 * this.elements[2] + v1 * this.elements[6] + v2 * this.elements[10] + v3 * this.elements[14];\n    const w = v0 * this.elements[3] + v1 * this.elements[7] + v2 * this.elements[11] + v3 * this.elements[15];\n    // scale such that fourth element becomes 1:\n    if (w !== 1) {\n      const invw = 1.0 / w;\n      x *= invw;\n      y *= invw;\n      z *= invw;\n    }\n    return new Vector2(x, y);\n  }\n\n  /**\n   * Determine whether this matrix is a mirroring transformation\n   */\n  isMirroring() {\n    const u = new Vector3(this.elements[0], this.elements[4], this.elements[8]);\n    const v = new Vector3(this.elements[1], this.elements[5], this.elements[9]);\n    const w = new Vector3(this.elements[2], this.elements[6], this.elements[10]);\n\n    // for a true orthogonal, non-mirrored base, u.cross(v) == w\n    // If they have an opposite direction then we are mirroring\n    const mirrorvalue = u.cross(v).dot(w);\n    const ismirror = (mirrorvalue < 0);\n    return ismirror;\n  }\n}\n\n","import {Line2D, Line3D, Matrix4x4, Plane, TransformationMethods, TVector3Universal, Vector2, Vector3} from '.';\n\n/**\n * Reprojects points on a 3D plane onto a 2D plane\n * or from a 2D plane back onto the 3D plane\n * @param  {Plane} plane\n * @param  {Vector3D|Vector2D} rightvector\n *\n * @class OrthoNormalBasis\n */\nexport class OrthoNormalBasis extends TransformationMethods {\n  v: Vector3;\n  u: Vector3;\n  plane: Plane;\n  planeorigin: Vector3;\n\n  /**\n   * Get an orthonormal basis for the standard XYZ planes.\n   * Parameters: the names of two 3D axes. The 2d x axis will map to the first given 3D axis, the 2d y\n   * axis will map to the second.\n   *\n   * Prepend the axis with a \"-\" to invert the direction of this axis.\n   * For example: OrthoNormalBasis.GetCartesian(\"-Y\",\"Z\")\n   * will return an orthonormal basis where the 2d X axis maps to the 3D inverted Y axis, and\n   * the 2d Y axis maps to the 3D Z axis.\n   * @param xaxisid\n   * @param yaxisid\n   * @constructor\n   */\n  static GetCartesian(xaxisid: string, yaxisid: string) {\n    const axisid = `${xaxisid}/${yaxisid}`;\n    let planenormal;\n    let rightvector;\n    if (axisid === 'X/Y') {\n      planenormal = [0, 0, 1];\n      rightvector = [1, 0, 0];\n    } else if (axisid === 'Y/-X') {\n      planenormal = [0, 0, 1];\n      rightvector = [0, 1, 0];\n    } else if (axisid === '-X/-Y') {\n      planenormal = [0, 0, 1];\n      rightvector = [-1, 0, 0];\n    } else if (axisid === '-Y/X') {\n      planenormal = [0, 0, 1];\n      rightvector = [0, -1, 0];\n    } else if (axisid === '-X/Y') {\n      planenormal = [0, 0, -1];\n      rightvector = [-1, 0, 0];\n    } else if (axisid === '-Y/-X') {\n      planenormal = [0, 0, -1];\n      rightvector = [0, -1, 0];\n    } else if (axisid === 'X/-Y') {\n      planenormal = [0, 0, -1];\n      rightvector = [1, 0, 0];\n    } else if (axisid === 'Y/X') {\n      planenormal = [0, 0, -1];\n      rightvector = [0, 1, 0];\n    } else if (axisid === 'X/Z') {\n      planenormal = [0, -1, 0];\n      rightvector = [1, 0, 0];\n    } else if (axisid === 'Z/-X') {\n      planenormal = [0, -1, 0];\n      rightvector = [0, 0, 1];\n    } else if (axisid === '-X/-Z') {\n      planenormal = [0, -1, 0];\n      rightvector = [-1, 0, 0];\n    } else if (axisid === '-Z/X') {\n      planenormal = [0, -1, 0];\n      rightvector = [0, 0, -1];\n    } else if (axisid === '-X/Z') {\n      planenormal = [0, 1, 0];\n      rightvector = [-1, 0, 0];\n    } else if (axisid === '-Z/-X') {\n      planenormal = [0, 1, 0];\n      rightvector = [0, 0, -1];\n    } else if (axisid === 'X/-Z') {\n      planenormal = [0, 1, 0];\n      rightvector = [1, 0, 0];\n    } else if (axisid === 'Z/X') {\n      planenormal = [0, 1, 0];\n      rightvector = [0, 0, 1];\n    } else if (axisid === 'Y/Z') {\n      planenormal = [1, 0, 0];\n      rightvector = [0, 1, 0];\n    } else if (axisid === 'Z/-Y') {\n      planenormal = [1, 0, 0];\n      rightvector = [0, 0, 1];\n    } else if (axisid === '-Y/-Z') {\n      planenormal = [1, 0, 0];\n      rightvector = [0, -1, 0];\n    } else if (axisid === '-Z/Y') {\n      planenormal = [1, 0, 0];\n      rightvector = [0, 0, -1];\n    } else if (axisid === '-Y/Z') {\n      planenormal = [-1, 0, 0];\n      rightvector = [0, -1, 0];\n    } else if (axisid === '-Z/-Y') {\n      planenormal = [-1, 0, 0];\n      rightvector = [0, 0, -1];\n    } else if (axisid === 'Y/-Z') {\n      planenormal = [-1, 0, 0];\n      rightvector = [0, 1, 0];\n    } else if (axisid === 'Z/Y') {\n      planenormal = [-1, 0, 0];\n      rightvector = [0, 0, 1];\n    } else {\n      throw new Error('OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.');\n    }\n    return new OrthoNormalBasis(new Plane(new Vector3(planenormal), 0), new Vector3(rightvector));\n  };\n\n  /*\n  // test code for OrthoNormalBasis.GetCartesian()\n  OrthoNormalBasis.GetCartesian_Test=function() {\n    let axisnames=[\"X\",\"Y\",\"Z\",\"-X\",\"-Y\",\"-Z\"];\n    let axisvectors=[[1,0,0], [0,1,0], [0,0,1], [-1,0,0], [0,-1,0], [0,0,-1]];\n    for(let axis1=0; axis1 < 3; axis1++) {\n      for(let axis1inverted=0; axis1inverted < 2; axis1inverted++) {\n        let axis1name=axisnames[axis1+3*axis1inverted];\n        let axis1vector=axisvectors[axis1+3*axis1inverted];\n        for(let axis2=0; axis2 < 3; axis2++) {\n          if(axis2 != axis1) {\n            for(let axis2inverted=0; axis2inverted < 2; axis2inverted++) {\n              let axis2name=axisnames[axis2+3*axis2inverted];\n              let axis2vector=axisvectors[axis2+3*axis2inverted];\n              let orthobasis=OrthoNormalBasis.GetCartesian(axis1name, axis2name);\n              let test1=orthobasis.to3D(new Vector2D([1,0]));\n              let test2=orthobasis.to3D(new Vector2D([0,1]));\n              let expected1=new Vector3D(axis1vector);\n              let expected2=new Vector3D(axis2vector);\n              let d1=test1.distanceTo(expected1);\n              let d2=test2.distanceTo(expected2);\n              if( (d1 > 0.01) || (d2 > 0.01) ) {\n                throw new Error(\"Wrong!\");\n    }}}}}}\n    throw new Error(\"OK\");\n  };\n  */\n\n  /**\n   * The z=0 plane, with the 3D x and y vectors mapped to the 2D x and y vector\n   * @constructor\n   */\n  static Z0Plane() {\n    const plane = new Plane(new Vector3([0, 0, 1]), 0);\n    return new OrthoNormalBasis(plane, new Vector3([1, 0, 0]));\n  };\n\n  /**\n   * OrthoNormalBasis Constructor\n   */\n  constructor(plane: Plane, _rightvector?: TVector3Universal) {\n    super();\n    const rightvector = typeof _rightvector !== 'undefined' ? new Vector3(_rightvector) : plane.normal.randomNonParallelVector();\n\n    this.v = plane.normal.cross(rightvector).unit();\n    this.u = this.v.cross(plane.normal);\n    this.plane = plane;\n    this.planeorigin = plane.normal.times(plane.w);\n  }\n\n  /**\n   * Get projection matrix\n   */\n  getProjectionMatrix() {\n    return new Matrix4x4([\n      this.u.x, this.v.x, this.plane.normal.x, 0,\n      this.u.y, this.v.y, this.plane.normal.y, 0,\n      this.u.z, this.v.z, this.plane.normal.z, 0,\n      0, 0, -this.plane.w, 1,\n    ]);\n  }\n\n  /**\n   * Get inverse projection matrix\n   */\n  getInverseProjectionMatrix() {\n    const p = this.plane.normal.times(this.plane.w);\n    return new Matrix4x4([\n      this.u.x, this.u.y, this.u.z, 0,\n      this.v.x, this.v.y, this.v.z, 0,\n      this.plane.normal.x, this.plane.normal.y, this.plane.normal.z, 0,\n      p.x, p.y, p.z, 1,\n    ]);\n  }\n\n  /**\n   * to Vector2\n   * @param vec3\n   */\n  to2D(vec3: Vector3) {\n    return new Vector2(vec3.dot(this.u), vec3.dot(this.v));\n  }\n\n  /**\n   * to Vector3\n   * @param vec2\n   */\n  to3D(vec2: Vector2) {\n    return this.planeorigin.plus(this.u.times(vec2.x)).plus(this.v.times(vec2.y));\n  }\n\n  /**\n   * Line 3D to 2D\n   * @param line3d\n   */\n  line3Dto2D(line3d: Line3D) {\n    const a = line3d.point;\n    const b = line3d.direction.plus(a);\n    const a2d = this.to2D(a);\n    const b2d = this.to2D(b);\n    return Line2D.fromPoints(a2d, b2d);\n  }\n\n  /**\n   * Line 2D to 3D\n   * @param line2d\n   */\n  line2Dto3D(line2d: Line2D) {\n    const a = line2d.origin();\n    const b = line2d.direction().plus(a);\n    const a3d = this.to3D(a);\n    const b3d = this.to3D(b);\n    return Line3D.fromPoints(a3d, b3d);\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): OrthoNormalBasis {\n    // todo: this may not work properly in case of mirroring\n    const newplane = this.plane.transform(matrix4x4);\n    const rightpointTransformed = this.u.transform(matrix4x4);\n    const originTransformed = new Vector3(0, 0, 0).transform(matrix4x4);\n    const newrighthandvector = rightpointTransformed.minus(originTransformed);\n    const newbasis = new OrthoNormalBasis(newplane, newrighthandvector);\n    return newbasis;\n  }\n}\n\n","import {angleEPS, defaultResolution2D, EPS} from '@core/constants';\nimport {parseOptionAs2DVector, parseOptionAsBool, parseOptionAsFloat, parseOptionAsInt} from '@api/optionParsers';\nimport {CAG} from '@core/CAG';\nimport {Matrix4x4, Side, TransformationMethods, TVector2Universal, Vector2, Vertex2} from '.';\n\nexport interface IPath2DArcOptions {\n  center: any;\n  radius: number;\n  startangle: number;\n  endangle: number;\n  resolution: number;\n  maketangent: boolean;\n}\n\n/**\n * @class Path2D\n *\n * Represents a series of points, connected by infinitely thin lines.\n * A path can be open or closed, i.e. additional line between first and last points.\n * The difference between Path2D and CAG is that a path is a 'thin' line, whereas a CAG is an enclosed area.\n *\n * @constructor\n * @param {Vector2[]} [points=[]] - list of points\n * @param {boolean} [closed=false] - closer of path\n *\n * @example\n * new CSG.Path2D()\n * new CSG.Path2D([[10,10], [-10,10], [-10,-10], [10,-10]], true) // closed\n */\nexport class Path2D extends TransformationMethods {\n  lastBezierControlPoint?: Vector2;\n\n  points: Vector2[] = [];\n  closed = false;\n\n  /**\n   * Construct an arc.\n   * @param {Object} [options] - options for construction\n   * @param {Vector2} [options.center=[0,0]] - center of circle\n   * @param {Number} [options.radius=1] - radius of circle\n   * @param {Number} [options.startangle=0] - starting angle of the arc, in degrees\n   * @param {Number} [options.endangle=360] - ending angle of the arc, in degrees\n   * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n   * @param {Boolean} [options.maketangent=false] - adds line segments at both ends of the arc to ensure that the gradients at the edges are tangent\n   * @returns {Path2D} new Path2D object (not closed)\n   *\n   * @example\n   * let path = CSG.Path2D.arc({\n   *   center: [5, 5],\n   *   radius: 10,\n   *   startangle: 90,\n   *   endangle: 180,\n   *   resolution: 36,\n   *   maketangent: true\n   * });\n   */\n  static arc(options: Partial<IPath2DArcOptions> = {}) {\n    const center = parseOptionAs2DVector(options, 'center', 0);\n    const radius = parseOptionAsFloat(options, 'radius', 1);\n    const startangle = parseOptionAsFloat(options, 'startangle', 0);\n    let endangle = parseOptionAsFloat(options, 'endangle', 360);\n    const resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n    const maketangent = parseOptionAsBool(options, 'maketangent', false);\n    // no need to make multiple turns:\n    while (endangle - startangle >= 720) {\n      endangle -= 360;\n    }\n    while (endangle - startangle <= -720) {\n      endangle += 360;\n    }\n    const points = [];\n    let point;\n    const absangledif = Math.abs(endangle - startangle);\n    if (absangledif < angleEPS) {\n      point = Vector2.fromAngle(startangle / 180.0 * Math.PI).times(radius);\n      points.push(point.plus(center));\n    } else {\n      const numsteps = Math.floor(resolution * absangledif / 360) + 1;\n      let edgestepsize = numsteps * 0.5 / absangledif; // step size for half a degree\n      if (edgestepsize > 0.25) edgestepsize = 0.25;\n      const numstepsMod = maketangent ? (numsteps + 2) : numsteps;\n      for (let i = 0; i <= numstepsMod; i++) {\n        let step = i;\n        if (maketangent) {\n          step = (i - 1) * (numsteps - 2 * edgestepsize) / numsteps + edgestepsize;\n          if (step < 0) step = 0;\n          if (step > numsteps) step = numsteps;\n        }\n        const angle = startangle + step * (endangle - startangle) / numsteps;\n        point = Vector2.fromAngle(angle / 180.0 * Math.PI).times(radius);\n        points.push(point.plus(center));\n      }\n    }\n    return new Path2D(points, false);\n  }\n\n  /**\n   * Path2D Constructor\n   * @param points\n   * @param closed\n   */\n  constructor(points?: number[][] | Vector2[], closed: boolean = false) {\n    super();\n\n    closed = !!closed;\n    points = points || [];\n    // re-parse the points into Vector2\n    // and remove any duplicate points\n    let prevpoint: Vector2 = null!;\n    if (closed && (points.length > 0)) {\n      prevpoint = new Vector2(points[points.length - 1]);\n    }\n    const newpoints: Vector2[] = [];\n    points.forEach((point: number[] | Vector2) => {\n      const vPoint = new Vector2(point);\n      let skip = false;\n      if (prevpoint !== null) {\n        const distance = vPoint.distanceTo(prevpoint);\n        skip = distance < EPS;\n      }\n      if (!skip) newpoints.push(vPoint);\n      prevpoint = vPoint;\n    });\n    this.points = newpoints;\n    this.closed = closed;\n  }\n\n  /**\n   * Create a new Path2D by merging two Path2D\n   * @param otherpath\n   */\n  concat(otherpath: Path2D) {\n    if (this.closed || otherpath.closed) {\n      throw new Error('Paths must not be closed');\n    }\n    const newpoints = this.points.concat(otherpath.points);\n    return new Path2D(newpoints);\n  }\n\n  /**\n   * Get the points that make up the path.\n   * note that this is current internal list of points, not an immutable copy.\n   * @returns {Vector2[]} array of points the make up the path\n   */\n  getPoints() {\n    return this.points;\n  }\n\n  /**\n   * Append an point to the end of the path.\n   * @param {Vector2} point - point to append\n   * @returns {Path2D} new Path2D object (not closed)\n   */\n  appendPoint(point: number[] | Vector2) {\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    point = new Vector2(point); // cast to Vector2\n    const newpoints = this.points.concat([point]);\n    return new Path2D(newpoints);\n  }\n\n  /**\n   * Append a list of points to the end of the path.\n   * @param {Vector2[]} points - points to append\n   * @returns {Path2D} new Path2D object (not closed)\n   */\n  appendPoints(points: number[][] | Vector2[]) {\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    const newpoints = this.points;\n    points.forEach((point: number[] | Vector2) => {\n      newpoints.push(new Vector2(point)); // cast to Vector2\n    });\n    return new Path2D(newpoints);\n  }\n\n  /**\n   * Close Path2D\n   */\n  close() {\n    return new Path2D(this.points, true);\n  }\n\n  /**\n   * Determine if the path is a closed or not.\n   * @returns {Boolean} true when the path is closed, otherwise false\n   */\n  isClosed() {\n    return this.closed;\n  }\n\n  /**\n   * Determine the overall clockwise or anti-clockwise turn of a path.\n   * See: http://mathworld.wolfram.com/PolygonArea.html\n   * @returns {String} One of ['clockwise', 'counter-clockwise', 'straight'].\n   */\n  getTurn() {\n    const points = this.points;\n    let twiceArea = 0;\n    let last = points.length - 1;\n    for (let current = 0; current < points.length; last = current++) {\n      twiceArea += points[last].x * points[current].y - points[last].y * points[current].x;\n    }\n    if (twiceArea > 0) {\n      return 'clockwise';\n    } else if (twiceArea < 0) {\n      return 'counter-clockwise';\n    } else {\n      return 'straight';\n    }\n  }\n\n  /**\n   * Extrude the path by following it with a rectangle (upright, perpendicular to the path direction)\n   * Returns a CSG solid\n   * @param width - width of the extrusion, in the z=0 plane\n   * @param height - height of the extrusion in the z direction\n   * @param resolution - number of segments per 360 degrees for the curve in a corner\n   */\n  rectangularExtrude(width: number, height: number, resolution: number) {\n    const cag = this.expandToCAG(width / 2, resolution);\n    const result = cag.extrude({\n      offset: [0, 0, height],\n    });\n    return result;\n  }\n\n  /**\n   * Expand the path to a CAG\n   * This traces the path with a circle with radius pathradius\n   * @param pathradius\n   * @param resolution\n   */\n  expandToCAG(pathradius: number, resolution: number) {\n    const sides = [];\n    const numpoints = this.points.length;\n    let startindex = 0;\n    if (this.closed && (numpoints > 2)) startindex = -1;\n    let prevvertex;\n    for (let i = startindex; i < numpoints; i++) {\n      let pointindex = i;\n      if (pointindex < 0) pointindex = numpoints - 1;\n      const point = this.points[pointindex];\n      const vertex = new Vertex2(point);\n      if (prevvertex && i > startindex) {\n        const side = new Side(prevvertex, vertex);\n        sides.push(side);\n      }\n      prevvertex = vertex;\n    }\n    const shellcag = CAG.fromSides(sides);\n    const expanded = shellcag.expandedShell(pathradius, resolution);\n    return expanded;\n  }\n\n  /**\n   * Inner to CAG\n   */\n  innerToCAG() {\n    if (!this.closed) throw new Error('The path should be closed!');\n    return CAG.fromPoints(this.points);\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Path2D {\n    const newpoints = this.points.map((point) => point.multiply4x4(matrix4x4));\n    return new Path2D(newpoints, this.closed);\n  }\n\n  /**\n   * Append a Bezier curve to the end of the path, using the control points to transition the curve through start and end points.\n   * <br>\n   * The Bzier curve starts at the last point in the path,\n   * and ends at the last given control point. Other control points are intermediate control points.\n   * <br>\n   * The first control point may be null to ensure a smooth transition occurs. In this case,\n   * the second to last control point of the path is mirrored into the control points of the Bezier curve.\n   * In other words, the trailing gradient of the path matches the new gradient of the curve.\n   * @param {Vector2[]} controlpoints - list of control points\n   * @param {Object} [options] - options for construction\n   * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n   * @returns {Path2D} new Path2D object (not closed)\n   *\n   * @example\n   * let p5 = new CSG.Path2D([[10,-20]],false);\n   * p5 = p5.appendBezier([[10,-10],[25,-10],[25,-20]]);\n   * p5 = p5.appendBezier([[25,-30],[40,-30],[40,-20]]);\n   */\n  appendBezier(controlpoints: number[][] | Vector2[], options?: any) {\n    if (arguments.length < 2) {\n      options = {};\n    }\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    if (!(controlpoints instanceof Array)) {\n      throw new Error('appendBezier: should pass an array of control points');\n    }\n    if (controlpoints.length < 1) {\n      throw new Error('appendBezier: need at least 1 control point');\n    }\n    if (this.points.length < 1) {\n      throw new Error('appendBezier: path must already contain a point (the endpoint of the path is used as the starting point for the bezier curve)');\n    }\n    let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n    if (resolution < 4) resolution = 4;\n    const factorials = [];\n    const controlpointsParsed: Vector2[] = [];\n    controlpointsParsed.push(this.points[this.points.length - 1]); // start at the previous end point\n    for (let i = 0; i < controlpoints.length; ++i) {\n      let p = controlpoints[i];\n      if (p === null) {\n        // we can pass null as the first control point. In that case a smooth gradient is ensured:\n        if (i !== 0) {\n          throw new Error('appendBezier: null can only be passed as the first control point');\n        }\n        if (controlpoints.length < 2) {\n          throw new Error('appendBezier: null can only be passed if there is at least one more control point');\n        }\n        let lastBezierControlPoint;\n        if (this.lastBezierControlPoint) {\n          lastBezierControlPoint = this.lastBezierControlPoint;\n        } else {\n          if (this.points.length < 2) {\n            throw new Error('appendBezier: null is passed as a control point but this requires a previous bezier curve or at least two points in the existing path');\n          }\n          lastBezierControlPoint = this.points[this.points.length - 2];\n        }\n        // mirror the last bezier control point:\n        p = this.points[this.points.length - 1].times(2).minus(lastBezierControlPoint);\n      } else {\n        p = new Vector2(p); // cast to Vector2\n      }\n      controlpointsParsed.push(p);\n    }\n    const bezierOrder = controlpointsParsed.length - 1;\n    let fact = 1;\n    for (let i = 0; i <= bezierOrder; ++i) {\n      if (i > 0) fact *= i;\n      factorials.push(fact);\n    }\n    const binomials: number[] = [];\n    for (let i = 0; i <= bezierOrder; ++i) {\n      const binomial = factorials[bezierOrder] / (factorials[i] * factorials[bezierOrder - i]);\n      binomials.push(binomial);\n    }\n    const getPointForT = (t: number) => {\n      let tK = 1; // = pow(t,k)\n      let oneMinusTNMinusK = Math.pow(1 - t, bezierOrder); // = pow( 1-t, bezierOrder - k)\n      const inv1MinusT = (t !== 1) ? (1 / (1 - t)) : 1;\n      let point = new Vector2(0, 0);\n      for (let k = 0; k <= bezierOrder; ++k) {\n        if (k === bezierOrder) oneMinusTNMinusK = 1;\n        const bernsteinCoefficient = binomials[k] * tK * oneMinusTNMinusK;\n        point = point.plus(controlpointsParsed[k].times(bernsteinCoefficient));\n        tK *= t;\n        oneMinusTNMinusK *= inv1MinusT;\n      }\n      return point;\n    };\n    let newpoints = [];\n    const newpointsT: number[] = [];\n    const numsteps = bezierOrder + 1;\n    for (let i = 0; i < numsteps; ++i) {\n      const t = i / (numsteps - 1);\n      const point = getPointForT(t);\n      newpoints.push(point);\n      newpointsT.push(t);\n    }\n    // subdivide each segment until the angle at each vertex becomes small enough:\n    let subdivideBase = 1;\n    const maxangle = Math.PI * 2 / resolution; // segments may have differ no more in angle than this\n    const maxsinangle = Math.sin(maxangle);\n    while (subdivideBase < newpoints.length - 1) {\n      const dir1 = newpoints[subdivideBase].minus(newpoints[subdivideBase - 1]).unit();\n      const dir2 = newpoints[subdivideBase + 1].minus(newpoints[subdivideBase]).unit();\n      const sinangle = dir1.cross(dir2); // this is the sine of the angle\n      if (Math.abs(sinangle) > maxsinangle) {\n        // angle is too big, we need to subdivide\n        const t0 = newpointsT[subdivideBase - 1];\n        const t1 = newpointsT[subdivideBase + 1];\n        const t0New = t0 + (t1 - t0) * 1 / 3;\n        const t1New = t0 + (t1 - t0) * 2 / 3;\n        const point0New = getPointForT(t0New);\n        const point1New = getPointForT(t1New);\n        // remove the point at subdivideBase and replace with 2 new points:\n        newpoints.splice(subdivideBase, 1, point0New, point1New);\n        newpointsT.splice(subdivideBase, 1, t0New, t1New);\n        // re - evaluate the angles, starting at the previous junction since it has changed:\n        subdivideBase--;\n        if (subdivideBase < 1) subdivideBase = 1;\n      } else {\n        ++subdivideBase;\n      }\n    }\n    // append to the previous points, but skip the first new point because it is identical to the last point:\n    newpoints = this.points.concat(newpoints.slice(1));\n    const result = new Path2D(newpoints);\n    result.lastBezierControlPoint = controlpointsParsed[controlpointsParsed.length - 2];\n    return result;\n  }\n\n  /**\n   * Append an arc to the end of the path.\n   * This implementation follows the SVG arc specs. For the details see\n   * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n   * @param {Vector2} endpoint - end point of arc\n   * @param {Object} [options] - options for construction\n   * @param {Number} [options.radius=0] - radius of arc (X and Y), see also xradius and yradius\n   * @param {Number} [options.xradius=0] - X radius of arc, see also radius\n   * @param {Number} [options.yradius=0] - Y radius of arc, see also radius\n   * @param {Number} [options.xaxisrotation=0] -  rotation (in degrees) of the X axis of the arc with respect to the X axis of the coordinate system\n   * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n   * @param {Boolean} [options.clockwise=false] - draw an arc clockwise with respect to the center point\n   * @param {Boolean} [options.large=false] - draw an arc longer than 180 degrees\n   * @returns {Path2D} new Path2D object (not closed)\n   *\n   * @example\n   * let p1 = new CSG.Path2D([[27.5,-22.96875]],false);\n   * p1 = p1.appendPoint([27.5,-3.28125]);\n   * p1 = p1.appendArc([12.5,-22.96875],{xradius: 15,yradius: -19.6875,xaxisrotation: 0,clockwise: false,large: false});\n   * p1 = p1.close();\n   */\n  appendArc(inEndpoint: TVector2Universal, options: any) {\n    const decimals = 100000;\n    if (arguments.length < 2) {\n      options = {};\n    }\n    if (this.closed) {\n      throw new Error('Path must not be closed');\n    }\n    if (this.points.length < 1) {\n      throw new Error('appendArc: path must already contain a point (the endpoint of the path is used as the starting point for the arc)');\n    }\n    let resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n    if (resolution < 4) resolution = 4;\n    let xradius;\n    let yradius;\n    if (('xradius' in options) || ('yradius' in options)) {\n      if ('radius' in options) {\n        throw new Error('Should either give an xradius and yradius parameter, or a radius parameter');\n      }\n      xradius = parseOptionAsFloat(options, 'xradius', 0);\n      yradius = parseOptionAsFloat(options, 'yradius', 0);\n    } else {\n      xradius = parseOptionAsFloat(options, 'radius', 0);\n      yradius = xradius;\n    }\n    const xaxisrotation = parseOptionAsFloat(options, 'xaxisrotation', 0);\n    const clockwise = parseOptionAsBool(options, 'clockwise', false);\n    const largearc = parseOptionAsBool(options, 'large', false);\n    const startpoint = this.points[this.points.length - 1];\n    let endpoint = new Vector2(inEndpoint);\n    // round to precision in order to have determinate calculations\n    xradius = Math.round(xradius * decimals) / decimals;\n    yradius = Math.round(yradius * decimals) / decimals;\n    endpoint = new Vector2(Math.round(endpoint.x * decimals) / decimals, Math.round(endpoint.y * decimals) / decimals);\n\n    const sweepFlag = !clockwise;\n    let newpoints = [];\n    if ((xradius === 0) || (yradius === 0)) {\n      // http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes:\n      // If rx = 0 or ry = 0, then treat this as a straight line from (x1, y1) to (x2, y2) and stop\n      newpoints.push(endpoint);\n    } else {\n      xradius = Math.abs(xradius);\n      yradius = Math.abs(yradius);\n\n      // see http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes :\n      const phi = xaxisrotation * Math.PI / 180.0;\n      const cosphi = Math.cos(phi);\n      const sinphi = Math.sin(phi);\n      const minushalfdistance = startpoint.minus(endpoint).times(0.5);\n      // F.6.5.1:\n      // round to precision in order to have determinate calculations\n      const x = Math.round((cosphi * minushalfdistance.x + sinphi * minushalfdistance.y) * decimals) / decimals;\n      const y = Math.round((-sinphi * minushalfdistance.x + cosphi * minushalfdistance.y) * decimals) / decimals;\n      const startTranslated = new Vector2(x, y);\n      // F.6.6.2:\n      const biglambda = (startTranslated.x * startTranslated.x) / (xradius * xradius) + (startTranslated.y * startTranslated.y) / (yradius * yradius);\n      if (biglambda > 1.0) {\n        // F.6.6.3:\n        const sqrtbiglambda = Math.sqrt(biglambda);\n        xradius *= sqrtbiglambda;\n        yradius *= sqrtbiglambda;\n        // round to precision in order to have determinate calculations\n        xradius = Math.round(xradius * decimals) / decimals;\n        yradius = Math.round(yradius * decimals) / decimals;\n      }\n      // F.6.5.2:\n      let multiplier1 = Math.sqrt((xradius * xradius * yradius * yradius - xradius * xradius * startTranslated.y * startTranslated.y - yradius * yradius * startTranslated.x * startTranslated.x) / (xradius * xradius * startTranslated.y * startTranslated.y + yradius * yradius * startTranslated.x * startTranslated.x));\n      if (sweepFlag === largearc) multiplier1 = -multiplier1;\n      const centerTranslated = new Vector2(xradius * startTranslated.y / yradius, -yradius * startTranslated.x / xradius).times(multiplier1);\n      // F.6.5.3:\n      const center = new Vector2(cosphi * centerTranslated.x - sinphi * centerTranslated.y, sinphi * centerTranslated.x + cosphi * centerTranslated.y).plus((startpoint.plus(endpoint)).times(0.5));\n      // F.6.5.5:\n      const vec1 = new Vector2((startTranslated.x - centerTranslated.x) / xradius, (startTranslated.y - centerTranslated.y) / yradius);\n      const vec2 = new Vector2((-startTranslated.x - centerTranslated.x) / xradius, (-startTranslated.y - centerTranslated.y) / yradius);\n      const theta1 = vec1.angleRadians();\n      const theta2 = vec2.angleRadians();\n      let deltatheta = theta2 - theta1;\n      deltatheta = deltatheta % (2 * Math.PI);\n      if ((!sweepFlag) && (deltatheta > 0)) {\n        deltatheta -= 2 * Math.PI;\n      } else if ((sweepFlag) && (deltatheta < 0)) {\n        deltatheta += 2 * Math.PI;\n      }\n\n      // Ok, we have the center point and angle range (from theta1, deltatheta radians) so we can create the ellipse\n      let numsteps = Math.ceil(Math.abs(deltatheta) / (2 * Math.PI) * resolution) + 1;\n      if (numsteps < 1) numsteps = 1;\n      for (let step = 1; step <= numsteps; step++) {\n        const theta = theta1 + step / numsteps * deltatheta;\n        const costheta = Math.cos(theta);\n        const sintheta = Math.sin(theta);\n        // F.6.3.1:\n        const point = new Vector2(cosphi * xradius * costheta - sinphi * yradius * sintheta, sinphi * xradius * costheta + cosphi * yradius * sintheta).plus(center);\n        newpoints.push(point);\n      }\n    }\n    newpoints = this.points.concat(newpoints);\n    const result = new Path2D(newpoints);\n    return result;\n  }\n}\n","import {EPS, getTag} from '@core/constants';\nimport {Line3D, Matrix4x4, TransformationMethods, TVector3Universal, Vector3} from '.';\n\n/**\n * @class Plane\n * Represents a plane in 3D space.\n */\nexport class Plane extends TransformationMethods {\n  normal: Vector3;\n  w: number;\n  tag?: number;\n\n  /**\n   * create from an untyped object with identical property names:\n   * @param obj\n   */\n  static fromObject<T extends Plane | { normal: TVector3Universal, w?: number | string }>(obj: T) {\n    const normal = new Vector3(obj.normal);\n    const w = (typeof obj.w === 'string' ? parseFloat(obj.w) : obj.w) || 0;\n    return new Plane(normal, w);\n  };\n\n  /**\n   * make from 3D Vectors\n   * @param a\n   * @param b\n   * @param c\n   */\n  static fromVector3Ds(a: Vector3, b: Vector3, c: Vector3) {\n    const n = b.minus(a).cross(c.minus(a)).unit();\n    return new Plane(n, n.dot(a));\n  };\n\n  /**\n   * like fromVector3Ds, but allow the vectors to be on one point or one line\n   * in such a case a random plane through the given points is constructed\n   * @param a\n   * @param b\n   * @param c\n   */\n  static anyPlaneFromVector3Ds(a: Vector3, b: Vector3, c: Vector3) {\n    let v1 = b.minus(a);\n    let v2 = c.minus(a);\n    if (v1.length() < EPS) {\n      v1 = v2.randomNonParallelVector();\n    }\n    if (v2.length() < EPS) {\n      v2 = v1.randomNonParallelVector();\n    }\n    let normal = v1.cross(v2);\n    if (normal.length() < EPS) {\n      // this would mean that v1 == v2.negated()\n      v2 = v1.randomNonParallelVector();\n      normal = v1.cross(v2);\n    }\n    normal = normal.unit();\n    return new Plane(normal, normal.dot(a));\n  };\n\n  /**\n   * Make From Points\n   * @param _a\n   * @param _b\n   * @param _c\n   */\n  static fromPoints(_a: TVector3Universal, _b: TVector3Universal, _c: TVector3Universal) {\n    const a = new Vector3(_a);\n    const b = new Vector3(_b);\n    const c = new Vector3(_c);\n    return Plane.fromVector3Ds(a, b, c);\n  };\n\n  /**\n   * Make from normal and point\n   * @param _normal\n   * @param _point\n   */\n  static fromNormalAndPoint(_normal: TVector3Universal, _point: TVector3Universal) {\n    const normal = new Vector3(_normal).unit();\n    const point = new Vector3(_point);\n    const w = point.dot(normal);\n    return new Plane(normal, w);\n  };\n\n  /**\n   * Plane constructor\n   * @param normal\n   * @param w\n   */\n  constructor(normal: Vector3, w: number) {\n    super();\n    this.normal = normal;\n    this.w = w;\n  }\n\n  /**\n   * Get Flipped Plane\n   */\n  flipped() {\n    return new Plane(this.normal.negated(), -this.w);\n  }\n\n  /**\n   * Get Tag\n   */\n  getTag() {\n    let result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  }\n\n  /**\n   * Plane-Plane equals\n   * @param n\n   */\n  equals(n: Plane) {\n    return this.normal.equals(n.normal) && this.w === n.w;\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Plane {\n    const ismirror = matrix4x4.isMirroring();\n    // get two vectors in the plane:\n    const r = this.normal.randomNonParallelVector();\n    const u = this.normal.cross(r);\n    const v = this.normal.cross(u);\n    // get 3 points in the plane:\n    let point1 = this.normal.times(this.w);\n    let point2 = point1.plus(u);\n    let point3 = point1.plus(v);\n    // transform the points:\n    point1 = point1.multiply4x4(matrix4x4);\n    point2 = point2.multiply4x4(matrix4x4);\n    point3 = point3.multiply4x4(matrix4x4);\n    // and create a new plane from the transformed points:\n    let newplane = Plane.fromVector3Ds(point1, point2, point3);\n    if (ismirror) {\n      // the transform is mirroring\n      // We should mirror the plane:\n      newplane = newplane.flipped();\n    }\n    return newplane;\n  }\n\n  /**\n   * robust splitting of a line by a plane\n   * will work even if the line is parallel to the plane\n   * @param p1\n   * @param p2\n   */\n  splitLineBetweenPoints(p1: Vector3, p2: Vector3) {\n    const direction = p2.minus(p1);\n    let labda = (this.w - this.normal.dot(p1)) / this.normal.dot(direction);\n    if (isNaN(labda)) labda = 0;\n    if (labda > 1) labda = 1;\n    if (labda < 0) labda = 0;\n    const result = p1.plus(direction.times(labda));\n    return result;\n  }\n\n  /**\n   * Intersect With Line\n   * returns Vector3D\n   * @param line3d\n   */\n  intersectWithLine(line3d: Line3D) {\n    return line3d.intersectWithPlane(this);\n  }\n\n  /**\n   * intersection of two planes\n   * @param plane\n   */\n  intersectWithPlane(plane: Plane) {\n    return Line3D.fromPlanes(this, plane);\n  }\n\n  /**\n   * Signed Distance To Point\n   * @param point\n   */\n  signedDistanceToPoint(point: Vector3) {\n    return this.normal.dot(point) - this.w;\n  }\n\n  /**\n   * To String\n   */\n  toString() {\n    return '[normal: ' + this.normal.toString() + ', w: ' + this.w + ']';\n  }\n\n  /**\n   * Mirror point\n   * @param point3d\n   */\n  mirrorPoint(point3d: Vector3) {\n    const distance = this.signedDistanceToPoint(point3d);\n    const mirrored = point3d.minus(this.normal.times(distance * 2.0));\n    return mirrored;\n  }\n}\n\n","import {_CSGDEBUG, areaEPS, EPS} from '@core/constants';\nimport {CAG} from '@core/CAG';\nimport {ISolidFromSlices, solidFromSlices} from '@core/utils/solidFromSlices';\nimport {fromPolygons} from '@core/CSGFactories';\nimport {fromPointsNoCheck} from '@core/CAGFactories';\nimport {fromPoints, Matrix4x4, OrthoNormalBasis, Plane, PolygonShared, TransformationMethods, TVector3Universal, Vector2, Vector3, Vertex3} from '.';\n\n/**\n * Class Polygon\n * Represents a convex polygon. The vertices used to initialize a polygon must\n *   be coplanar and form a convex loop. They do not have to be `Vertex`\n *   instances but they must behave similarly (duck typing can be used for\n *   customization).\n * <br>\n * Each convex polygon has a `shared` property, which is shared between all\n *   polygons that are clones of each other or were split from the same polygon.\n *   This can be used to define per-polygon properties (such as surface color).\n * <br>\n * The plane of the polygon is calculated from the vertex coordinates if not provided.\n *   The plane can alternatively be passed as the third argument to avoid calculations.\n *\n * @constructor\n * @param {Vertex[]} vertices - list of vertices\n * @param {Polygon3.Shared} [shared=defaultShared] - shared property to apply\n * @param {Plane} [plane] - plane of the polygon\n *\n * @example\n * const vertices = [\n *   new CSG.Vertex(new CSG.Vector3([0, 0, 0])),\n *   new CSG.Vertex(new CSG.Vector3([0, 10, 0])),\n *   new CSG.Vertex(new CSG.Vector3([0, 10, 10]))\n * ]\n * let observed = new Polygon(vertices)\n */\nexport class Polygon3 extends TransformationMethods {\n  vertices: Vertex3[];\n  shared: PolygonShared;\n  plane: Plane;\n  cachedBoundingBox?: [Vector3, Vector3];\n  cachedBoundingSphere?: [Vector3, number];\n\n  static defaultShared = new PolygonShared(null);\n  static Shared = PolygonShared;\n\n  /**\n   * create from an untyped object with identical property names:\n   * @param obj\n   */\n  static fromObject<T extends Polygon3 | { vertices: Vertex3[], shared?: PolygonShared, plane?: Plane }>(obj: T) {\n    const vertices = obj.vertices.map((v: Vertex3) => {\n      return Vertex3.fromObject(v);\n    });\n    const shared = Polygon3.Shared.fromObject(obj.shared);\n    const plane = obj.plane ? Plane.fromObject(obj.plane) : Plane.fromVector3Ds(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n    return new Polygon3(vertices, shared, plane);\n  }\n\n  /**\n   * Create a polygon from the given points.\n   *\n   * @param {Array[]} points - list of points\n   * @param {Polygon3.Shared} [shared=defaultShared] - shared property to apply\n   * @param {Plane} [plane] - plane of the polygon\n   *\n   * @example\n   * const points = [\n   *   [0,  0, 0],\n   *   [0, 10, 0],\n   *   [0, 10, 10]\n   * ]\n   * let observed = CSG.Polygon3.createFromPoints(points)\n   */\n  static createFromPoints = fromPoints;\n\n  /**\n   * Vertices Convex\n   * @param vertices\n   * @param planenormal\n   */\n  static verticesConvex(vertices: Vertex3[], planenormal: Vector3) {\n    const numvertices = vertices.length;\n    if (numvertices > 2) {\n      let prevprevpos = vertices[numvertices - 2].pos;\n      let prevpos = vertices[numvertices - 1].pos;\n      for (let i = 0; i < numvertices; i++) {\n        const pos = vertices[i].pos;\n        if (!Polygon3.isConvexPoint(prevprevpos, prevpos, pos, planenormal)) {\n          return false;\n        }\n        prevprevpos = prevpos;\n        prevpos = pos;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * calculate whether three points form a convex corner\n   * prevpoint, point, nextpoint: the 3 coordinates (Vector3 instances)\n   * @param prevpoint\n   * @param point\n   * @param nextpoint\n   * @param normal - the normal vector of the plane\n   */\n  static isConvexPoint(prevpoint: Vector3, point: Vector3, nextpoint: Vector3, normal: Vector3) {\n    const crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));\n    const crossdotnormal = crossproduct.dot(normal);\n    return (crossdotnormal >= 0);\n  };\n\n  /**\n   * Is Strictly Convex Point\n   * @param prevpoint\n   * @param point\n   * @param nextpoint\n   * @param normal\n   */\n  static isStrictlyConvexPoint(prevpoint: Vector3, point: Vector3, nextpoint: Vector3, normal: Vector3) {\n    const crossproduct = point.minus(prevpoint).cross(nextpoint.minus(point));\n    const crossdotnormal = crossproduct.dot(normal);\n    return (crossdotnormal >= EPS);\n  };\n\n  /**\n   * Polygon3 Constructor\n   * @param vertices\n   * @param shared\n   * @param plane\n   */\n  constructor(vertices: Vertex3[], shared?: PolygonShared | null, plane?: Plane) {\n    super();\n\n    this.vertices = vertices;\n    this.shared = shared ? shared : Polygon3.defaultShared;\n    this.plane = plane ? plane : Plane.fromVector3Ds(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n\n    // let numvertices = vertices.length;\n\n    if (_CSGDEBUG) {\n      if (!this.checkIfConvex()) {\n        throw new Error('Not convex!');\n      }\n    }\n  }\n\n  /**\n   * Check whether the polygon is convex. (it should be, otherwise we will get unexpected results)\n   * @returns {boolean}\n   */\n  checkIfConvex() {\n    return Polygon3.verticesConvex(this.vertices, this.plane.normal);\n  }\n\n  // FIXME what? why does this return this, and not a new polygon?\n  // FIXME is this used?\n  /**\n   * Set Color\n   * @param args\n   */\n  setColor(...args: any[]) {\n    this.shared = Polygon3.Shared.fromColor(...args);\n    return this;\n  }\n\n  /**\n   * Get Signed Volume\n   */\n  getSignedVolume() {\n    let signedVolume = 0;\n    for (let i = 0; i < this.vertices.length - 2; i++) {\n      signedVolume += this.vertices[0].pos.dot(this.vertices[i + 1].pos\n        .cross(this.vertices[i + 2].pos));\n    }\n    signedVolume /= 6;\n    return signedVolume;\n  }\n\n  /**\n   * Get Area\n   * Note: could calculate vectors only once to speed up\n   */\n  getArea() {\n    let polygonArea = 0;\n    for (let i = 0; i < this.vertices.length - 2; i++) {\n      polygonArea += this.vertices[i + 1].pos.minus(this.vertices[0].pos)\n        .cross(this.vertices[i + 2].pos.minus(this.vertices[i + 1].pos)).length();\n    }\n    polygonArea /= 2;\n    return polygonArea;\n  }\n\n  /**\n   * Get Tetra Features\n   * accepts array of features to calculate\n   * returns array of results\n   * @param features\n   */\n  getTetraFeatures(features: string[]) {\n    const result: number[] = [];\n    features.forEach((feature) => {\n      if (feature === 'volume') {\n        result.push(this.getSignedVolume());\n      } else if (feature === 'area') {\n        result.push(this.getArea());\n      }\n    }, this);\n    return result;\n  }\n\n  /**\n   * Extrude a polygon into the direction offsetvector\n   * Returns a CSG object\n   * @param offsetvector\n   */\n  extrude(offsetvector: Vector3) {\n    const newpolygons = [];\n\n    let polygon1: Polygon3 = this;\n    const direction = polygon1.plane.normal.dot(offsetvector);\n    if (direction > 0) {\n      polygon1 = polygon1.flipped();\n    }\n\n    newpolygons.push(polygon1);\n\n    let polygon2 = polygon1.translate(offsetvector);\n\n    const numvertices = this.vertices.length;\n    let x = 0;\n\n    const y = offsetvector.length();\n    for (let i = 0; i < numvertices; i++) {\n      const sidefacepoints = [];\n      const nexti = (i < (numvertices - 1)) ? i + 1 : 0;\n      const xn = x + polygon1.vertices[i].pos.distanceTo(polygon1.vertices[nexti].pos);\n      sidefacepoints.push(Vertex3.fromPosAndUV(polygon1.vertices[i].pos, new Vector2(x, 0)));\n      sidefacepoints.push(Vertex3.fromPosAndUV(polygon2.vertices[i].pos, new Vector2(x, y)));\n      sidefacepoints.push(Vertex3.fromPosAndUV(polygon2.vertices[nexti].pos, new Vector2(xn, y)));\n      sidefacepoints.push(Vertex3.fromPosAndUV(polygon1.vertices[nexti].pos, new Vector2(xn, 0)));\n\n      const sidefacepolygon = new Polygon3(sidefacepoints, this.shared);\n      newpolygons.push(sidefacepolygon);\n      x = xn;\n    }\n    polygon2 = polygon2.flipped();\n    newpolygons.push(polygon2);\n    return fromPolygons(newpolygons);\n  }\n\n  /**\n   * Translate polygon\n   * @param offset\n   */\n  translate(offset: TVector3Universal) {\n    return this.transform(Matrix4x4.translation(offset));\n  }\n\n  /**\n   * Bounding Sphere\n   * returns an array with a Vector3 (center point) and a radius\n   */\n  boundingSphere() {\n    if (!this.cachedBoundingSphere) {\n      const box = this.boundingBox();\n      const middle = box[0].plus(box[1]).times(0.5);\n      const radius3 = box[1].minus(middle);\n      const radius = radius3.length();\n      this.cachedBoundingSphere = [middle, radius];\n    }\n    return this.cachedBoundingSphere;\n  }\n\n  /**\n   * Bounding Box\n   * returns an array of two Vector3s (minimum coordinates and maximum coordinates)\n   */\n  boundingBox() {\n    if (!this.cachedBoundingBox) {\n      let minpoint;\n      let maxpoint;\n      const vertices = this.vertices;\n      const numvertices = vertices.length;\n      if (numvertices === 0) {\n        minpoint = new Vector3(0, 0, 0);\n      } else {\n        minpoint = vertices[0].pos;\n      }\n      maxpoint = minpoint;\n      for (let i = 1; i < numvertices; i++) {\n        const point = vertices[i].pos;\n        minpoint = minpoint.min(point);\n        maxpoint = maxpoint.max(point);\n      }\n      this.cachedBoundingBox = [minpoint, maxpoint];\n    }\n    return this.cachedBoundingBox;\n  }\n\n  /**\n   * get Flipped Polygon\n   */\n  flipped() {\n    const newvertices = this.vertices.map((v) => {\n      return v.flipped();\n    });\n    newvertices.reverse();\n    const newplane = this.plane.flipped();\n    return new Polygon3(newvertices, this.shared, newplane);\n  }\n\n  /**\n   * Affine transformation of polygon. Returns a new Polygon\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Polygon3 {\n    const newvertices = this.vertices.map((v) => {\n      return v.transform(matrix4x4);\n    });\n    const newplane = this.plane.transform(matrix4x4);\n    if (matrix4x4.isMirroring()) {\n      // need to reverse the vertex order\n      // in order to preserve the inside/outside orientation:\n      newvertices.reverse();\n    }\n    return new Polygon3(newvertices, this.shared, newplane);\n  }\n\n  /**\n   * To String helper\n   */\n  toString() {\n    let result = 'Polygon plane: ' + this.plane.toString() + '\\n';\n    this.vertices.map((vertex) => {\n      result += '  ' + vertex.toString() + '\\n';\n    });\n    return result;\n  }\n\n  /**\n   * Project the 3D polygon onto a plane\n   * @param orthobasis\n   */\n  projectToOrthoNormalBasis(orthobasis: OrthoNormalBasis) {\n    const points2d = this.vertices.map((vertex) => {\n      return orthobasis.to2D(vertex.pos);\n    });\n\n    let result = fromPointsNoCheck(points2d);\n    const area = result.area();\n    if (Math.abs(area) < areaEPS) {\n      // the polygon was perpendicular to the orthnormal plane. The resulting 2D polygon would be degenerate\n      // return an empty area instead:\n      result = new CAG();\n    } else if (area < 0) {\n      result = result.flipped();\n    }\n    return result;\n  }\n\n  /**\n   * Solid From Slices\n   * ALIAS ONLY!!\n   * @param options\n   */\n  solidFromSlices(options: Partial<ISolidFromSlices>) {\n    return solidFromSlices(this, options);\n  }\n}\n","import {Polygon3} from '@core/math';\nimport {PolygonTreeNode} from '@core/PolygonTreeNode';\nimport {Node} from '@core/Node';\n\n/**\n * @class Tree\n * This is the root of a BSP tree\n * We are using this separate class for the root of the tree, to hold the PolygonTreeNode root\n * The actual tree is kept in this.rootnode\n */\nexport class Tree {\n  polygonTree = new PolygonTreeNode();\n  rootnode = new Node(null);\n\n  /**\n   * Tree Constructor\n   */\n  constructor(polygons?: Polygon3[]) {\n    if (polygons) {\n      this.addPolygons(polygons);\n    }\n  }\n\n  /**\n   * Invert\n   */\n  invert() {\n    this.polygonTree.invert();\n    this.rootnode.invert();\n  }\n\n  /**\n   * Remove all polygons in this BSP tree that are inside the other BSP tree\n   * `tree`.\n   * @param tree\n   * @param alsoRemovecoplanarFront\n   */\n  clipTo(tree: Tree, alsoRemovecoplanarFront?: boolean) {\n    alsoRemovecoplanarFront = !!alsoRemovecoplanarFront;\n    this.rootnode.clipTo(tree, alsoRemovecoplanarFront);\n  }\n\n  /**\n   * All Polygons\n   */\n  allPolygons() {\n    const result: Polygon3[] = [];\n    this.polygonTree.getPolygons(result);\n    return result;\n  }\n\n  /**\n   * Add Polygons\n   * @param polygons\n   */\n  addPolygons(polygons: Polygon3[]) {\n    const _this = this;\n    const polygontreenodes = polygons.map((p) => {\n      return _this.polygonTree.addChild(p);\n    });\n    this.rootnode.addPolygonTreeNodes(polygontreenodes);\n  }\n}\n","import {_CSGDEBUG, EPS} from '@core/constants';\nimport {splitPolygonByPlane} from '@core/splitPolygonByPlane';\nimport {Plane, Polygon3} from '@core/math';\n\n/**\n * @class PolygonTreeNode\n * This class manages hierarchical splits of polygons\n * At the top is a root node which doesn hold a polygon, only child PolygonTreeNodes\n * Below that are zero or more 'top' nodes; each holds a polygon. The polygons can be in different planes\n * splitByPlane() splits a node by a plane. If the plane intersects the polygon, two new child nodes\n * are created holding the splitted polygon.\n * getPolygons() retrieves the polygon from the tree. If for PolygonTreeNode the polygon is split but\n * the two split parts (child nodes) are still intact, then the unsplit polygon is returned.\n * This ensures that we can safely split a polygon into many fragments. If the fragments are untouched,\n * getPolygons() will return the original unsplit polygon instead of the fragments.\n * remove() removes a polygon from the tree. Once a polygon is removed, the parent polygons are invalidated\n * since they are no longer intact.\n * constructor creates the root node:\n */\nexport class PolygonTreeNode {\n  parent: PolygonTreeNode | null = null;\n  children: PolygonTreeNode[] = [];\n  polygon: Polygon3 | null = null;\n  removed = false;\n\n  /**\n   * fill the tree with polygons. Should be called on the root node only; child nodes must\n   * always be a derivate (split) of the parent node.\n   * @param polygons\n   */\n  addPolygons(polygons: Polygon3[]) {\n    // new polygons can only be added to root node; children can only be splitted polygons\n    if (!this.isRootNode()) {\n      throw new Error('Assertion failed');\n    }\n    const _this = this;\n    polygons.map((polygon) => {\n      _this.addChild(polygon);\n    });\n  }\n\n  /**\n   * remove a node\n   * - the siblings become toplevel nodes\n   * - the parent is removed recursively\n   */\n  remove() {\n    if (!this.removed) {\n      this.removed = true;\n\n      if (_CSGDEBUG) {\n        if (this.isRootNode()) throw new Error('Assertion failed'); // can't remove root node\n        if (this.children.length) throw new Error('Assertion failed'); // we shouldn't remove nodes with children\n      }\n\n      if (this.parent) {\n        // remove ourselves from the parent's children list:\n        const parentschildren = this.parent.children;\n        const i = parentschildren.indexOf(this);\n        if (i < 0) throw new Error('Assertion failed');\n        parentschildren.splice(i, 1);\n\n        // invalidate the parent's polygon, and of all parents above it:\n        this.parent.recursivelyInvalidatePolygon();\n      }\n    }\n  }\n\n  /**\n   * isRemoved\n   */\n  isRemoved() {\n    return this.removed;\n  }\n\n  /**\n   * isRootNode\n   */\n  isRootNode() {\n    return !this.parent;\n  }\n\n  /**\n   * Invert\n   * invert all polygons in the tree. Call on the root node\n   */\n  invert() {\n    if (!this.isRootNode()) throw new Error('Assertion failed'); // can only call this on the root node\n    this.invertSub();\n  }\n\n  /**\n   * Get Polygon\n   */\n  getPolygon() {\n    if (!this.polygon) throw new Error('Assertion failed'); // doesn't have a polygon, which means that it has been broken down\n    return this.polygon;\n  }\n\n  /**\n   * Get Polygons\n   * @param result\n   */\n  getPolygons(result: Polygon3[]) {\n    let children: PolygonTreeNode[] = [this];\n    const queue = [children];\n    let i;\n    let j;\n    let l;\n    let node;\n    for (i = 0; i < queue.length; ++i) { // queue size can change in loop, don't cache length\n      children = queue[i];\n      for (j = 0, l = children.length; j < l; j++) { // ok to cache length\n        node = children[j];\n        if (node.polygon) {\n          // the polygon hasn't been broken yet. We can ignore the children and return our polygon:\n          result.push(node.polygon);\n        } else {\n          // our polygon has been split up and broken, so gather all subpolygons from the children\n          queue.push(node.children);\n        }\n      }\n    }\n  }\n\n  /**\n   * Split the node by a plane; add the resulting nodes to the frontnodes and backnodes array\n   * If the plane doesn't intersect the polygon, the 'this' object is added to one of the arrays\n   * If the plane does intersect the polygon, two new child nodes are created for the front and back fragments,\n   * and added to both arrays.\n   * @param plane\n   * @param coplanarfrontnodes\n   * @param coplanarbacknodes\n   * @param frontnodes\n   * @param backnodes\n   */\n  splitByPlane(plane: Plane, coplanarfrontnodes: PolygonTreeNode[], coplanarbacknodes: PolygonTreeNode[], frontnodes: PolygonTreeNode[], backnodes: PolygonTreeNode[]) {\n    if (this.children.length) {\n      const queue = [this.children];\n      let i;\n      let j;\n      let l;\n      let node;\n      let nodes;\n      for (i = 0; i < queue.length; i++) { // queue.length can increase, do not cache\n        nodes = queue[i];\n        for (j = 0, l = nodes.length; j < l; j++) { // ok to cache length\n          node = nodes[j];\n          if (node.children.length) {\n            queue.push(node.children);\n          } else {\n            // no children. Split the polygon:\n            node._splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes);\n          }\n        }\n      }\n    } else {\n      this._splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes);\n    }\n  }\n\n  /**\n   * Split By Plane\n   * only to be called for nodes with no children\n   * @param plane\n   * @param coplanarfrontnodes\n   * @param coplanarbacknodes\n   * @param frontnodes\n   * @param backnodes\n   * @private\n   */\n  _splitByPlane(plane: Plane, coplanarfrontnodes: PolygonTreeNode[], coplanarbacknodes: PolygonTreeNode[], frontnodes: PolygonTreeNode[], backnodes: PolygonTreeNode[]) {\n    const polygon = this.polygon;\n    if (polygon) {\n      const bound = polygon.boundingSphere();\n      const sphereradius = bound[1] + EPS; // FIXME Why add imprecision?\n      const planenormal = plane.normal;\n      const spherecenter = bound[0];\n      const d = planenormal.dot(spherecenter) - plane.w;\n      if (d > sphereradius) {\n        frontnodes.push(this);\n      } else if (d < -sphereradius) {\n        backnodes.push(this);\n      } else {\n        const splitresult = splitPolygonByPlane(plane, polygon);\n        switch (splitresult.type) {\n          case 0:\n            // coplanar front:\n            coplanarfrontnodes.push(this);\n            break;\n\n          case 1:\n            // coplanar back:\n            coplanarbacknodes.push(this);\n            break;\n\n          case 2:\n            // front:\n            frontnodes.push(this);\n            break;\n\n          case 3:\n            // back:\n            backnodes.push(this);\n            break;\n\n          case 4:\n            // spanning:\n            if (splitresult.front) {\n              const frontnode = this.addChild(splitresult.front);\n              frontnodes.push(frontnode);\n            }\n            if (splitresult.back) {\n              const backnode = this.addChild(splitresult.back);\n              backnodes.push(backnode);\n            }\n            break;\n        }\n      }\n    }\n  }\n\n  /**\n   *  PRIVATE methods from here:\n   * add child to a node\n   * this should be called whenever the polygon is split\n   * a child should be created for every fragment of the split polygon\n   * returns the newly created child\n   * @param polygon\n   */\n  addChild(polygon: Polygon3) {\n    const newchild = new PolygonTreeNode();\n    newchild.parent = this;\n    newchild.polygon = polygon;\n    this.children.push(newchild);\n    return newchild;\n  }\n\n  /**\n   * Invert Sub\n   */\n  invertSub() {\n    let children: PolygonTreeNode[] = [this];\n    const queue = [children];\n    let i;\n    let j;\n    let l;\n    let node;\n    for (i = 0; i < queue.length; i++) {\n      children = queue[i];\n      for (j = 0, l = children.length; j < l; j++) {\n        node = children[j];\n        if (node.polygon) {\n          node.polygon = node.polygon.flipped();\n        }\n        queue.push(node.children);\n      }\n    }\n  }\n\n  /**\n   * Recursively Invalidate Polygon\n   */\n  recursivelyInvalidatePolygon() {\n    let node: PolygonTreeNode = this;\n    while (node.polygon) {\n      node.polygon = null;\n      if (node.parent) {\n        node = node.parent;\n      }\n    }\n  }\n}\n","import {Plane, Polygon3} from '@core/math';\nimport {EPS} from '@core/constants';\nimport {calcInterpolationFactor} from '@core/utils/calcInterpolationFactor';\n\n/**\n * Split Polygon By Plane\n * Returns object:\n *  .type:\n *   0: coplanar-front\n *   1: coplanar-back\n *   2: front\n *   3: back\n *   4: spanning\n * In case the polygon is spanning, returns:\n *   .front: a Polygon of the front part\n *   .back: a Polygon of the back part\n *\n * @param plane\n * @param polygon\n */\nexport function splitPolygonByPlane(plane: Plane, polygon: Polygon3) {\n  const result: {\n    type: number | null,\n    front: Polygon3 | null,\n    back: Polygon3 | null\n  } = {\n    type: null,\n    front: null,\n    back: null,\n  };\n  // cache in local lets (speedup):\n  const planenormal = plane.normal;\n  const vertices = polygon.vertices;\n  const numvertices = vertices.length;\n  if (polygon.plane.equals(plane)) {\n    result.type = 0;\n  } else {\n    const thisw = plane.w;\n    let hasfront = false;\n    let hasback = false;\n    const vertexIsBack = [];\n    const MINEPS = -EPS;\n    for (let i = 0; i < numvertices; i++) {\n      const t = planenormal.dot(vertices[i].pos) - thisw;\n      const isback = (t < 0);\n      vertexIsBack.push(isback);\n      if (t > EPS) hasfront = true;\n      if (t < MINEPS) hasback = true;\n    }\n    if ((!hasfront) && (!hasback)) {\n      // all points coplanar\n      const t = planenormal.dot(polygon.plane.normal);\n      result.type = (t >= 0) ? 0 : 1;\n    } else if (!hasback) {\n      result.type = 2;\n    } else if (!hasfront) {\n      result.type = 3;\n    } else {\n      // spanning\n      result.type = 4;\n      const frontvertices = [];\n      const backvertices = [];\n      let isback = vertexIsBack[0];\n      for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n        const vertex = vertices[vertexindex];\n        let nextvertexindex = vertexindex + 1;\n        if (nextvertexindex >= numvertices) nextvertexindex = 0;\n        const nextisback = vertexIsBack[nextvertexindex];\n        if (isback === nextisback) {\n          // line segment is on one side of the plane:\n          if (isback) {\n            backvertices.push(vertex);\n          } else {\n            frontvertices.push(vertex);\n          }\n        } else {\n          // line segment intersects plane:\n          const point = vertex.pos;\n          const nextpoint = vertices[nextvertexindex].pos;\n          const interpolationFactor = calcInterpolationFactor(point, nextpoint, plane.splitLineBetweenPoints(point, nextpoint));\n          const intersectionvertex = vertex.interpolate(vertices[nextvertexindex], interpolationFactor);\n          if (isback) {\n            backvertices.push(vertex);\n            backvertices.push(intersectionvertex);\n            frontvertices.push(intersectionvertex);\n          } else {\n            frontvertices.push(vertex);\n            frontvertices.push(intersectionvertex);\n            backvertices.push(intersectionvertex);\n          }\n        }\n        isback = nextisback;\n      } // for vertexindex\n      // remove duplicate vertices:\n      const EPS_SQUARED = EPS * EPS;\n      if (backvertices.length >= 3) {\n        let prevvertex = backvertices[backvertices.length - 1];\n        for (let vertexindex = 0; vertexindex < backvertices.length; vertexindex++) {\n          const vertex = backvertices[vertexindex];\n          if (vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {\n            backvertices.splice(vertexindex, 1);\n            vertexindex--;\n          }\n          prevvertex = vertex;\n        }\n      }\n      if (frontvertices.length >= 3) {\n        let prevvertex = frontvertices[frontvertices.length - 1];\n        for (let vertexindex = 0; vertexindex < frontvertices.length; vertexindex++) {\n          const vertex = frontvertices[vertexindex];\n          if (vertex.pos.distanceToSquared(prevvertex.pos) < EPS_SQUARED) {\n            frontvertices.splice(vertexindex, 1);\n            vertexindex--;\n          }\n          prevvertex = vertex;\n        }\n      }\n      if (frontvertices.length >= 3) {\n        result.front = new Polygon3(frontvertices, polygon.shared, polygon.plane);\n      }\n      if (backvertices.length >= 3) {\n        result.back = new Polygon3(backvertices, polygon.shared, polygon.plane);\n      }\n    }\n  }\n  return result;\n}\n","import {Plane, Vector3} from '@core/math';\nimport {Tree} from '@core/Tree';\nimport {PolygonTreeNode} from '@core/PolygonTreeNode';\n\n/**\n * @class Node\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n * by picking a polygon to split along.\n * Polygons are not stored directly in the tree, but in PolygonTreeNodes, stored in\n * this.polygontreenodes. Those PolygonTreeNodes are children of the owning\n * Tree.polygonTree\n * This is not a leafy BSP tree since there is\n * no distinction between internal and leaf nodes.\n */\nexport class Node {\n  plane: Plane | null = null;\n  front: Node | null = null;\n  back: Node | null = null;\n  polygontreenodes = [];\n\n  /**\n   * Node Constructor\n   */\n  constructor(public parent: Node | null) {\n\n  }\n\n  /**\n   * Convert solid space to empty space and empty space to solid space.\n   */\n  invert() {\n    const queue: Node[] = [this];\n\n    let node: Node;\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < queue.length; i++) {\n      node = queue[i];\n      if (node.plane) {\n        node.plane = node.plane.flipped();\n      }\n      if (node.front) {\n        queue.push(node.front);\n      }\n      if (node.back) {\n        queue.push(node.back);\n      }\n      const temp = node.front;\n      node.front = node.back;\n      node.back = temp;\n    }\n  }\n\n  /**\n   * clip polygontreenodes to our plane\n   * calls remove() for all clipped PolygonTreeNodes\n   * @param polygontreenodes\n   * @param alsoRemovecoplanarFront\n   */\n  clipPolygons(polygontreenodes: PolygonTreeNode[], alsoRemovecoplanarFront?: boolean) {\n    let args = {\n      'node': this as Node,\n      'polygontreenodes': polygontreenodes,\n    };\n    let node;\n    const stack = [];\n\n    do {\n      node = args.node;\n      polygontreenodes = args.polygontreenodes;\n\n      // begin \"function\"\n      if (node.plane) {\n        const backnodes: PolygonTreeNode[] = [];\n        const frontnodes: PolygonTreeNode[] = [];\n        const coplanarfrontnodes = alsoRemovecoplanarFront ? backnodes : frontnodes;\n        const plane = node.plane;\n        const numpolygontreenodes = polygontreenodes.length;\n        for (let i = 0; i < numpolygontreenodes; i++) {\n          const node1 = polygontreenodes[i];\n          if (!node1.isRemoved()) {\n            node1.splitByPlane(plane, coplanarfrontnodes, backnodes, frontnodes, backnodes);\n          }\n        }\n\n        if (node.front && (frontnodes.length > 0)) {\n          stack.push({'node': node.front, 'polygontreenodes': frontnodes});\n        }\n        const numbacknodes = backnodes.length;\n        if (node.back && (numbacknodes > 0)) {\n          stack.push({'node': node.back, 'polygontreenodes': backnodes});\n        } else {\n          // there's nothing behind this plane. Delete the nodes behind this plane:\n          for (let i = 0; i < numbacknodes; i++) {\n            backnodes[i].remove();\n          }\n        }\n      }\n      args = stack.pop()!;\n    } while (typeof (args) !== 'undefined');\n  }\n\n  /**\n   * Remove all polygons in this BSP tree that are inside the other BSP tree\n   * `tree`.\n   * @param tree\n   * @param alsoRemovecoplanarFront\n   */\n  clipTo(tree: Tree, alsoRemovecoplanarFront?: boolean) {\n    let node: Node = this;\n    const stack = [];\n\n    do {\n      if (node.polygontreenodes.length > 0) {\n        tree.rootnode.clipPolygons(node.polygontreenodes, alsoRemovecoplanarFront);\n      }\n      if (node.front) stack.push(node.front);\n      if (node.back) stack.push(node.back);\n      node = stack.pop()!;\n    } while (typeof (node) !== 'undefined');\n  }\n\n  /**\n   * Add Polygon Tree Nodes\n   * @param polygontreenodes\n   */\n  addPolygonTreeNodes(polygontreenodes: PolygonTreeNode[]) {\n    let args = {\n      'node': this as Node,\n      'polygontreenodes': polygontreenodes,\n    };\n\n    let node;\n    const stack = [];\n    do {\n      node = args.node;\n      polygontreenodes = args.polygontreenodes;\n\n      if (polygontreenodes.length === 0) {\n        args = stack.pop()!;\n        continue;\n      }\n      const _this = node;\n      if (!node.plane) {\n        const bestplane = polygontreenodes[0].getPolygon().plane;\n        node.plane = bestplane;\n      }\n      const frontnodes: PolygonTreeNode[] = [];\n      const backnodes: PolygonTreeNode[] = [];\n\n      for (let i = 0, n = polygontreenodes.length; i < n; ++i) {\n        polygontreenodes[i].splitByPlane(_this.plane!, _this.polygontreenodes, backnodes, frontnodes, backnodes);\n      }\n\n      if (frontnodes.length > 0) {\n        if (!node.front) {\n          node.front = new Node(node);\n        }\n\n        stack.push({\n          'node': node.front,\n          'polygontreenodes': frontnodes,\n        });\n      }\n      if (backnodes.length > 0) {\n        if (!node.back) {\n          node.back = new Node(node);\n        }\n\n        stack.push({\n          'node': node.back,\n          'polygontreenodes': backnodes,\n        });\n      }\n\n      args = stack.pop()!;\n    } while (typeof (args) !== 'undefined');\n  }\n\n  /**\n   * Get Parent Plane Normals\n   * @param normals\n   * @param maxdepth\n   */\n  getParentPlaneNormals(normals: Vector3[], maxdepth: number) {\n    if (maxdepth > 0) {\n      if (this.parent && this.parent.plane) {\n        normals.push(this.parent.plane.normal);\n        this.parent.getParentPlaneNormals(normals, maxdepth - 1);\n      }\n    }\n  }\n}\n","import {EPS} from '@core/constants';\nimport {Plane, Polygon3} from '@core/math';\n\n/**\n * Add Side\n * @param sidemap\n * @param vertextag2sidestart\n * @param vertextag2sideend\n * @param vertex0\n * @param vertex1\n * @param polygonindex\n */\nfunction addSide(sidemap: any, vertextag2sidestart: any, vertextag2sideend: any, vertex0: any, vertex1: any, polygonindex: any) {\n  const starttag = vertex0.getTag();\n  const endtag = vertex1.getTag();\n  if (starttag === endtag) throw new Error('Assertion failed');\n  const newsidetag = starttag + '/' + endtag;\n  const reversesidetag = endtag + '/' + starttag;\n  if (reversesidetag in sidemap) {\n    // we have a matching reverse oriented side.\n    // Instead of adding the new side, cancel out the reverse side:\n    // console.log(\"addSide(\"+newsidetag+\") has reverse side:\");\n    deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, vertex1, vertex0, null);\n    return null;\n  }\n  //  console.log(\"addSide(\"+newsidetag+\")\");\n  const newsideobj = {\n    vertex0,\n    vertex1,\n    polygonindex,\n  };\n  if (!(newsidetag in sidemap)) {\n    sidemap[newsidetag] = [newsideobj];\n  } else {\n    sidemap[newsidetag].push(newsideobj);\n  }\n  if (starttag in vertextag2sidestart) {\n    vertextag2sidestart[starttag].push(newsidetag);\n  } else {\n    vertextag2sidestart[starttag] = [newsidetag];\n  }\n  if (endtag in vertextag2sideend) {\n    vertextag2sideend[endtag].push(newsidetag);\n  } else {\n    vertextag2sideend[endtag] = [newsidetag];\n  }\n  return newsidetag;\n}\n\n/**\n * Delete Side\n * @param sidemap\n * @param vertextag2sidestart\n * @param vertextag2sideend\n * @param vertex0\n * @param vertex1\n * @param polygonindex\n */\nfunction deleteSide(sidemap: any, vertextag2sidestart: any, vertextag2sideend: any, vertex0: any, vertex1: any, polygonindex: any) {\n  const starttag = vertex0.getTag();\n  const endtag = vertex1.getTag();\n  const sidetag = starttag + '/' + endtag;\n  // console.log(\"deleteSide(\"+sidetag+\")\");\n  if (!(sidetag in sidemap)) throw new Error('Assertion failed');\n  let idx = -1;\n  const sideobjs = sidemap[sidetag];\n  for (let i = 0; i < sideobjs.length; i++) {\n    const sideobj = sideobjs[i];\n    if (sideobj.vertex0 !== vertex0) continue;\n    if (sideobj.vertex1 !== vertex1) continue;\n    if (polygonindex !== null) {\n      if (sideobj.polygonindex !== polygonindex) continue;\n    }\n    idx = i;\n    break;\n  }\n  if (idx < 0) throw new Error('Assertion failed');\n  sideobjs.splice(idx, 1);\n  if (sideobjs.length === 0) {\n    delete sidemap[sidetag];\n  }\n  idx = vertextag2sidestart[starttag].indexOf(sidetag);\n  if (idx < 0) throw new Error('Assertion failed');\n  vertextag2sidestart[starttag].splice(idx, 1);\n  if (vertextag2sidestart[starttag].length === 0) {\n    delete vertextag2sidestart[starttag];\n  }\n\n  idx = vertextag2sideend[endtag].indexOf(sidetag);\n  if (idx < 0) throw new Error('Assertion failed');\n  vertextag2sideend[endtag].splice(idx, 1);\n  if (vertextag2sideend[endtag].length === 0) {\n    delete vertextag2sideend[endtag];\n  }\n}\n\n/**\n * Fix TJunctions\n *     Suppose we have two polygons ACDB and EDGF:\n *\n *     A-----B\n *     |     |\n *     |     E--F\n *     |     |  |\n *     C-----D--G\n *\n *     Note that vertex E forms a T-junction on the side BD. In this case some STL slicers will complain\n *     that the solid is not watertight. This is because the watertightness check is done by checking if\n *     each side DE is matched by another side ED.\n *\n *     This function will return a new solid with ACDB replaced by ACDEB\n *\n *     Note that this can create polygons that are slightly non-convex (due to rounding errors). Therefore the result should\n *     not be used for further CSG operations!\n *\n * @param fromPolygons\n * @param csg\n */\nexport const fixTJunctions = (fromPolygons: any, csg: any) => {\n  csg = csg.canonicalized();\n  const sidemap: any = {};\n\n  // STEP 1\n  for (let polygonindex = 0; polygonindex < csg.polygons.length; polygonindex++) {\n    const polygon = csg.polygons[polygonindex];\n    const numvertices = polygon.vertices.length;\n    // should be true\n    if (numvertices >= 3) {\n      let vertex = polygon.vertices[0];\n      let vertextag = vertex.getTag();\n      for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {\n        let nextvertexindex = vertexindex + 1;\n        if (nextvertexindex === numvertices) nextvertexindex = 0;\n        const nextvertex = polygon.vertices[nextvertexindex];\n        const nextvertextag = nextvertex.getTag();\n        const sidetag = vertextag + '/' + nextvertextag;\n        const reversesidetag = nextvertextag + '/' + vertextag;\n        if (reversesidetag in sidemap) {\n          // this side matches the same side in another polygon. Remove from sidemap:\n          const ar = sidemap[reversesidetag];\n          ar.splice(-1, 1);\n          if (ar.length === 0) {\n            delete sidemap[reversesidetag];\n          }\n        } else {\n          const sideobj = {\n            vertex0: vertex,\n            vertex1: nextvertex,\n            polygonindex,\n          };\n          if (!(sidetag in sidemap)) {\n            sidemap[sidetag] = [sideobj];\n          } else {\n            sidemap[sidetag].push(sideobj);\n          }\n        }\n        vertex = nextvertex;\n        vertextag = nextvertextag;\n      }\n    }\n  }\n  // STEP 2\n  // now sidemap contains 'unmatched' sides\n  // i.e. side AB in one polygon does not have a matching side BA in another polygon\n  const vertextag2sidestart: any = {};\n  const vertextag2sideend: any = {};\n  const sidestocheck: any = {};\n  let sidemapisempty = true;\n\n  // tslint:disable-next-line:forin\n  for (const sidetag in sidemap) {\n    sidemapisempty = false;\n    sidestocheck[sidetag] = true;\n    sidemap[sidetag].map((sideobj: any) => {\n      const starttag = sideobj.vertex0.getTag();\n      const endtag = sideobj.vertex1.getTag();\n      if (starttag in vertextag2sidestart) {\n        vertextag2sidestart[starttag].push(sidetag);\n      } else {\n        vertextag2sidestart[starttag] = [sidetag];\n      }\n      if (endtag in vertextag2sideend) {\n        vertextag2sideend[endtag].push(sidetag);\n      } else {\n        vertextag2sideend[endtag] = [sidetag];\n      }\n    });\n  }\n\n  // STEP 3 : if sidemap is not empty\n  if (!sidemapisempty) {\n    // make a copy of the polygons array, since we are going to modify it:\n    const polygons = csg.polygons.slice(0);\n    while (true) {\n      // tslint:disable-next-line:no-shadowed-variable\n      let sidemapisempty = true;\n\n      // tslint:disable-next-line:forin\n      for (const sidetag in sidemap) {\n        sidemapisempty = false;\n        sidestocheck[sidetag] = true;\n      }\n      if (sidemapisempty) break;\n      let donesomething = false;\n      while (true) {\n        let sidetagtocheck = null;\n\n        // tslint:disable-next-line:forin\n        for (const sidetag in sidestocheck) {\n          sidetagtocheck = sidetag;\n          break; // FIXME  : say what now ?\n        }\n        if (sidetagtocheck === null) break; // sidestocheck is empty, we're done!\n        let donewithside = true;\n        if (sidetagtocheck in sidemap) {\n          const sideobjs = sidemap[sidetagtocheck];\n          if (sideobjs.length === 0) throw new Error('Assertion failed');\n          const sideobj = sideobjs[0];\n          for (let directionindex = 0; directionindex < 2; directionindex++) {\n            const startvertex = (directionindex === 0) ? sideobj.vertex0 : sideobj.vertex1;\n            const endvertex = (directionindex === 0) ? sideobj.vertex1 : sideobj.vertex0;\n            const startvertextag = startvertex.getTag();\n            const endvertextag = endvertex.getTag();\n            let matchingsides = [];\n            if (directionindex === 0) {\n              if (startvertextag in vertextag2sideend) {\n                matchingsides = vertextag2sideend[startvertextag];\n              }\n            } else {\n              if (startvertextag in vertextag2sidestart) {\n                matchingsides = vertextag2sidestart[startvertextag];\n              }\n            }\n\n            // tslint:disable-next-line:prefer-for-of\n            for (let matchingsideindex = 0; matchingsideindex < matchingsides.length; matchingsideindex++) {\n              const matchingsidetag = matchingsides[matchingsideindex];\n              const matchingside = sidemap[matchingsidetag][0];\n              const matchingsidestartvertex = (directionindex === 0) ? matchingside.vertex0 : matchingside.vertex1;\n              const matchingsideendvertex = (directionindex === 0) ? matchingside.vertex1 : matchingside.vertex0;\n              const matchingsidestartvertextag = matchingsidestartvertex.getTag();\n              const matchingsideendvertextag = matchingsideendvertex.getTag();\n              if (matchingsideendvertextag !== startvertextag) throw new Error('Assertion failed');\n              if (matchingsidestartvertextag === endvertextag) {\n                // matchingside cancels sidetagtocheck\n                deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, startvertex, endvertex, null);\n                deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, endvertex, startvertex, null);\n                donewithside = false;\n                directionindex = 2; // skip reverse direction check\n                donesomething = true;\n                break;\n              } else {\n                const startpos = startvertex.pos;\n                const endpos = endvertex.pos;\n                const checkpos = matchingsidestartvertex.pos;\n                const direction = checkpos.minus(startpos);\n                // Now we need to check if endpos is on the line startpos-checkpos:\n                const t = endpos.minus(startpos).dot(direction) / direction.dot(direction);\n                if ((t > 0) && (t < 1)) {\n                  const closestpoint = startpos.plus(direction.times(t));\n                  const distancesquared = closestpoint.distanceToSquared(endpos);\n                  if (distancesquared < (EPS * EPS)) {\n                    // Yes it's a t-junction! We need to split matchingside in two:\n                    const polygonindex = matchingside.polygonindex;\n                    const polygon = polygons[polygonindex];\n                    // find the index of startvertextag in polygon:\n                    const insertionvertextag = matchingside.vertex1.getTag();\n                    let insertionvertextagindex = -1;\n                    for (let i = 0; i < polygon.vertices.length; i++) {\n                      if (polygon.vertices[i].getTag() === insertionvertextag) {\n                        insertionvertextagindex = i;\n                        break;\n                      }\n                    }\n                    if (insertionvertextagindex < 0) throw new Error('Assertion failed');\n                    // split the side by inserting the vertex:\n                    const newvertices = polygon.vertices.slice(0);\n                    newvertices.splice(insertionvertextagindex, 0, endvertex);\n                    const newpolygon = new Polygon3(newvertices, polygon.shared /* polygon.plane */);\n\n                    // calculate plane with differents point\n                    if (isNaN(newpolygon.plane.w)) {\n                      let found = false;\n                      const loop = (callback: any) => {\n                        newpolygon.vertices.forEach((item) => {\n                          if (found) return;\n                          callback(item);\n                        });\n                      };\n\n                      loop((a: any) => {\n                        loop((b: any) => {\n                          loop((c: any) => {\n                            newpolygon.plane = Plane.fromPoints(a.pos, b.pos, c.pos);\n                            if (!isNaN(newpolygon.plane.w)) {\n                              found = true;\n                            }\n                          });\n                        });\n                      });\n                    }\n                    polygons[polygonindex] = newpolygon;\n                    // remove the original sides from our maps\n                    // deleteSide(sideobj.vertex0, sideobj.vertex1, null)\n                    deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, matchingside.vertex0, matchingside.vertex1, polygonindex);\n                    const newsidetag1 = addSide(sidemap, vertextag2sidestart, vertextag2sideend, matchingside.vertex0, endvertex, polygonindex);\n                    const newsidetag2 = addSide(sidemap, vertextag2sidestart, vertextag2sideend, endvertex, matchingside.vertex1, polygonindex);\n                    if (newsidetag1 !== null) sidestocheck[newsidetag1] = true;\n                    if (newsidetag2 !== null) sidestocheck[newsidetag2] = true;\n                    donewithside = false;\n                    directionindex = 2; // skip reverse direction check\n                    donesomething = true;\n                    break;\n                  } // if(distancesquared < 1e-10)\n                } // if( (t > 0) && (t < 1) )\n              } // if(endingstidestartvertextag === endvertextag)\n            } // for matchingsideindex\n          } // for directionindex\n        } // if(sidetagtocheck in sidemap)\n        if (donewithside) {\n          delete sidestocheck[sidetagtocheck];\n        }\n      }\n      if (!donesomething) break;\n    }\n    const newcsg = fromPolygons(polygons);\n    newcsg.properties = csg.properties;\n    newcsg.isCanonicalized = true;\n    newcsg.isRetesselated = true;\n    csg = newcsg;\n  }\n\n  // FIXME : what is even the point of this ???\n  /* sidemapisempty = true\n  for (let sidetag in sidemap) {\n    sidemapisempty = false\n    break\n  }\n  */\n\n  return csg;\n};\n\n","import {FuzzyFactory} from '@core/FuzzyFactory';\nimport {EPS} from '@core/constants';\nimport {Side, Vertex2} from '@core/math';\n\n/**\n * Class FuzzyCAGFactory\n */\nexport class FuzzyCAGFactory {\n  vertexfactory = new FuzzyFactory(2, EPS);\n\n  /**\n   * Get Vertex\n   * @param sourcevertex\n   */\n  getVertex(sourcevertex: Vertex2) {\n    const elements = [sourcevertex.pos._x, sourcevertex.pos._y];\n    const result = this.vertexfactory.lookupOrCreate(elements, (els) => {\n      return sourcevertex;\n    });\n    return result;\n  }\n\n  /**\n   * Get Side\n   * @param sourceside\n   */\n  getSide(sourceside: Side) {\n    const vertex0 = this.getVertex(sourceside.vertex0);\n    const vertex1 = this.getVertex(sourceside.vertex1);\n    return new Side(vertex0, vertex1);\n  }\n\n}\n","import {EPS} from '@core/constants';\nimport {Line2D, OrthoNormalBasis, Polygon3, Vector2, Vertex3} from '../math';\nimport {fnNumberSort} from '@core/utils/sortHelpers';\nimport {insertSorted} from '@core/utils/insertSorted';\nimport {interpolateBetween2DPointsForY} from '@core/utils/interpolateBetween2DPointsForY';\nimport {calcInterpolationFactor} from '@core/utils/calcInterpolationFactor';\n\n/**\n * Re-Tessellation function for a set of coplanar polygons.\n * @param sourcepolygons\n * @param destpolygons\n */\nexport const reTessellateCoplanarPolygons = (sourcepolygons: Polygon3[], destpolygons: Polygon3[]) => {\n  const numpolygons = sourcepolygons.length;\n  if (numpolygons > 0) {\n    const plane = sourcepolygons[0].plane;\n    const shared = sourcepolygons[0].shared;\n    const orthobasis = new OrthoNormalBasis(plane);\n    const polygonvertices2d: any[] = []; // array of array of Vector2D\n    const polygonuvcoordinates: any[] = []; // array of array of Vector2D\n    const polygontopvertexindexes: any[] = []; // array of indexes of topmost vertex per polygon\n    const topy2polygonindexes: any = {};\n    const ycoordinatetopolygonindexes: any = {};\n\n    const xcoordinatebins: any = {};\n    const ycoordinatebins: any = {};\n\n    // convert all polygon vertices to 2D\n    // Make a list of all encountered y coordinates\n    // And build a map of all polygons that have a vertex at a certain y coordinate:\n    const ycoordinateBinningFactor = 1.0 / EPS * 10;\n    for (let polygonindex = 0; polygonindex < numpolygons; polygonindex++) {\n      const poly3d = sourcepolygons[polygonindex];\n      let vertices2d = [];\n      let uvcoordinates = [];\n      let numvertices = poly3d.vertices.length;\n      let minindex = -1;\n      if (numvertices > 0) {\n        let miny = 0; // todo fix me\n        let maxy = 0; // todo fix me\n        let maxindex;\n        for (let i = 0; i < numvertices; i++) {\n          let pos2d = orthobasis.to2D(poly3d.vertices[i].pos);\n          const uvcoordinate = poly3d.vertices[i].uv;\n          // perform binning of y coordinates: If we have multiple vertices very\n          // close to each other, give them the same y coordinate:\n          const ycoordinatebin = Math.floor(pos2d.y * ycoordinateBinningFactor);\n          let newy;\n          if (ycoordinatebin in ycoordinatebins) {\n            newy = ycoordinatebins[ycoordinatebin];\n          } else if (ycoordinatebin + 1 in ycoordinatebins) {\n            newy = ycoordinatebins[ycoordinatebin + 1];\n          } else if (ycoordinatebin - 1 in ycoordinatebins) {\n            newy = ycoordinatebins[ycoordinatebin - 1];\n          } else {\n            newy = pos2d.y;\n            ycoordinatebins[ycoordinatebin] = pos2d.y;\n          }\n          pos2d = Vector2.Create(pos2d.x, newy);\n          vertices2d.push(pos2d);\n          uvcoordinates.push(uvcoordinate);\n          const y = pos2d.y;\n          if ((i === 0) || (y < miny)) {\n            miny = y;\n            minindex = i;\n          }\n          if ((i === 0) || (y > maxy)) {\n            maxy = y;\n            maxindex = i;\n          }\n          if (!(y in ycoordinatetopolygonindexes)) {\n            ycoordinatetopolygonindexes[y] = {};\n          }\n          ycoordinatetopolygonindexes[y][polygonindex] = true;\n        }\n        if (miny >= maxy) {\n          // degenerate polygon, all vertices have same y coordinate. Just ignore it from now:\n          vertices2d = [];\n          uvcoordinates = [];\n          numvertices = 0;\n          minindex = -1;\n        } else {\n          if (!(miny in topy2polygonindexes)) {\n            topy2polygonindexes[miny] = [];\n          }\n          topy2polygonindexes[miny].push(polygonindex);\n        }\n      } // if(numvertices > 0)\n      // reverse the vertex order:\n      vertices2d.reverse();\n      uvcoordinates.reverse();\n      minindex = numvertices - minindex - 1;\n      polygonvertices2d.push(vertices2d);\n      polygonuvcoordinates.push(uvcoordinates);\n      polygontopvertexindexes.push(minindex);\n    }\n    const ycoordinates: any[] = [];\n\n    // tslint:disable-next-line:forin\n    for (const ycoordinate in ycoordinatetopolygonindexes) {\n      ycoordinates.push(ycoordinate);\n    }\n    ycoordinates.sort(fnNumberSort as any);\n\n    // Now we will iterate over all y coordinates, from lowest to highest y coordinate\n    // activepolygons: source polygons that are 'active', i.e. intersect with our y coordinate\n    //   Is sorted so the polygons are in left to right order\n    // Each element in activepolygons has these properties:\n    //        polygonindex: the index of the source polygon (i.e. an index into the sourcepolygons\n    //                      and polygonvertices2d arrays)\n    //        leftvertexindex: the index of the vertex at the left side of the polygon (lowest x)\n    //                         that is at or just above the current y coordinate\n    //        rightvertexindex: dito at right hand side of polygon\n    //        topleft, bottomleft: coordinates of the left side of the polygon crossing the current y coordinate\n    //        topright, bottomright: coordinates of the right hand side of the polygon crossing the current y coordinate\n    let activepolygons: any[] = [];\n    let prevoutpolygonrow: any[] = [];\n    for (let yindex = 0; yindex < ycoordinates.length; yindex++) {\n      const newoutpolygonrow = [];\n      const ycoordinateAsString = ycoordinates[yindex];\n      const ycoordinate = Number(ycoordinateAsString);\n\n      // update activepolygons for this y coordinate:\n      // - Remove any polygons that end at this y coordinate\n      // - update leftvertexindex and rightvertexindex (which point to the current vertex index\n      //   at the the left and right side of the polygon\n      // Iterate over all polygons that have a corner at this y coordinate:\n      const polygonindexeswithcorner = ycoordinatetopolygonindexes[ycoordinateAsString];\n      for (let activepolygonindex = 0; activepolygonindex < activepolygons.length; ++activepolygonindex) {\n        const activepolygon = activepolygons[activepolygonindex];\n        const polygonindex = activepolygon.polygonindex;\n        if (polygonindexeswithcorner[polygonindex]) {\n          // this active polygon has a corner at this y coordinate:\n          const vertices2d = polygonvertices2d[polygonindex];\n          const uvcoordinates = polygonuvcoordinates[polygonindex];\n          const numvertices = vertices2d.length;\n          let newleftvertexindex = activepolygon.leftvertexindex;\n          let newrightvertexindex = activepolygon.rightvertexindex;\n          // See if we need to increase leftvertexindex or decrease rightvertexindex:\n          while (true) {\n            let nextleftvertexindex = newleftvertexindex + 1;\n            if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;\n            if (vertices2d[nextleftvertexindex].y !== ycoordinate) break;\n            newleftvertexindex = nextleftvertexindex;\n          }\n          let nextrightvertexindex = newrightvertexindex - 1;\n          if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;\n          if (vertices2d[nextrightvertexindex].y === ycoordinate) {\n            newrightvertexindex = nextrightvertexindex;\n          }\n          if ((newleftvertexindex !== activepolygon.leftvertexindex) && (newleftvertexindex === newrightvertexindex)) {\n            // We have increased leftvertexindex or decreased rightvertexindex, and now they point to the same vertex\n            // This means that this is the bottom point of the polygon. We'll remove it:\n            activepolygons.splice(activepolygonindex, 1);\n            --activepolygonindex;\n          } else {\n            activepolygon.leftvertexindex = newleftvertexindex;\n            activepolygon.rightvertexindex = newrightvertexindex;\n            activepolygon.topleft = vertices2d[newleftvertexindex];\n            activepolygon.topleftuv = uvcoordinates[newleftvertexindex];\n            activepolygon.topright = vertices2d[newrightvertexindex];\n            activepolygon.toprightuv = uvcoordinates[newrightvertexindex];\n            let nextleftvertexindex = newleftvertexindex + 1;\n            if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;\n            activepolygon.bottomleft = vertices2d[nextleftvertexindex];\n            activepolygon.bottomleftuv = uvcoordinates[nextleftvertexindex];\n\n            // tslint:disable-next-line:no-shadowed-variable\n            let nextrightvertexindex = newrightvertexindex - 1;\n            if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;\n            activepolygon.bottomright = vertices2d[nextrightvertexindex];\n            activepolygon.bottomrightuv = uvcoordinates[nextrightvertexindex];\n          }\n        } // if polygon has corner here\n      } // for activepolygonindex\n      let nextycoordinate: any;\n      if (yindex >= ycoordinates.length - 1) {\n        // last row, all polygons must be finished here:\n        activepolygons = [];\n        nextycoordinate = null;\n      } else // yindex < ycoordinates.length-1\n      {\n        nextycoordinate = Number(ycoordinates[yindex + 1]);\n        const middleycoordinate = 0.5 * (ycoordinate + nextycoordinate);\n        // update activepolygons by adding any polygons that start here:\n        const startingpolygonindexes = topy2polygonindexes[ycoordinateAsString];\n\n        // tslint:disable-next-line:forin\n        for (const polygonindexKey in startingpolygonindexes) {\n          const polygonindex = startingpolygonindexes[polygonindexKey];\n          const vertices2d = polygonvertices2d[polygonindex];\n          const uvcoordinates = polygonuvcoordinates[polygonindex];\n          const numvertices = vertices2d.length;\n          const topvertexindex = polygontopvertexindexes[polygonindex];\n          // the top of the polygon may be a horizontal line. In that case topvertexindex can point to any point on this line.\n          // Find the left and right topmost vertices which have the current y coordinate:\n          let topleftvertexindex = topvertexindex;\n          while (true) {\n            let i = topleftvertexindex + 1;\n            if (i >= numvertices) i = 0;\n            if (vertices2d[i].y !== ycoordinate) break;\n            if (i === topvertexindex) break; // should not happen, but just to prevent endless loops\n            topleftvertexindex = i;\n          }\n          let toprightvertexindex = topvertexindex;\n          while (true) {\n            let i = toprightvertexindex - 1;\n            if (i < 0) i = numvertices - 1;\n            if (vertices2d[i].y !== ycoordinate) break;\n            if (i === topleftvertexindex) break; // should not happen, but just to prevent endless loops\n            toprightvertexindex = i;\n          }\n          let nextleftvertexindex = topleftvertexindex + 1;\n          if (nextleftvertexindex >= numvertices) nextleftvertexindex = 0;\n          let nextrightvertexindex = toprightvertexindex - 1;\n          if (nextrightvertexindex < 0) nextrightvertexindex = numvertices - 1;\n          const newactivepolygon = {\n            polygonindex,\n            leftvertexindex: topleftvertexindex,\n            rightvertexindex: toprightvertexindex,\n            topleft: vertices2d[topleftvertexindex],\n            topleftuv: uvcoordinates[topleftvertexindex],\n            topright: vertices2d[toprightvertexindex],\n            toprightuv: uvcoordinates[toprightvertexindex],\n            bottomleft: vertices2d[nextleftvertexindex],\n            bottomleftuv: uvcoordinates[nextleftvertexindex],\n            bottomright: vertices2d[nextrightvertexindex],\n            bottomrightuv: uvcoordinates[nextrightvertexindex],\n          };\n          insertSorted(activepolygons, newactivepolygon, (el1: any, el2: any) => {\n            const x1 = interpolateBetween2DPointsForY(\n              el1.topleft, el1.bottomleft, middleycoordinate);\n            const x2 = interpolateBetween2DPointsForY(\n              el2.topleft, el2.bottomleft, middleycoordinate);\n            if (x1 > x2) return 1;\n            if (x1 < x2) return -1;\n            return 0;\n          });\n        } // for(let polygonindex in startingpolygonindexes)\n      } //  yindex < ycoordinates.length-1\n      // if( (yindex === ycoordinates.length-1) || (nextycoordinate - ycoordinate > EPS) )\n      if (true) {\n        // Now activepolygons is up to date\n        // Build the output polygons for the next row in newoutpolygonrow:\n\n        // tslint:disable-next-line:forin\n        for (const activepolygonKey in activepolygons) {\n          const activepolygon = activepolygons[activepolygonKey];\n          const polygonindex = activepolygon.polygonindex;\n          const vertices2d = polygonvertices2d[polygonindex];\n          const numvertices = vertices2d.length;\n\n          let x = interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, ycoordinate);\n          const topleft = Vector2.Create(x, ycoordinate);\n          const topleftuv = activepolygon.topleftuv.lerp(activepolygon.bottomleftuv,\n            calcInterpolationFactor(activepolygon.topleft,\n              activepolygon.bottomleft,\n              topleft));\n          x = interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, ycoordinate);\n          const topright = Vector2.Create(x, ycoordinate);\n          const toprightuv = activepolygon.toprightuv.lerp(activepolygon.bottomrightuv,\n            calcInterpolationFactor(activepolygon.topright,\n              activepolygon.bottomright,\n              topright));\n          x = interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, nextycoordinate);\n          const bottomleft = Vector2.Create(x, nextycoordinate);\n          const bottomleftuv = activepolygon.topleftuv.lerp(activepolygon.bottomleftuv,\n            calcInterpolationFactor(activepolygon.topleft,\n              activepolygon.bottomleft,\n              bottomleft));\n          x = interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, nextycoordinate);\n          const bottomright = Vector2.Create(x, nextycoordinate);\n          const bottomrightuv = activepolygon.toprightuv.lerp(activepolygon.bottomrightuv,\n            calcInterpolationFactor(activepolygon.topright,\n              activepolygon.bottomright,\n              bottomright));\n          const outpolygon = {\n            topleft,\n            topleftuv,\n            topright,\n            toprightuv,\n            bottomleft,\n            bottomleftuv,\n            bottomright,\n            bottomrightuv,\n            leftline: Line2D.fromPoints(topleft, bottomleft),\n            rightline: Line2D.fromPoints(bottomright, topright),\n          };\n          if (newoutpolygonrow.length > 0) {\n            const prevoutpolygon = newoutpolygonrow[newoutpolygonrow.length - 1];\n            const d1 = outpolygon.topleft.distanceTo(prevoutpolygon.topright);\n            const d2 = outpolygon.bottomleft.distanceTo(prevoutpolygon.bottomright);\n            if ((d1 < EPS) && (d2 < EPS)) {\n              // we can join this polygon with the one to the left:\n              outpolygon.topleft = prevoutpolygon.topleft;\n              outpolygon.topleftuv = prevoutpolygon.topleftuv;\n              outpolygon.leftline = prevoutpolygon.leftline;\n              outpolygon.bottomleft = prevoutpolygon.bottomleft;\n              outpolygon.bottomleftuv = prevoutpolygon.bottomleftuv;\n              newoutpolygonrow.splice(newoutpolygonrow.length - 1, 1);\n            }\n          }\n          newoutpolygonrow.push(outpolygon);\n        } // for(activepolygon in activepolygons)\n        if (yindex > 0) {\n          // try to match the new polygons against the previous row:\n          const prevcontinuedindexes: any = {};\n          const matchedindexes: any = {};\n\n          // tslint:disable-next-line:prefer-for-of\n          for (let i = 0; i < newoutpolygonrow.length; i++) {\n            const thispolygon: any = newoutpolygonrow[i];\n            for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {\n              if (!matchedindexes[ii]) // not already processed?\n              {\n                // We have a match if the sidelines are equal or if the top coordinates\n                // are on the sidelines of the previous polygon\n                const prevpolygon = prevoutpolygonrow[ii];\n                if (prevpolygon.bottomleft.distanceTo(thispolygon.topleft) < EPS) {\n                  if (prevpolygon.bottomright.distanceTo(thispolygon.topright) < EPS) {\n                    // Yes, the top of this polygon matches the bottom of the previous:\n                    matchedindexes[ii] = true;\n                    // Now check if the joined polygon would remain convex:\n                    const d1 = thispolygon.leftline.direction().x - prevpolygon.leftline.direction().x;\n                    const d2 = thispolygon.rightline.direction().x - prevpolygon.rightline.direction().x;\n                    const leftlinecontinues = Math.abs(d1) < EPS;\n                    const rightlinecontinues = Math.abs(d2) < EPS;\n                    const leftlineisconvex = leftlinecontinues || (d1 >= 0);\n                    const rightlineisconvex = rightlinecontinues || (d2 >= 0);\n                    if (leftlineisconvex && rightlineisconvex) {\n                      // yes, both sides have convex corners:\n                      // This polygon will continue the previous polygon\n                      thispolygon.outpolygon = prevpolygon.outpolygon;\n                      thispolygon.leftlinecontinues = leftlinecontinues;\n                      thispolygon.rightlinecontinues = rightlinecontinues;\n                      prevcontinuedindexes[ii] = true;\n                    }\n                    break;\n                  }\n                }\n              } // if(!prevcontinuedindexes[ii])\n            } // for ii\n          } // for i\n          for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {\n            if (!prevcontinuedindexes[ii]) {\n              // polygon ends here\n              // Finish the polygon with the last point(s):\n              const prevpolygon = prevoutpolygonrow[ii];\n              prevpolygon.outpolygon.rightpoints.push(prevpolygon.bottomright);\n              prevpolygon.outpolygon.rightuvcoordinates.push(prevpolygon.bottomrightuv);\n              if (prevpolygon.bottomright.distanceTo(prevpolygon.bottomleft) > EPS) {\n                // polygon ends with a horizontal line:\n                prevpolygon.outpolygon.leftpoints.push(prevpolygon.bottomleft);\n                prevpolygon.outpolygon.leftuvcoordinates.push(prevpolygon.bottomleftuv);\n              }\n              // reverse the left half so we get a counterclockwise circle:\n              prevpolygon.outpolygon.leftpoints.reverse();\n              prevpolygon.outpolygon.leftuvcoordinates.reverse();\n              const points2d = prevpolygon.outpolygon.rightpoints.concat(prevpolygon.outpolygon.leftpoints);\n              const uvcoordinates = prevpolygon.outpolygon.rightuvcoordinates.concat(prevpolygon.outpolygon.leftuvcoordinates);\n              const vertices3d: any[] = [];\n              points2d.map((point2d: any, i: any) => {\n                const point3d = orthobasis.to3D(point2d);\n                const vertex3d = Vertex3.fromPosAndUV(point3d, uvcoordinates[i]);\n                vertices3d.push(vertex3d);\n              });\n              const polygon = new Polygon3(vertices3d, shared, plane);\n              destpolygons.push(polygon);\n            }\n          }\n        }\n\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < newoutpolygonrow.length; i++) {\n          const thispolygon: any = newoutpolygonrow[i];\n          if (!thispolygon.outpolygon) {\n            // polygon starts here:\n            thispolygon.outpolygon = {\n              leftpoints: [],\n              leftuvcoordinates: [],\n              rightpoints: [],\n              rightuvcoordinates: [],\n            };\n            thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);\n            thispolygon.outpolygon.leftuvcoordinates.push(thispolygon.topleftuv);\n            if (thispolygon.topleft.distanceTo(thispolygon.topright) > EPS) {\n              // we have a horizontal line at the top:\n              thispolygon.outpolygon.rightpoints.push(thispolygon.topright);\n              thispolygon.outpolygon.rightuvcoordinates.push(thispolygon.toprightuv);\n            }\n          } else {\n            // continuation of a previous row\n            if (!thispolygon.leftlinecontinues) {\n              thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);\n              thispolygon.outpolygon.leftuvcoordinates.push(thispolygon.topleftuv);\n            }\n            if (!thispolygon.rightlinecontinues) {\n              thispolygon.outpolygon.rightpoints.push(thispolygon.topright);\n              thispolygon.outpolygon.rightuvcoordinates.push(thispolygon.toprightuv);\n            }\n          }\n        }\n\n        prevoutpolygonrow = newoutpolygonrow;\n      }\n    }\n  }\n};\n\n","/**\n * Insert Sorted\n * @param array\n * @param element\n * @param comparefunc\n */\nexport function insertSorted(array: any[], element: any, comparefunc: any) {\n  let leftbound = 0;\n  let rightbound = array.length;\n  while (rightbound > leftbound) {\n    const testindex = Math.floor((leftbound + rightbound) / 2);\n    const testelement = array[testindex];\n    const compareresult = comparefunc(element, testelement);\n    if (compareresult > 0) // element > testelement\n    {\n      leftbound = testindex + 1;\n    } else {\n      rightbound = testindex;\n    }\n  }\n  array.splice(leftbound, 0, element);\n}\n","import {Vector2} from '@core/math';\n\n/**\n * Get the x coordinate of a point with a certain y coordinate, interpolated between two points (CSG.Vector2D).\n * Interpolation is robust even if the points have the same y coordinate\n * @param point1\n * @param point2\n * @param y\n */\nexport const interpolateBetween2DPointsForY = (point1: Vector2, point2: Vector2, y: number) => {\n  let f1 = y - point1.y;\n  let f2 = point2.y - point1.y;\n  if (f2 < 0) {\n    f1 = -f1;\n    f2 = -f2;\n  }\n  let t;\n  if (f1 <= 0) {\n    t = 0.0;\n  } else if (f1 >= f2) {\n    t = 1.0;\n  } else if (f2 < 1e-10) { // FIXME Should this be CSG.EPS?\n    t = 0.5;\n  } else {\n    t = f1 / f2;\n  }\n  const result = point1.x + t * (point2.x - point1.x);\n  return result;\n};\n","import {Vector3} from '@core/math';\nimport {CSG} from '@core/CSG';\n\n/**\n * Returns an array of Vector3D, providing minimum coordinates and maximum coordinates\n * of this solid.\n * @returns {Vector3D[]}\n * @example\n * let bounds = A.getBounds()\n * let minX = bounds[0].x\n */\nexport const bounds = (csg: CSG) => {\n  if (!csg.cachedBoundingBox) {\n    let minpoint = new Vector3(0, 0, 0);\n    let maxpoint = new Vector3(0, 0, 0);\n    const polygons = csg.polygons;\n    const numpolygons = polygons.length;\n    for (let i = 0; i < numpolygons; i++) {\n      const polygon = polygons[i];\n      const _bounds = polygon.boundingBox();\n      if (i === 0) {\n        minpoint = _bounds[0];\n        maxpoint = _bounds[1];\n      } else {\n        minpoint = minpoint.min(_bounds[0]);\n        maxpoint = maxpoint.max(_bounds[1]);\n      }\n    }\n    // FIXME: not ideal, we are mutating the input, we need to move some of it out\n    csg.cachedBoundingBox = [minpoint, maxpoint];\n  }\n  return csg.cachedBoundingBox;\n};\n\n/**\n * Get CSG Volume\n * @param csg\n */\nexport const volume = (csg: CSG) => {\n  const result = csg.toTriangles().map((triPoly: any) => {\n    return triPoly.getTetraFeatures(['volume']);\n  });\n  // tslint:disable-next-line:no-console\n  console.log('volume', result);\n  return result;\n};\n\n/**\n * Get CSG Area\n * @param csg\n */\nexport const area = (csg: CSG) => {\n  const result = csg.toTriangles().map((triPoly: any) => {\n    return triPoly.getTetraFeatures(['area']);\n  });\n  // tslint:disable-next-line:no-console\n  console.log('area', result);\n  return result;\n};\n","import {EPS} from '@core/constants';\nimport {CSG} from '@core/CSG';\nimport {CAG} from '@core/CAG';\nimport {OrthoNormalBasis} from '@core/math';\n\n/**\n * Project the 3D CSG onto a plane\n * This returns a 2D CAG with the 'shadow' shape of the 3D solid when projected onto the\n * plane represented by the orthonormal basis\n * @param csg\n * @param orthobasis\n */\nexport const projectToOrthoNormalBasis = (csg: CSG, orthobasis: OrthoNormalBasis) => {\n  const cags: CAG[] = [];\n\n  csg.polygons\n    .filter((p) => {\n      // only return polys in plane, others may disturb result\n      return p.plane.normal.minus(orthobasis.plane.normal).lengthSquared() < (EPS * EPS);\n    })\n    .map((polygon) => {\n      const cag = polygon.projectToOrthoNormalBasis(orthobasis);\n      if (cag.sides.length > 0) {\n        cags.push(cag);\n      }\n    });\n\n  const result = new CAG().union(cags);\n  return result;\n};\n","import {EPS} from '@core/constants';\nimport {OrthoNormalBasis, Plane, Polygon3, Vector2, Vertex3} from '@core/math';\nimport {CSG} from '@core/CSG';\n\n/**\n * cuts a csg along a orthobasis\n * @param  {CSG} csg the csg object to cut\n * @param  {Orthobasis} orthobasis the orthobasis to cut along\n */\nexport const sectionCut = (csg: CSG, orthobasis: OrthoNormalBasis) => {\n  let plane1 = orthobasis.plane;\n  let plane2 = orthobasis.plane.flipped();\n  plane1 = new Plane(plane1.normal, plane1.w);\n  plane2 = new Plane(plane2.normal, plane2.w + (5 * EPS));\n  let cut3d = csg.cutByPlane(plane1);\n  cut3d = cut3d.cutByPlane(plane2);\n  return cut3d.projectToOrthoNormalBasis(orthobasis);\n};\n\n/**\n * Cut the solid by a plane. Returns the solid on the back side of the plane\n * @param csg\n * @param {Plane} plane\n * @returns {CSG} the solid on the back side of the plane\n */\nexport const cutByPlane = (csg: CSG, plane: Plane) => {\n  if (csg.polygons.length === 0) {\n    return new CSG();\n  }\n  // Ideally we would like to do an intersection with a polygon of inifinite size\n  // but this is not supported by our implementation. As a workaround, we will create\n  // a cube, with one face on the plane, and a size larger enough so that the entire\n  // solid fits in the cube.\n  // find the max distance of any vertex to the center of the plane:\n  const planecenter = plane.normal.times(plane.w);\n  let maxdistance = 0;\n  csg.polygons.map((_polygon: any) => {\n    _polygon.vertices.map((vertex: any) => {\n      const distance = vertex.pos.distanceToSquared(planecenter);\n      if (distance > maxdistance) maxdistance = distance;\n    });\n  });\n  maxdistance = Math.sqrt(maxdistance);\n  maxdistance *= 1.01; // make sure it's really larger\n  // Now build a polygon on the plane, at any point farther than maxdistance from the plane center:\n  const vertices = [];\n  const orthobasis = new OrthoNormalBasis(plane);\n  vertices.push(Vertex3.fromPosAndUV(orthobasis.to3D(new Vector2(maxdistance, -maxdistance)),\n    new Vector2(maxdistance, -maxdistance)));\n  vertices.push(Vertex3.fromPosAndUV(orthobasis.to3D(new Vector2(-maxdistance, -maxdistance)),\n    new Vector2(-maxdistance, -maxdistance)));\n  vertices.push(Vertex3.fromPosAndUV(orthobasis.to3D(new Vector2(-maxdistance, maxdistance)),\n    new Vector2(-maxdistance, maxdistance)));\n  vertices.push(Vertex3.fromPosAndUV(orthobasis.to3D(new Vector2(maxdistance, maxdistance)),\n    new Vector2(maxdistance, maxdistance)));\n  const polygon = new Polygon3(vertices, null, plane.flipped());\n\n  // and extrude the polygon into a cube, backwards of the plane:\n  const cube = polygon.extrude(plane.normal.times(-maxdistance));\n\n  // Now we can do the intersection:\n  const result = csg.intersect(cube);\n  result.properties = csg.properties; // keep original properties\n  return result;\n};\n","import {expandedShellOfCCSG} from './expandedShellOfCCSG';\nimport {expandedShellOfCAG} from './expandedShellOfCAG';\nimport {isCSG} from '@core/utils/isCSG';\n\n/**\n * Expand\n * @param shape\n * @param radius\n * @param resolution\n */\nexport const expand = (shape: any, radius: number, resolution: number) => {\n  let result;\n  if (isCSG(shape)) {\n    result = shape.union(expandedShellOfCCSG(shape, radius, resolution));\n    result = result.reTesselated();\n    result.properties = shape.properties; // keep original properties\n  } else {\n    result = shape.union(expandedShellOfCAG(shape, radius, resolution));\n  }\n  return result;\n};\n\n","import {expandedShellOfCCSG} from './expandedShellOfCCSG';\nimport {expandedShellOfCAG} from './expandedShellOfCAG';\nimport {isCSG} from '@core/utils/isCSG';\n\n/**\n * Contract\n * @param shape\n * @param radius\n * @param resolution\n */\nexport const contract = (shape: any, radius: number, resolution: number) => {\n  let result;\n  if (isCSG(shape)) {\n    result = shape.subtract(expandedShellOfCCSG(shape, radius, resolution));\n    result = result.reTesselated();\n    result.properties = shape.properties; // keep original properties\n  } else {\n    result = shape.subtract(expandedShellOfCAG(shape, radius, resolution));\n  }\n  return result;\n};\n","import {Path2D, TVector3Universal, Vector3} from '@core/math';\nimport {Connector} from '@core/Connector';\nimport {fromPolygons} from '@core/CSGFactories';\n\nexport class ConnectorList {\n  closed = false;\n  connectorsList: Connector[];\n\n  static defaultNormal = [0, 0, 1];\n\n  /**\n   * make ConnectorList from Path2D\n   * @param path2D\n   * @param arg1\n   * @param arg2\n   */\n  static fromPath2D(path2D: Path2D, arg1: TVector3Universal, arg2: TVector3Universal) {\n    if (arguments.length === 3) {\n      return ConnectorList._fromPath2DTangents(path2D, arg1, arg2);\n    } else if (arguments.length === 2) {\n      return ConnectorList._fromPath2DExplicit(path2D, arg1);\n    } else {\n      throw new Error('call with path2D and either 2 direction vectors, or a function returning direction vectors');\n    }\n  };\n\n  /**\n   * calculate the connector axisvectors by calculating the \"tangent\" for path2D.\n   * This is undefined for start and end points, so axis for these have to be manually\n   * provided.\n   * @param path2D\n   * @param start\n   * @param end\n   * @private\n   */\n  static _fromPath2DTangents(path2D: Path2D, start: TVector3Universal, end: TVector3Universal) {\n    // path2D\n    let axis;\n    const pathLen = path2D.points.length;\n    const result = new ConnectorList([\n      new Connector(path2D.points[0], start, ConnectorList.defaultNormal),\n    ]);\n    // middle points\n    path2D.points.slice(1, pathLen - 1).forEach((p2: any, i: any) => {\n      axis = path2D.points[i + 2].minus(path2D.points[i]).toVector3D(0);\n      result.appendConnector(\n        new Connector(p2.toVector3D(0), axis, ConnectorList.defaultNormal),\n      );\n    }, this);\n    result.appendConnector(\n      new Connector(path2D.points[pathLen - 1], end, ConnectorList.defaultNormal),\n    );\n\n    result.closed = path2D.closed;\n    return result;\n  };\n\n  /**\n   * From Path2D Explicit\n   * angleIsh: either a static angle, or a function(point) returning an angle\n   * @param path2D\n   * @param angleIsh\n   * @private\n   */\n  static _fromPath2DExplicit(path2D: Path2D, angleIsh: any) {\n\n    function getAngle(angleIshVal: any, pt: any, i: any) {\n      if (typeof angleIshVal === 'function') {\n        angleIshVal = angleIshVal(pt, i);\n      }\n      return angleIshVal;\n    }\n\n    const result = new ConnectorList(\n      path2D.points.map((p2, i) => {\n        return new Connector(p2.toVector3D(0),\n          Vector3.Create(1, 0, 0).rotateZ(getAngle(angleIsh, p2, i)),\n          ConnectorList.defaultNormal);\n      }, this),\n    );\n    result.closed = path2D.closed;\n    return result;\n  };\n\n  /**\n   * ConnectorList Constructor\n   */\n  constructor(connectors: Connector[]) {\n    this.connectorsList = [...connectors];\n  }\n\n  /**\n   * Set Closed\n   * @param closed\n   */\n  setClosed(closed: boolean) {\n    this.closed = !!closed;\n  }\n\n  /**\n   * Append Connector\n   * @param conn\n   */\n  appendConnector(conn: Connector) {\n    this.connectorsList.push(conn);\n  }\n\n  /**\n   * Follow With\n   * arguments: cagish: a cag or a function(connector) returning a cag\n   *            closed: whether the 3d path defined by connectors location\n   *              should be closed or stay open\n   *              Note: don't duplicate connectors in the path\n   * TODO: consider an option \"maySelfIntersect\" to close & force union all single segments\n   * @param cagish\n   */\n  followWith(cagish: any) {\n    this.verify();\n\n    function getCag(cagishVal: any, connector: Connector) {\n      if (typeof cagishVal === 'function') {\n        cagishVal = cagishVal(connector.point, connector.axisvector, connector.normalvector);\n      }\n      return cagishVal;\n    }\n\n    const polygons: any[] = [];\n    let currCag;\n    let prevConnector = this.connectorsList[this.connectorsList.length - 1];\n    let prevCag = getCag(cagish, prevConnector);\n\n    // add walls\n\n    this.connectorsList.forEach((connector, notFirst) => {\n      currCag = getCag(cagish, connector);\n      if (notFirst || this.closed) {\n        polygons.push.apply(polygons, prevCag._toWallPolygons({\n          toConnector1: prevConnector, toConnector2: connector, cag: currCag,\n        }));\n      } else {\n        // it is the first, and shape not closed -> build start wall\n        polygons.push.apply(polygons,\n          currCag._toPlanePolygons({toConnector: connector, flipped: true}));\n      }\n\n      if (notFirst === this.connectorsList.length - 1 && !this.closed) {\n        // build end wall\n        polygons.push.apply(polygons,\n          currCag._toPlanePolygons({toConnector: connector}));\n      }\n      prevCag = currCag;\n      prevConnector = connector;\n    });\n\n    return fromPolygons(polygons).reTesselated().canonicalized();\n  }\n\n  /**\n   * Verify\n   * general idea behind these checks: connectors need to have smooth transition from one to another\n   * TODO: add a check that 2 follow-on CAGs are not intersecting\n   */\n  verify() {\n    let connI;\n    let connI1;\n    for (let i = 0; i < this.connectorsList.length - 1; i++) {\n      connI = this.connectorsList[i];\n      connI1 = this.connectorsList[i + 1];\n      if (connI1.point.minus(connI.point).dot(connI.axisvector) <= 0) {\n        throw new Error('Invalid ConnectorList. Each connectors position needs to be within a <90deg range of previous connectors axisvector');\n      }\n      if (connI.axisvector.dot(connI1.axisvector) <= 0) {\n        throw new Error('invalid ConnectorList. No neighboring connectors axisvectors may span a >=90deg angle');\n      }\n    }\n  }\n}\n","import {getTag} from '@core/constants';\nimport {Matrix4x4, Polygon3, TransformationMethods, Vector2, Vertex2, Vertex3} from '.';\n\n/**\n * Side\n * @class Side\n */\nexport class Side extends TransformationMethods {\n  vertex0: Vertex2;\n  vertex1: Vertex2;\n  tag?: number;\n\n  /**\n   * make from object\n   * @param obj\n   */\n  static fromObject(obj: Side) {\n    const vertex0 = Vertex2.fromObject(obj.vertex0);\n    const vertex1 = Vertex2.fromObject(obj.vertex1);\n    return new Side(vertex0, vertex1);\n  };\n\n  /**\n   * from fake polygon\n   * @param polygon\n   * @private\n   */\n  static _fromFakePolygon(polygon: Polygon3) {\n    // this can happen based on union, seems to be residuals -\n    // return null and handle in caller\n    if (polygon.vertices.length < 4) {\n      return null;\n    }\n    const vert1Indices: number[] = [];\n    const pts2d = polygon.vertices\n      .filter((v, i) => {\n        if (v.pos.z > 0) {\n          vert1Indices.push(i);\n          return true;\n        }\n        return false;\n      })\n      .map((v) => {\n        return new Vector2(v.pos.x, v.pos.y);\n      });\n\n    if (pts2d.length !== 2) {\n      throw new Error('Assertion failed: _fromFakePolygon: not enough points found');\n    }\n\n    const d = vert1Indices[1] - vert1Indices[0];\n    if (d === 1 || d === 3) {\n      if (d === 1) {\n        pts2d.reverse();\n      }\n    } else {\n      throw new Error('Assertion failed: _fromFakePolygon: unknown index ordering');\n    }\n\n    const result = new Side(new Vertex2(pts2d[0]), new Vertex2(pts2d[1]));\n    return result;\n  };\n\n  /**\n   * Side Constructor\n   * @param vertex0\n   * @param vertex1\n   */\n  constructor(vertex0: Vertex2, vertex1: Vertex2) {\n    super();\n    this.vertex0 = vertex0;\n    this.vertex1 = vertex1;\n  }\n\n  /**\n   * To String Helper\n   */\n  toString() {\n    return this.vertex0 + ' -> ' + this.vertex1;\n  }\n\n  /**\n   * Convert to Polygon3\n   * @param z0\n   * @param z1\n   */\n  toPolygon3D(z0: number, z1: number) {\n    // console.log(this.vertex0.pos)\n    const vertices = [\n      new Vertex3(this.vertex0.pos.toVector3D(z0)),\n      new Vertex3(this.vertex1.pos.toVector3D(z0)),\n      new Vertex3(this.vertex1.pos.toVector3D(z1)),\n      new Vertex3(this.vertex0.pos.toVector3D(z1)),\n    ];\n    return new Polygon3(vertices);\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Side {\n    const newp1 = this.vertex0.pos.transform(matrix4x4);\n    const newp2 = this.vertex1.pos.transform(matrix4x4);\n    return new Side(new Vertex2(newp1), new Vertex2(newp2));\n  }\n\n  /**\n   * Get Flipped side\n   */\n  flipped() {\n    return new Side(this.vertex1, this.vertex0);\n  }\n\n  /**\n   * Get Direction\n   */\n  direction() {\n    return this.vertex1.pos.minus(this.vertex0.pos);\n  }\n\n  /**\n   * Get Tag\n   */\n  getTag() {\n    let result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  }\n\n  /**\n   * Length Squared\n   */\n  lengthSquared() {\n    const x = this.vertex1.pos.x - this.vertex0.pos.x;\n    const y = this.vertex1.pos.y - this.vertex0.pos.y;\n    return x * x + y * y;\n  }\n\n  /**\n   * Get Length\n   */\n  length() {\n    return Math.sqrt(this.lengthSquared());\n  }\n}\n","import {Matrix4x4, TransformationMethods, Vector3} from '.';\n\nexport type TVector2Universal = Vector2 | Vector3 | [number, number] | number[] | { x?: number | string, y?: number | string };\n\n/**\n * Represents a 2D vector with X, Y coordinates\n * @class Vector2\n * @constructor\n *\n * @example\n * new CSG.Vector2(1, 2);\n * new CSG.Vector2([1, 2]);\n * new CSG.Vector2({ x: 1, y: 2});\n */\nexport class Vector2 extends TransformationMethods {\n  _x: number;\n  _y: number;\n\n  /**\n   * make from angle\n   * @param radians\n   */\n  static fromAngle(radians: number) {\n    return Vector2.fromAngleRadians(radians);\n  };\n\n  /**\n   * make from angle in degrees\n   * @param degrees\n   */\n  static fromAngleDegrees(degrees: number) {\n    const radians = Math.PI * degrees / 180;\n    return Vector2.fromAngleRadians(radians);\n  };\n\n  /**\n   * make from angle in radians\n   * @param radians\n   */\n  static fromAngleRadians(radians: number) {\n    return Vector2.Create(Math.cos(radians), Math.sin(radians));\n  };\n\n  /**\n   * This does the same as new Vector2(x,y) but it doesn't go through the constructor and the parameters are not validated. Is much faster.\n   * @param x\n   * @param y\n   * @constructor\n   */\n  static Create(x: number, y: number) {\n    return new Vector2(x, y);\n  };\n\n  /**\n   * Vector2 Constructor\n   * @param x\n   * @param y\n   */\n  constructor(x?: number | string | TVector2Universal, y?: number | string) {\n    super();\n    if (typeof x === 'object' && x !== null) {\n      if (Array.isArray(x)) {\n        this._x = x[0] || 0;\n        this._y = x[1] || 0;\n      } else if (x instanceof Vector2 || x instanceof Vector3) {\n        this._x = x.x;\n        this._y = x.y;\n      } else {\n        this._x = ('x' in x ? (typeof x.x === 'string' ? parseFloat(x.x) : x.x) : 0) || 0;\n        this._y = ('y' in x ? (typeof x.y === 'string' ? parseFloat(x.y) : x.y) : 0) || 0;\n      }\n    } else {\n      this._x = (typeof x === 'string' ? parseFloat(x) : x) || 0;\n      this._y = (typeof y === 'string' ? parseFloat(y) : y) || 0;\n    }\n// throw new Error('wrong arguments');\n  }\n\n  /**\n   * Get X\n   */\n  get x() {\n    return this._x;\n  }\n\n  /**\n   * Set X is not allowed, Vector2 is immutable\n   * @param v\n   */\n  set x(v: number) {\n    throw new Error('Vector2 is immutable');\n  }\n\n  /**\n   * Get Y\n   */\n  get y() {\n    return this._y;\n  }\n\n  /**\n   * Set Y is not allowed, Vector2 is immutable\n   * @param v\n   */\n  set y(v: number) {\n    throw new Error('Vector2 is immutable');\n  }\n\n  /**\n   * extend to a 3D vector by adding a z coordinate:\n   * @param z\n   */\n  toVector3D(z = 0) {\n    return new Vector3(this._x, this._y, z);\n  }\n\n  /**\n   * is vectors equal\n   * @param a\n   */\n  equals(a: Vector2) {\n    return (this._x === a._x) && (this._y === a._y);\n  }\n\n  /**\n   * Clone\n   */\n  clone() {\n    return Vector2.Create(this._x, this._y);\n  }\n\n  /**\n   * return negated vector\n   */\n  negated() {\n    return Vector2.Create(-this._x, -this._y);\n  }\n\n  /**\n   * Plus\n   * @param a\n   */\n  plus(a: Vector2) {\n    return Vector2.Create(this._x + a._x, this._y + a._y);\n  }\n\n  /**\n   * Minus\n   * @param a\n   */\n  minus(a: Vector2) {\n    return Vector2.Create(this._x - a._x, this._y - a._y);\n  }\n\n  /**\n   * scalar scale\n   * @param a\n   */\n  times(a: number) {\n    return Vector2.Create(this._x * a, this._y * a);\n  }\n\n  /**\n   * divided by value\n   * @param a\n   */\n  dividedBy(a: number) {\n    return Vector2.Create(this._x / a, this._y / a);\n  }\n\n  /**\n   * Find The Dot Product Of Two Vectors\n   * @param a\n   */\n  dot(a: Vector2) {\n    return this._x * a._x + this._y * a._y;\n  }\n\n  /**\n   * Lerp\n   * @param a\n   * @param t\n   */\n  lerp(a: Vector2, t: number) {\n    return this.plus(a.minus(this).times(t));\n  }\n\n  /**\n   * Vector length\n   */\n  length() {\n    return Math.sqrt(this.dot(this));\n  }\n\n  /**\n   * Distance to point\n   * @param a\n   */\n  distanceTo(a: Vector2) {\n    return this.minus(a).length();\n  }\n\n  /**\n   * Squared distance between two points\n   * @param a\n   */\n  distanceToSquared(a: Vector2) {\n    return this.minus(a).lengthSquared();\n  }\n\n  /**\n   * Squared Length\n   */\n  lengthSquared() {\n    return this.dot(this);\n  }\n\n  /**\n   * Unit Vector\n   */\n  unit() {\n    return this.dividedBy(this.length());\n  }\n\n  /**\n   * Cross product\n   * @param a\n   */\n  cross(a: Vector2) {\n    return this._x * a._y - this._y * a._x;\n  }\n\n  /**\n   * returns the vector rotated by 90 degrees clockwise\n   */\n  normal() {\n    return Vector2.Create(this._y, -this._x);\n  }\n\n  /**\n   * Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)\n   * Returns a new Vector2\n   * @param matrix4x4\n   */\n  multiply4x4(matrix4x4: Matrix4x4) {\n    return matrix4x4.leftMultiply1x2Vector(this);\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Vector2 {\n    return matrix4x4.leftMultiply1x2Vector(this);\n  }\n\n  /**\n   * Get rotation angle in radians\n   */\n  angle() {\n    return this.angleRadians();\n  }\n\n  /**\n   * Get rotation angle in degrees\n   */\n  angleDegrees() {\n    const radians = this.angleRadians();\n    return 180 * radians / Math.PI;\n  }\n\n  /**\n   * Get rotation angle in radians\n   */\n  angleRadians() {\n    // y=sin, x=cos\n    return Math.atan2(this._y, this._x);\n  }\n\n  /**\n   * get min vector components\n   * @param p\n   */\n  min(p: Vector2) {\n    return Vector2.Create(\n      Math.min(this._x, p._x), Math.min(this._y, p._y));\n  }\n\n  /**\n   * get max vector components\n   * @param p\n   */\n  max(p: Vector2) {\n    return Vector2.Create(\n      Math.max(this._x, p._x), Math.max(this._y, p._y));\n  }\n\n  /**\n   * To String helper\n   */\n  toString() {\n    return '(' + this._x.toFixed(5) + ', ' + this._y.toFixed(5) + ')';\n  }\n\n  /**\n   * Module of a vector\n   */\n  abs() {\n    return Vector2.Create(Math.abs(this._x), Math.abs(this._y));\n  }\n}\n","import {Matrix4x4, TransformationMethods, Vector2} from '.';\n\nexport type TVector3Universal = Vector3 | Vector2 | { x?: number | string, y?: number | string, z?: number | string } | [number, number, number] | number[];\n\n/**\n * Class Vector3\n * Represents a 3D vector with X, Y, Z coordinates.\n * @constructor\n *\n * @example\n * new CSG.Vector3(1, 2, 3);\n * new CSG.Vector3([1, 2, 3]);\n * new CSG.Vector3({ x: 1, y: 2, z: 3 });\n * new CSG.Vector3(1, 2); // assumes z=0\n * new CSG.Vector3([1, 2]); // assumes z=0\n */\nexport class Vector3 extends TransformationMethods {\n  _x: number;\n  _y: number;\n  _z: number;\n\n  /**\n   * Make Vector3\n   * This does the same as new Vector3(x,y,z) but it doesn't go through the constructor\n   * and the parameters are not validated. Is much faster.\n   * @param x\n   * @param y\n   * @param z\n   * @constructor\n   */\n  static Create(x: number, y: number, z: number) {\n    return new Vector3(x, y, z);\n  };\n\n  /**\n   * Vector3 Constructor\n   */\n  constructor(x?: number | string | TVector3Universal, y?: number | string, z?: number | string) {\n    super();\n    if (typeof x === 'object') {\n      if (Array.isArray(x)) {\n        this._x = x[0] || 0;\n        this._y = x[1] || 0;\n        this._z = x[2] || 0;\n      } else if (x instanceof Vector2) {\n        this._x = x.x;\n        this._y = x.y;\n        this._z = 0;\n      } else if (x instanceof Vector3) {\n        this._x = x.x;\n        this._y = x.y;\n        this._z = x.z;\n      } else {\n        this._x = ('x' in x ? (typeof x.x === 'string' ? parseFloat(x.x) : x.x) : 0) || 0;\n        this._y = ('y' in x ? (typeof x.y === 'string' ? parseFloat(x.y) : x.y) : 0) || 0;\n        this._z = ('z' in x ? (typeof x.z === 'string' ? parseFloat(x.z) : x.z) : 0) || 0;\n      }\n    } else {\n      this._x = (typeof x === 'string' ? parseFloat(x) : x) || 0;\n      this._y = (typeof y === 'string' ? parseFloat(y) : y) || 0;\n      this._z = (typeof z === 'string' ? parseFloat(z) : z) || 0;\n    }\n  }\n\n  /**\n   * Set X is not allowed. Vector3 is immutable\n   * @param v\n   */\n  set x(v) {\n    throw new Error('Vector3 is immutable');\n  }\n\n  /**\n   * Get X component\n   */\n  get x() {\n    return this._x;\n  }\n\n  /**\n   * Set Y is not allowed. Vector3 is immutable\n   * @param v\n   */\n  set y(v) {\n    throw new Error('Vector3 is immutable');\n  }\n\n  /**\n   * Get Y component\n   */\n  get y() {\n    return this._y;\n  }\n\n  /**\n   * Set Z is not allowed. Vector3 is immutable\n   * @param v\n   */\n  set z(v) {\n    throw new Error('Vector3 is immutable');\n  }\n\n  /**\n   * get Z component\n   */\n  get z() {\n    return this._z;\n  }\n\n  /**\n   * Clone Vector3\n   */\n  clone() {\n    return Vector3.Create(this._x, this._y, this._z);\n  }\n\n  /**\n   * Get negated vector\n   */\n  negated() {\n    return Vector3.Create(-this._x, -this._y, -this._z);\n  }\n\n  /**\n   * get module\n   */\n  abs() {\n    return Vector3.Create(Math.abs(this._x), Math.abs(this._y), Math.abs(this._z));\n  }\n\n  /**\n   * Plus\n   * @param a\n   */\n  plus(a: Vector3) {\n    return Vector3.Create(this._x + a._x, this._y + a._y, this._z + a._z);\n  }\n\n  /**\n   * Minus\n   * @param a\n   */\n  minus(a: Vector3) {\n    return Vector3.Create(this._x - a._x, this._y - a._y, this._z - a._z);\n  }\n\n  /**\n   * scale this vector by scalar and return a new vector\n   * @param a\n   */\n  times(a: number) {\n    return Vector3.Create(this._x * a, this._y * a, this._z * a);\n  }\n\n  /**\n   * divide this vector by scalar and return a new vector\n   * @param a\n   */\n  dividedBy(a: number) {\n    return Vector3.Create(this._x / a, this._y / a, this._z / a);\n  }\n\n  /**\n   * Find The Dot Product Of Two Vectors\n   * @param a\n   */\n  dot(a: Vector3) {\n    return this._x * a._x + this._y * a._y + this._z * a._z;\n  }\n\n  /**\n   * Lerp\n   * @param a\n   * @param t\n   */\n  lerp(a: Vector3, t: number) {\n    return this.plus(a.minus(this).times(t));\n  }\n\n  /**\n   * get Squared Length\n   */\n  lengthSquared() {\n    return this.dot(this);\n  }\n\n  /**\n   * Get Length\n   */\n  length() {\n    return Math.sqrt(this.lengthSquared());\n  }\n\n  /**\n   * Get Unit Vector\n   */\n  unit() {\n    return this.dividedBy(this.length());\n  }\n\n  /**\n   * Cross Product\n   * @param a\n   */\n  cross(a: Vector3) {\n    return Vector3.Create(\n      this._y * a._z - this._z * a._y, this._z * a._x - this._x * a._z, this._x * a._y - this._y * a._x);\n  }\n\n  /**\n   * Distance to point\n   * @param a\n   */\n  distanceTo(a: Vector3) {\n    return this.minus(a).length();\n  }\n\n  /**\n   * Squared distance to point\n   * @param a\n   */\n  distanceToSquared(a: Vector3) {\n    return this.minus(a).lengthSquared();\n  }\n\n  /**\n   * is Vector Equals\n   * @param a\n   */\n  equals(a: Vector3) {\n    return (this._x === a._x) && (this._y === a._y) && (this._z === a._z);\n  }\n\n  /**\n   * Right multiply by a 4x4 matrix (the vector is interpreted as a row vector)\n   * Returns a new Vector3\n   * @param matrix4x4\n   */\n  multiply4x4(matrix4x4: Matrix4x4) {\n    return matrix4x4.leftMultiply1x3Vector(this);\n  }\n\n  /**\n   * Transform helper\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Vector3 {\n    return matrix4x4.leftMultiply1x3Vector(this);\n  }\n\n  /**\n   * To string helper\n   */\n  toString() {\n    return '(' + this._x.toFixed(5) + ', ' + this._y.toFixed(5) + ', ' + this._z.toFixed(5) + ')';\n  }\n\n  /**\n   * find a vector that is somewhat perpendicular to this one\n   */\n  randomNonParallelVector() {\n    const abs = this.abs();\n    if ((abs._x <= abs._y) && (abs._x <= abs._z)) {\n      return Vector3.Create(1, 0, 0);\n    } else if ((abs._y <= abs._x) && (abs._y <= abs._z)) {\n      return Vector3.Create(0, 1, 0);\n    } else {\n      return Vector3.Create(0, 0, 1);\n    }\n  }\n\n  /**\n   * get min vector components\n   * @param p\n   */\n  min(p: Vector3) {\n    return Vector3.Create(\n      Math.min(this._x, p._x), Math.min(this._y, p._y), Math.min(this._z, p._z));\n  }\n\n  /**\n   * get max vector components\n   * @param p\n   */\n  max(p: Vector3) {\n    return Vector3.Create(\n      Math.max(this._x, p._x), Math.max(this._y, p._y), Math.max(this._z, p._z));\n  }\n}\n","import {getTag} from '@core/constants';\nimport {Vector2} from '.';\n\n/**\n * Vertex2\n * @class Vertex2\n */\nexport class Vertex2 { // extends TransformationMethods\n  tag?: number;\n\n  /**\n   * From Object\n   * @param obj\n   */\n  static fromObject(obj: any) {\n    return new Vertex2(new Vector2(obj.pos._x, obj.pos._y));\n  }\n\n  /**\n   * Vertex2 constructor\n   * @param pos\n   */\n  constructor(public pos: Vector2) {\n  }\n\n  /**\n   * To String helper\n   */\n  toString() {\n    return '(' + this.pos.x.toFixed(5) + ',' + this.pos.y.toFixed(5) + ')';\n  }\n\n  /**\n   * Get Tag\n   */\n  getTag() {\n    let result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  }\n}\n","import {getTag} from '@core/constants';\nimport {Matrix4x4, TransformationMethods, TVector3Universal, Vector2, Vector3} from '.';\n\n/**\n * Represents a vertex of a polygon. Use your own vertex class instead of this\n * one to provide additional features like texture coordinates and vertex\n * colors. Custom vertex classes need to provide a `pos` property\n * `flipped()`, and `interpolate()` methods that behave analogous to the ones\n * FIXME: And a lot MORE (see plane.fromVector3Ds for ex) ! This is fragile code\n * defined by `Vertex`.\n */\nexport class Vertex3 extends TransformationMethods {\n  uv = new Vector2(0, 0);\n  tag?: number;\n\n  /**\n   * create from an untyped object with identical property names:\n   * @param obj\n   */\n  static fromObject(obj: { pos: TVector3Universal }) {\n    const pos = new Vector3(obj.pos);\n    return new Vertex3(pos);\n  }\n\n  /**\n   * create with position and uv coordinates\n   * @param pos\n   * @param uv\n   */\n  static fromPosAndUV(pos: Vector3, uv: Vector2) {\n    const newVertex = new Vertex3(pos);\n    newVertex.uv = uv;\n    return newVertex;\n  };\n\n  /**\n   * Vertex3 constructor\n   * @param pos\n   */\n  constructor(public pos: Vector3) {\n    super();\n  }\n\n  /**\n   * Return a vertex with all orientation-specific data (e.g. vertex normal) flipped. Called when the\n   * orientation of a polygon is flipped.\n   */\n  flipped() {\n    return this;\n  }\n\n  /**\n   * Get Tag\n   */\n  getTag() {\n    let result = this.tag;\n    if (!result) {\n      result = getTag();\n      this.tag = result;\n    }\n    return result;\n  }\n\n  /**\n   * Create a new vertex between this vertex and `other` by linearly\n   * interpolating all properties using a parameter of `t`. Subclasses should\n   * override this to interpolate additional properties.\n   * @param other\n   * @param t\n   */\n  interpolate(other: Vertex3, t: number) {\n    const newpos = this.pos.lerp(other.pos, t);\n    const newUv = this.uv.lerp(other.uv, t);\n    return Vertex3.fromPosAndUV(newpos, newUv);\n  }\n\n  /**\n   * Affine transformation of vertex. Returns a new Vertex\n   * @param matrix4x4\n   */\n  transform(matrix4x4: Matrix4x4): Vertex3 {\n    const newpos = this.pos.multiply4x4(matrix4x4);\n    return Vertex3.fromPosAndUV(newpos, this.uv);\n  }\n\n  /**\n   * To String helper\n   */\n  toString() {\n    return this.pos.toString();\n  }\n}\n\n","import {Vector2} from '@core/math';\nimport {CAG} from '@core/CAG';\n\n/**\n * Area of the polygon. For a counter clockwise rotating polygon the area is positive, otherwise negative\n * Note(bebbi): this looks wrong. See polygon getArea()\n * see http://local.wasp.uwa.edu.au/~pbourke/geometry/polyarea/ :\n * @param cag\n */\nexport const area = (cag: CAG) => {\n  let polygonArea = 0;\n  cag.sides.map((side) => {\n    polygonArea += side.vertex0.pos.cross(side.vertex1.pos);\n  });\n  polygonArea *= 0.5;\n  return polygonArea;\n};\n\n/**\n * Get CAG Bounds\n * @param cag\n */\nexport const getBounds = (cag: CAG) => {\n  let minpoint: any;\n  if (cag.sides.length === 0) {\n    minpoint = new Vector2(0, 0);\n  } else {\n    minpoint = cag.sides[0].vertex0.pos;\n  }\n  let maxpoint = minpoint;\n  cag.sides.map((side) => {\n    minpoint = minpoint.min(side.vertex0.pos);\n    minpoint = minpoint.min(side.vertex1.pos);\n    maxpoint = maxpoint.max(side.vertex0.pos);\n    maxpoint = maxpoint.max(side.vertex1.pos);\n  });\n  return [minpoint, maxpoint];\n};\n","import {OrthoNormalBasis} from '@core/math';\nimport {extrudeInOrthonormalBasis} from './extrudeInOrthonormalBasis';\nimport {CAG} from '@core/CAG';\n\n/**\n * Extrude in a standard cartesian plane, specified by two axis identifiers. Each identifier can be\n * one of [\"X\",\"Y\",\"Z\",\"-X\",\"-Y\",\"-Z\"]\n * The 2d x axis will map to the first given 3D axis, the 2d y axis will map to the second.\n * See OrthoNormalBasis.GetCartesian for details.\n * @param  {CAG} cag the cag to extrude\n * @param  {String} axis1 the first axis\n * @param  {String} axis2 the second axis\n * @param  {Float} depth thickness of the extruded shape. Extrusion is done upwards from the plane\n * @param  {Object} [options] - options for construction\n * @param {Boolean} [options.symmetrical=true] - extrude symmetrically in two directions about the plane\n */\nexport const extrudeInPlane = (cag: CAG, axis1: string, axis2: string, depth: number, options: any) => {\n  return extrudeInOrthonormalBasis(cag, OrthoNormalBasis.GetCartesian(axis1, axis2), depth, options);\n};\n","import {defaultResolution3D} from '@core/constants';\nimport {parseOptionAs3DVector, parseOptionAsFloat, parseOptionAsInt} from '@api/optionParsers';\nimport {fromPolygons} from '@core/CSGFactories';\nimport {Connector} from '@core/Connector';\nimport {Vector3} from '@core/math';\nimport {CSG} from '@core/CSG';\n\n/**\n * Linear extrusion of 2D shape, with optional twist\n * @param  {CAG} cag the cag to extrude\n * @param  {Object} [options] - options for construction\n * @param {Array} [options.offset=[0,0,1]] - The 2d shape is placed in in z=0 plane and extruded into direction <offset>\n * (a 3D vector as a 3 component array)\n * @param {Boolean} [options.twiststeps=defaultResolution3D] - twiststeps determines the resolution of the twist (should be >= 1)\n * @param {Boolean} [options.twistangle=0] - twistangle The final face is rotated <twistangle> degrees. Rotation is done around the origin of the 2d shape (i.e. x=0, y=0)\n * @returns {CSG} the extrude shape, as a CSG object\n * @example extruded=cag.extrude({offset: [0,0,10], twistangle: 360, twiststeps: 100});\n */\nexport const extrude = (cag: any, options: any) => {\n  if (cag.sides.length === 0) {\n    // empty! : FIXME: should this throw ?\n    return new CSG();\n  }\n  const offsetVector = parseOptionAs3DVector(options, 'offset', [0, 0, 1]);\n  const twistangle = parseOptionAsFloat(options, 'twistangle', 0);\n  let twiststeps = parseOptionAsInt(options, 'twiststeps', defaultResolution3D);\n  if (offsetVector.z === 0) {\n    throw new Error('offset cannot be orthogonal to Z axis');\n  }\n  if (twistangle === 0 || twiststeps < 1) {\n    twiststeps = 1;\n  }\n  const normalVector = Vector3.Create(0, 1, 0);\n\n  let polygons: any[] = [];\n  // bottom and top\n  polygons = polygons.concat(cag._toPlanePolygons({\n      translation: [0, 0, 0],\n      normalVector,\n      flipped: !(offsetVector.z < 0),\n    },\n  ));\n  polygons = polygons.concat(cag._toPlanePolygons({\n    translation: offsetVector,\n    normalVector: normalVector.rotateZ(twistangle),\n    flipped: offsetVector.z < 0,\n  }));\n  // walls\n  for (let i = 0; i < twiststeps; i++) {\n    const c1 = new Connector(offsetVector.times(i / twiststeps), [0, 0, offsetVector.z],\n      normalVector.rotateZ(i * twistangle / twiststeps));\n    const c2 = new Connector(offsetVector.times((i + 1) / twiststeps), [0, 0, offsetVector.z],\n      normalVector.rotateZ((i + 1) * twistangle / twiststeps));\n    polygons = polygons.concat(cag._toWallPolygons({toConnector1: c1, toConnector2: c2}, i));\n  }\n\n  return fromPolygons(polygons);\n};\n","import {defaultResolution3D, EPS} from '@core/constants';\nimport {parseOptionAsFloat, parseOptionAsInt} from '@api/optionParsers';\nimport {Vector3} from '@core/math';\nimport {Connector} from '@core/Connector';\nimport {fromPolygons} from '@core/CSGFactories';\nimport {CAG} from '@core/CAG';\n\nexport interface IRotateExtrude {\n  angle: number;\n  resolution: number;\n}\n\n// THIS IS AN OLD untested !!! version of rotate extrude\n/**\n * Extrude to into a 3D solid by rotating the origin around the Y axis.\n * (and turning everything into XY plane)\n * @param {Object} options - options for construction\n * @param {Number} [options.angle=360] - angle of rotation\n * @param {Number} [options.resolution=defaultResolution3D] - number of polygons per 360 degree revolution\n * @returns {CSG} new 3D solid\n */\nexport const rotateExtrude = (cag: CAG, options?: Partial<IRotateExtrude>) => {\n  if (options === undefined) {\n    options = {};\n  }\n  let alpha = parseOptionAsFloat(options, 'angle', 360);\n  const resolution = parseOptionAsInt(options, 'resolution', defaultResolution3D);\n\n  alpha = alpha > 360 ? alpha % 360 : alpha;\n  const origin = [0, 0, 0];\n  const axisV = Vector3.Create(0, 1, 0);\n  const normalV = [0, 0, 1];\n  let polygons: any[] = [];\n  // planes only needed if alpha > 0\n  const connS = new Connector(origin, axisV, normalV);\n  if (alpha > 0 && alpha < 360) {\n    // we need to rotate negative to satisfy wall function condition of\n    // building in the direction of axis vector\n    const connE = new Connector(origin, axisV.rotateZ(-alpha), normalV);\n    polygons = polygons.concat(\n      cag._toPlanePolygons({toConnector: connS, flipped: true}));\n    polygons = polygons.concat(\n      cag._toPlanePolygons({toConnector: connE}));\n  }\n  let connT1 = connS;\n  let connT2;\n  const step = alpha / resolution;\n  const iteration = 0;\n  for (let a = step; a <= alpha + EPS; a += step) { // FIXME Should this be angelEPS?\n    connT2 = new Connector(origin, axisV.rotateZ(-a), normalV);\n    polygons = polygons.concat(cag._toWallPolygons(\n      {toConnector1: connT1, toConnector2: connT2}, iteration));\n    connT1 = connT2;\n  }\n  return fromPolygons(polygons).reTesselated();\n};\n","// FIXME: right now linear & rotate extrude take params first, while rectangular_extrude\n// takes params second ! confusing and incoherent ! needs to be changed (BREAKING CHANGE !)\n\n/**\n * linear extrusion of the input 2d shape\n * @param {Object} [options] - options for construction\n * @param {Float} [options.height=1] - height of the extruded shape\n * @param {Integer} [options.slices=10] - number of intermediary steps/slices\n * @param {Integer} [options.twist=0] - angle (in degrees to twist the extusion by)\n * @param {Boolean} [options.center=false] - whether to center extrusion or not\n * @param {CAG} baseShape input 2d shape\n * @returns {CSG} new extruded shape\n *\n * @example\n * let revolved = linear_extrude({height: 10}, square())\n */\nexport function linear_extrude(params: any, baseShape: any) {\n  const defaults = {\n    height: 1,\n    slices: 10,\n    twist: 0,\n    center: false,\n  };\n  /* convexity = 10, */\n  const {height, twist, slices, center} = Object.assign({}, defaults, params);\n\n  // if(params.convexity) convexity = params.convexity      // abandoned\n  let output = baseShape.extrude({offset: [0, 0, height], twistangle: twist, twiststeps: slices});\n  if (center === true) {\n    const b = output.getBounds(); // b[0] = min, b[1] = max\n    const offset = (b[1].plus(b[0])).times(-0.5);\n    output = output.translate(offset);\n  }\n  return output;\n}\n","import {polygonFromPoints} from '@helpers/polygonFromPoints';\nimport {rightMultiply1x3VectorToArray} from '@helpers/rightMultiply1x3VectorToArray';\nimport {cagToPointsArray} from '@helpers/cagToPointsArray';\nimport {clamp} from '@math/clamp';\nimport {Matrix4x4, Polygon3} from '@core/math';\nimport {fromPolygons} from '@core/CSGFactories';\nimport {fromPoints} from '@core/CAGFactories';\n\nconst defaults = {\n  fn: 32,\n  startAngle: 0,\n  angle: 360,\n  overflow: 'cap',\n};\n\n/**\n * Rotate extrusion / revolve of the given 2d shape\n * @param {Object} [options] - options for construction\n * @param {Integer} [options.fn=1] - resolution/number of segments of the extrusion\n * @param {Float} [options.startAngle=1] - start angle of the extrusion, in degrees\n * @param {Float} [options.angle=1] - angle of the extrusion, in degrees\n * @param {Float} [options.overflow='cap'] - what to do with points outside of bounds (+ / - x) :\n * defaults to capping those points to 0 (only supported behaviour for now)\n * @param {CAG} baseShape input 2d shape\n * @returns {CSG} new extruded shape\n *\n * @example\n * let revolved = rotate_extrude({fn: 10}, square())\n */\nexport function rotate_extrude(params?: any, baseShape?: any) {\n// note, we should perhaps alias this to revolve() as well\n  params = Object.assign({}, defaults, params);\n  const {fn, startAngle, angle, overflow} = params;\n  if (overflow !== 'cap') {\n    throw new Error('only capping of overflowing points is supported !');\n  }\n\n  if (arguments.length < 2) { // FIXME: what the hell ??? just put params second !\n    baseShape = params;\n  }\n  // are we dealing with a positive or negative angle (for normals flipping)\n  const flipped = angle > 0;\n  // limit actual angle between 0 & 360, regardless of direction\n  const totalAngle = flipped ? clamp((startAngle + angle), 0, 360) : clamp((startAngle + angle), -360, 0);\n  // adapt to the totalAngle : 1 extra segment per 45 degs if not 360 deg extrusion\n  // needs to be at least one and higher then the input resolution\n  const segments = Math.max(\n    Math.floor(Math.abs(totalAngle) / 45),\n    1,\n    fn,\n  );\n  // maximum distance per axis between two points before considering them to be the same\n  const overlapTolerance = 0.00001;\n  // convert baseshape to just an array of points, easier to deal with\n  let shapePoints = cagToPointsArray(baseShape);\n\n  // determine if the rotate_extrude can be computed in the first place\n  // ie all the points have to be either x > 0 or x < 0\n\n  // generic solution to always have a valid solid, even if points go beyond x/ -x\n  // 1. split points up between all those on the 'left' side of the axis (x<0) & those on the 'righ' (x>0)\n  // 2. for each set of points do the extrusion operation IN OPOSITE DIRECTIONS\n  // 3. union the two resulting solids\n\n  // 1. alt : OR : just cap of points at the axis ?\n\n  // console.log('shapePoints BEFORE', shapePoints, baseShape.sides)\n\n  const pointsWithNegativeX = shapePoints.filter((x: any) => x[0] < 0);\n  const pointsWithPositiveX = shapePoints.filter((x: any) => x[0] >= 0);\n  const arePointsWithNegAndPosX = pointsWithNegativeX.length > 0 && pointsWithPositiveX.length > 0;\n\n  if (arePointsWithNegAndPosX && overflow === 'cap') {\n    if (pointsWithNegativeX.length > pointsWithPositiveX.length) {\n      shapePoints = shapePoints.map((point: any) => [Math.min(point[0], 0), point[1]]);\n    } else if (pointsWithPositiveX.length >= pointsWithNegativeX.length) {\n      shapePoints = shapePoints.map((point: any) => [Math.max(point[0], 0), point[1]]);\n    }\n  }\n\n  // console.log('negXs', pointsWithNegativeX, 'pointsWithPositiveX', pointsWithPositiveX, 'arePointsWithNegAndPosX', arePointsWithNegAndPosX)\n  //  console.log('shapePoints AFTER', shapePoints, baseShape.sides)\n\n  let polygons: Polygon3[] = [];\n\n  // for each of the intermediary steps in the extrusion\n  for (let i = 1; i < segments + 1; i++) {\n    // for each side of the 2d shape\n    for (let j = 0; j < shapePoints.length - 1; j++) {\n      // 2 points of a side\n      const curPoint = shapePoints[j];\n      const nextPoint = shapePoints[j + 1];\n\n      // compute matrix for current and next segment angle\n      const prevMatrix = Matrix4x4.rotationZ((i - 1) / segments * angle + startAngle);\n      const curMatrix = Matrix4x4.rotationZ(i / segments * angle + startAngle);\n\n      const pointA = rightMultiply1x3VectorToArray(prevMatrix, [curPoint[0], 0, curPoint[1]]);\n      const pointAP = rightMultiply1x3VectorToArray(curMatrix, [curPoint[0], 0, curPoint[1]]);\n      const pointB = rightMultiply1x3VectorToArray(prevMatrix, [nextPoint[0], 0, nextPoint[1]]);\n      const pointBP = rightMultiply1x3VectorToArray(curMatrix, [nextPoint[0], 0, nextPoint[1]]);\n\n      // console.log(`point ${j} edge connecting ${j} to ${j + 1}`)\n      let overlappingPoints = false;\n      if (Math.abs(pointA[0] - pointAP[0]) < overlapTolerance && Math.abs(pointB[1] - pointBP[1]) < overlapTolerance) {\n        // console.log('identical / overlapping points (from current angle and next one), what now ?')\n        overlappingPoints = true;\n      }\n\n      // we do not generate a single quad because:\n      // 1. it does not allow eliminating unneeded triangles in case of overlapping points\n      // 2. the current cleanup routines of csg.js create degenerate shapes from those quads\n      // let polyPoints = [pointA, pointB, pointBP, pointAP]\n      // polygons.push(polygonFromPoints(polyPoints))\n\n      if (flipped) {\n        // CW\n        polygons.push(polygonFromPoints([pointA, pointB, pointBP]));\n        if (!overlappingPoints) {\n          polygons.push(polygonFromPoints([pointBP, pointAP, pointA]));\n        }\n      } else {\n        // CCW\n        if (!overlappingPoints) {\n          polygons.push(polygonFromPoints([pointA, pointAP, pointBP]));\n        }\n        polygons.push(polygonFromPoints([pointBP, pointB, pointA]));\n      }\n    }\n    // if we do not do a full extrusion, we want caps at both ends (closed volume)\n    if (Math.abs(angle) < 360) {\n      // we need to recreate the side with capped points where applicable\n      const sideShape = fromPoints(shapePoints);\n      const endMatrix = Matrix4x4.rotationX(90).multiply(\n        Matrix4x4.rotationZ(-startAngle),\n      );\n      const endCap = sideShape._toPlanePolygons({flipped})\n        .map((x: any) => x.transform(endMatrix));\n\n      const startMatrix = Matrix4x4.rotationX(90).multiply(\n        Matrix4x4.rotationZ(-angle - startAngle),\n      );\n      const startCap = sideShape._toPlanePolygons({flipped: !flipped})\n        .map((x: any) => x.transform(startMatrix));\n      polygons = polygons.concat(endCap).concat(startCap);\n    }\n  }\n  return fromPolygons(polygons).reTesselated().canonicalized();\n}\n","import {Polygon3, TVector3Universal, Vector3, Vertex3} from '@core/math';\n\n/**\n * Polygon From Points\n * @param points\n */\nexport const polygonFromPoints = (points: TVector3Universal[]) => {\n  // EEK talk about wrapping wrappers !\n  const vertices = points.map((point) => new Vertex3(new Vector3(point)));\n  return new Polygon3(vertices);\n};\n","import {Matrix4x4} from '@core/math';\n\n/**\n * Simplified, array vector rightMultiply1x3Vector\n * @param matrix\n * @param vector\n */\nexport const rightMultiply1x3VectorToArray = (matrix: Matrix4x4, vector: [number, number, number]) => {\n  const [v0, v1, v2] = vector;\n  const v3 = 1;\n  let x = v0 * matrix.elements[0] + v1 * matrix.elements[1] + v2 * matrix.elements[2] + v3 * matrix.elements[3];\n  let y = v0 * matrix.elements[4] + v1 * matrix.elements[5] + v2 * matrix.elements[6] + v3 * matrix.elements[7];\n  let z = v0 * matrix.elements[8] + v1 * matrix.elements[9] + v2 * matrix.elements[10] + v3 * matrix.elements[11];\n  const w = v0 * matrix.elements[12] + v1 * matrix.elements[13] + v2 * matrix.elements[14] + v3 * matrix.elements[15];\n\n  // scale such that fourth element becomes 1:\n  if (w !== 1) {\n    const invw = 1.0 / w;\n    x *= invw;\n    y *= invw;\n    z *= invw;\n  }\n  return [x, y, z];\n};\n","/**\n * Cag To Points Array\n * @param input\n */\nexport const cagToPointsArray = (input: any) => {\n  let points;\n  if ('sides' in input) { // this is a cag\n    points = [];\n    input.sides.forEach((side: any) => {\n      points.push([side.vertex0.pos.x, side.vertex0.pos.y]);\n      points.push([side.vertex1.pos.x, side.vertex1.pos.y]);\n    });\n    // cag.sides.map(side => [side.vertex0.pos.x, side.vertex0.pos.y])\n    // , side.vertex1.pos.x, side.vertex1.pos.y])\n    // due to the logic of CAG.fromPoints()\n    // move the first point to the last\n    /* if (points.length > 0) {\n      points.push(points.shift())\n    } */\n  } else if ('points' in input) {\n    points = input.points.map((p: any) => ([p.x, p.y]));\n  }\n\n  return points;\n};\n","/**\n * Clamp\n * @param value\n * @param min\n * @param max\n */\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max);\n}\n","import {Path2D} from '@core/math';\n\n/**\n * Rectangular extrusion of the given array of points\n * @param {Array} basePoints array of points (nested) to extrude from\n * layed out like [ [0,0], [10,0], [5,10], [0,10] ]\n * @param {Object} [options] - options for construction\n * @param {Float} [options.h=1] - height of the extruded shape\n * @param {Float} [options.w=10] - width of the extruded shape\n * @param {Integer} [options.fn=1] - resolution/number of segments of the extrusion\n * @param {Boolean} [options.closed=false] - whether to close the input path for the extrusion or not\n * @param {Boolean} [options.round=true] - whether to round the extrusion or not\n * @returns {CSG} new extruded shape\n *\n * @example\n * let revolved = rectangular_extrude({height: 10}, square())\n */\nexport function rectangular_extrude(basePoints: any, params?: any) {\n  const defaults = {\n    w: 1,\n    h: 1,\n    fn: 8,\n    closed: false,\n    // round: true, // not supported\n  };\n  const {w, h, fn, closed} = Object.assign({}, defaults, params);\n  return new Path2D(basePoints, closed).rectangularExtrude(w, h, fn);\n}\n","import {Path2D, Side, Vector2} from '@core/math';\nimport {CAG} from '@core/CAG';\n\n/**\n * Cag Outline Paths\n * @param _cag\n */\nexport const cagOutlinePaths = (_cag: CAG) => {\n  const cag = _cag.canonicalized();\n\n  const sideTagToSideMap: {\n    [hash: number]: Side;\n  } = {};\n\n  const startVertexTagToSideTagMap: {\n    [hash: number]: number[]\n  } = {};\n\n  cag.sides.map((side: Side) => {\n    const sideTag = side.getTag();\n    sideTagToSideMap[sideTag] = side;\n    const startVertexTag = side.vertex0.getTag();\n\n    if (!(startVertexTag in startVertexTagToSideTagMap)) {\n      startVertexTagToSideTagMap[startVertexTag] = [];\n    }\n\n    startVertexTagToSideTagMap[startVertexTag].push(sideTag);\n  });\n\n  const paths: Path2D[] = [];\n  while (true) {\n    let startSideTag = null;\n\n    // tslint:disable-next-line:forin\n    for (const aVertexTag in startVertexTagToSideTagMap) {\n      const sidesForcagVertex = startVertexTagToSideTagMap[aVertexTag];\n      startSideTag = sidesForcagVertex[0];\n      sidesForcagVertex.splice(0, 1);\n      if (sidesForcagVertex.length === 0) {\n        delete startVertexTagToSideTagMap[aVertexTag];\n      }\n      break;\n    }\n\n    if (startSideTag === null) {\n      break; // we've had all sides\n    }\n\n    const connectedVertexPoints: Vector2[] = [];\n    const sideTag = startSideTag;\n\n    let cagSide = sideTagToSideMap[sideTag];\n    const startVertexTag = cagSide.vertex0.getTag();\n    while (true) {\n      connectedVertexPoints.push(cagSide.vertex0.pos);\n      const nextVertexTag = cagSide.vertex1.getTag();\n\n      if (nextVertexTag === startVertexTag) {\n        break; // we've closed the polygon\n      }\n\n      if (!(nextVertexTag in startVertexTagToSideTagMap)) {\n        throw new Error('Area is not closed!');\n      }\n\n      const nextPossibleSideTags = startVertexTagToSideTagMap[nextVertexTag];\n\n      let nextSideIndex = -1;\n\n      if (nextPossibleSideTags.length === 1) {\n        nextSideIndex = 0;\n      } else {\n        // more than one side starting at the same vertex. cag means we have\n        // two shapes touching at the same corner\n\n        let bestAngle = null;\n\n        const cagAngle = cagSide.direction().angleDegrees();\n        for (let sideIndex = 0; sideIndex < nextPossibleSideTags.length; sideIndex++) {\n          const nextPossibleSideTag = nextPossibleSideTags[sideIndex];\n          const possibleside = sideTagToSideMap[nextPossibleSideTag];\n          const angle = possibleside.direction().angleDegrees();\n\n          let angleDiff = angle - cagAngle;\n\n          if (angleDiff < -180) angleDiff += 360;\n          if (angleDiff >= 180) angleDiff -= 360;\n\n          if ((nextSideIndex < 0) || bestAngle === null || (angleDiff > bestAngle)) {\n            nextSideIndex = sideIndex;\n            bestAngle = angleDiff;\n          }\n        }\n      }\n\n      const nextSideTag = nextPossibleSideTags[nextSideIndex];\n\n      nextPossibleSideTags.splice(nextSideIndex, 1);\n      if (nextPossibleSideTags.length === 0) {\n        delete startVertexTagToSideTagMap[nextVertexTag];\n      }\n\n      cagSide = sideTagToSideMap[nextSideTag];\n    }\n\n    // due to the logic of fromPoints() move the first point to the last\n    if (connectedVertexPoints.length > 0) {\n      connectedVertexPoints.push(connectedVertexPoints.shift()!);\n    }\n\n    const path = new Path2D(connectedVertexPoints, true);\n    paths.push(path);\n  }\n\n  return paths;\n};\n\n","import {parseOptionAs2DVector, parseOptionAsFloat, parseOptionAsInt} from '@api/optionParsers';\nimport {defaultResolution2D} from '@core/constants';\nimport {fromPath2, fromPoints} from '@core/CAGFactories';\nimport {Path2D, TVector2Universal, Vector2} from '@core/math';\n\nexport interface ICircleOptions {\n  center: TVector2Universal;\n  radius: number;\n  resolution: number;\n}\n\n/**\n * Construct a circle.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of circle\n * @param {Number} [options.radius=1] - radius of circle\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @returns {CAG} new CAG object\n */\nexport const circle = (options: Partial<ICircleOptions> = {}) => {\n  const center = parseOptionAs2DVector(options, 'center', [0, 0]);\n  const radius = parseOptionAsFloat(options, 'radius', 1);\n  const resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n\n  const points = [];\n  for (let i = 0; i < resolution; i++) {\n    const radians = 2 * Math.PI * i / resolution;\n    const point = Vector2.fromAngleRadians(radians).times(radius).plus(center);\n    points.push(point);\n  }\n  return fromPoints(points);\n};\n\nexport interface IEllipse {\n  center: TVector2Universal;\n  radius: TVector2Universal;\n  resolution: number;\n}\n\n/**\n * Construct an ellispe.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of ellipse\n * @param {Vector2D} [options.radius=[1,1]] - radius of ellipse, width and height\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @returns {CAG} new CAG object\n */\nexport const ellipse = (options: Partial<IEllipse> = {}) => {\n  const c = parseOptionAs2DVector(options, 'center', [0, 0]);\n  let r = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  r = r.abs(); // negative radii make no sense\n  const res = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n\n  let e2 = new Path2D([[c.x, c.y + r.y]]);\n  e2 = e2.appendArc([c.x, c.y - r.y], {\n    xradius: r.x,\n    yradius: r.y,\n    xaxisrotation: 0,\n    resolution: res,\n    clockwise: true,\n    large: false,\n  });\n  e2 = e2.appendArc([c.x, c.y + r.y], {\n    xradius: r.x,\n    yradius: r.y,\n    xaxisrotation: 0,\n    resolution: res,\n    clockwise: true,\n    large: false,\n  });\n  e2 = e2.close();\n  return fromPath2(e2);\n};\n\nexport interface IRectangle {\n  corner1: TVector2Universal;\n  corner2: TVector2Universal;\n  center: TVector2Universal;\n  radius: TVector2Universal;\n}\n\n/**\n * Construct a rectangle.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of rectangle\n * @param {Vector2D} [options.radius=[1,1]] - radius of rectangle, width and height\n * @param {Vector2D} [options.corner1=[0,0]] - bottom left corner of rectangle (alternate)\n * @param {Vector2D} [options.corner2=[0,0]] - upper right corner of rectangle (alternate)\n * @returns {CAG} new CAG object\n */\nexport const rectangle = (options: Partial<IRectangle> = {}) => {\n  let c;\n  let r;\n  if (('corner1' in options) || ('corner2' in options)) {\n    if (('center' in options) || ('radius' in options)) {\n      throw new Error('rectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter');\n    }\n    const corner1 = parseOptionAs2DVector(options, 'corner1', [0, 0]);\n    const corner2 = parseOptionAs2DVector(options, 'corner2', [1, 1]);\n    c = corner1.plus(corner2).times(0.5);\n    r = corner2.minus(corner1).times(0.5);\n  } else {\n    c = parseOptionAs2DVector(options, 'center', [0, 0]);\n    r = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  }\n  r = r.abs(); // negative radii make no sense\n  const rswap = new Vector2(r.x, -r.y);\n  const points = [\n    c.plus(r), c.plus(rswap), c.minus(r), c.minus(rswap),\n  ];\n  return fromPoints(points);\n};\n\nexport interface IRoundedRectangle {\n  roundradius: number;\n  resolution: number;\n}\n\nexport interface IRoundedRectangleNormal {\n  center: TVector2Universal;\n  radius: TVector2Universal;\n\n}\n\nexport interface IRoundedRectangleCorner {\n  corner1: TVector2Universal;\n  corner2: TVector2Universal;\n\n}\n\n/**\n * Construct a rounded rectangle.\n * @param {Object} [options] - options for construction\n * @param {Vector2D} [options.center=[0,0]] - center of rounded rectangle\n * @param {Vector2D} [options.radius=[1,1]] - radius of rounded rectangle, width and height\n * @param {Vector2D} [options.corner1=[0,0]] - bottom left corner of rounded rectangle (alternate)\n * @param {Vector2D} [options.corner2=[0,0]] - upper right corner of rounded rectangle (alternate)\n * @param {Number} [options.roundradius=0.2] - round radius of corners\n * @param {Number} [options.resolution=defaultResolution2D] - number of sides per 360 rotation\n * @returns {CAG} new CAG object\n *\n * @example\n * let r = roundedRectangle({\n *   center: [0, 0],\n *   radius: [5, 10],\n *   roundradius: 2,\n *   resolution: 36,\n * });\n */\nexport const roundedRectangle = (options: Partial<IRoundedRectangleNormal & IRoundedRectangle> | Partial<IRoundedRectangleCorner & IRoundedRectangle> = {}) => {\n  let center;\n  let radius;\n  if (('corner1' in options) || ('corner2' in options)) {\n    if (('center' in options) || ('radius' in options)) {\n      throw new Error('roundedRectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter');\n    }\n    const corner1 = parseOptionAs2DVector(options, 'corner1', [0, 0]);\n    const corner2 = parseOptionAs2DVector(options, 'corner2', [1, 1]);\n    center = corner1.plus(corner2).times(0.5);\n    radius = corner2.minus(corner1).times(0.5);\n  } else {\n    center = parseOptionAs2DVector(options, 'center', [0, 0]);\n    radius = parseOptionAs2DVector(options, 'radius', [1, 1]);\n  }\n  radius = radius.abs(); // negative radii make no sense\n  let roundradius = parseOptionAsFloat(options, 'roundradius', 0.2);\n  const resolution = parseOptionAsInt(options, 'resolution', defaultResolution2D);\n  let maxroundradius = Math.min(radius.x, radius.y);\n  maxroundradius -= 0.1;\n  roundradius = Math.min(roundradius, maxroundradius);\n  roundradius = Math.max(0, roundradius);\n  radius = new Vector2(radius.x - roundradius, radius.y - roundradius);\n  let rect = rectangle({\n    center,\n    radius,\n  });\n  if (roundradius > 0) {\n    rect = rect.expand(roundradius, resolution);\n  }\n  return rect;\n};\n","import {CAG} from '@core/CAG'; // we have to import from top level otherwise prototypes are not complete..\n\nexport interface ICircleOptions {\n  r: number;\n  fn: number;\n  center: boolean;\n}\n\nconst defaults: ICircleOptions = {\n  r: 1,\n  fn: 32,\n  center: false,\n};\n\n/**\n * Construct a circle\n * @param {ICircleOptions} [options] - options for construction\n * @param {number} options.r - radius of the circle\n * @param {number} options.fn - segments of circle (ie quality/ resolution)\n * @param {boolean} options.center - whether to center the circle or not\n * @returns {CAG} new circle\n *\n * @example\n * let circle1 = circle({\n *   r: 10\n * })\n */\nexport function circle(options?: Partial<ICircleOptions> | number) {\n\n  const {r, fn, center} = {...defaults, ...(typeof options === 'number' ? {r: options} : options)} as ICircleOptions;\n  const offset = center ? [0, 0] : [r, r];\n\n  return CAG.circle({center: offset, radius: r, resolution: fn});\n}\n","import {CAG} from '@core/CAG'; // we have to import from top level otherwise prototypes are not complete..\nimport {fromPoints} from '@core/CAGFactories';\n\n/**\n * Construct a polygon either from arrays of paths and points,\n * or just arrays of points nested paths (multiple paths) and flat paths are supported\n * @param {Object} [options] - options for construction or either flat or nested array of points\n * @param {Array} [options.points] - points of the polygon : either flat or nested array of points\n * @param {Array} [options.paths] - paths of the polygon : either flat or nested array of points index\n * @returns {CAG} new polygon\n *\n * @example\n * let roof = [[10,11], [0,11], [5,20]]\n * let wall = [[0,0], [10,0], [10,10], [0,10]]\n *\n * let poly = polygon(roof)\n * or\n * let poly = polygon([roof, wall])\n * or\n * let poly = polygon({ points: roof })\n * or\n * let poly = polygon({ points: [roof, wall] })\n * or\n * let poly = polygon({ points: roof, path: [0, 1, 2] })\n * or\n * let poly = polygon({ points: [roof, wall], path: [[0, 1, 2], [3, 4, 5, 6]] })\n * or\n * let poly = polygon({ points: roof.concat(wall), paths: [[0, 1, 2], [3, 4, 5], [3, 6, 5]] })\n */\nexport function polygon(params: any) { // array of po(ints) and pa(ths)\n  let points: any[] = [];\n  if (params.paths && params.paths.length && params.paths[0].length) { // pa(th): [[0,1,2],[2,3,1]] (two paths)\n    if (typeof params.points[0][0] !== 'number') { // flatten points array\n      params.points = params.points.reduce((a: any, b: any) => a.concat(b));\n    }\n    params.paths.forEach((path: any, i: number) => {\n      points.push([]);\n      path.forEach((j: any) => points[i].push(params.points[j]));\n    });\n  } else if (params.paths && params.paths.length) { // pa(th): [0,1,2,3,4] (single path)\n    params.paths.forEach((i: any) => points.push(params.points[i]));\n  } else { // pa(th) = po(ints)\n    if (params.length) {\n      points = params;\n    } else {\n      points = params.points;\n    }\n  }\n  return fromPoints(points);\n}\n","import {CAG} from '@core/CAG'; // we have to import from top level otherwise prototypes are not complete..\nimport {fromPoints} from '@core/CAGFactories';\n\n// FIXME: errr this is kinda just a special case of a polygon , why do we need it ?\n/**\n * Construct a triangle\n * @returns {CAG} new triangle\n *\n * @example\n * let triangle = trangle({\n *   length: 10\n * })\n */\nexport function triangle() {\n  let a = arguments;\n  if (a[0] && a[0].length) a = a[0];\n  return fromPoints(a);\n}\n","import {translate} from '@modifiers/transforms';\nimport {roundedCube as CSGroundedCube, cube as CSGcube} from './csg/primitives3d';\n\nexport interface ICuboidOptions {\n  size: number | [number, number, number];\n  center: boolean | [boolean, boolean, boolean];\n  round: boolean;\n  radius: number;\n  fn: number;\n}\n\nconst defaults: ICuboidOptions = {\n  size: 1,\n  center: false,\n  round: false,\n  radius: 0,\n  fn: 8,\n};\n\n/**\n * Construct a cuboid\n * @param {ICuboidOptions} options - options for construction\n * @param {boolean | boolean[]} options.center - center of cuboid\n * @param {number} options.size - dimensions of cuboid; width, depth, height\n * @returns {CSG} new cuboid\n *\n * @example\n * let cube1 = cube({\n *   r: 10,\n *   fn: 20\n * })\n */\nexport function cube(options?: Partial<ICuboidOptions> | [number, number, number] | number) {\n  const {round, radius, fn, size, center} = {...defaults, ...(typeof options === 'number' ? {size: [options, options, options]} : Array.isArray(options) ? {size: options} : options)} as ICuboidOptions;\n\n  const [width, depth, height] = Array.isArray(size) ? size : [size, size, size];\n  const roundRadius = (round || radius) && (radius ? radius : (width + depth + height) / 30) || 0;\n\n  const halfSize = [width / 2, depth / 2, height / 2];\n\n  const mesh = roundRadius\n    ? CSGroundedCube({radius: [...halfSize], roundradius: roundRadius, resolution: fn})\n    : CSGcube({radius: [...halfSize]});\n\n  const offset = Array.isArray(center) ? [+!!!center[0] * halfSize[0], +!!!center[1] * halfSize[1], +!!!center[2] * halfSize[2]] : (!center ? [...halfSize] : [0, 0, 0]);\n\n  return (offset[0] || offset[1] || offset[2]) ? translate(offset, mesh) : mesh;\n}\n","/**\n * translate an object in 2D/3D space\n * @param {Object} vector - 3D vector to translate the given object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to translate\n * @returns {CSG} new CSG object , translated by the given amount\n *\n * @example\n * let movedSphere = translate([10,2,0], sphere())\n */\nexport function translate(vector: any, ...objects: any[]) {      // v, obj or array\n  // workaround needed to determine if we are dealing with an array of objects\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  return object.translate(vector);\n}\n","/**\n * Scale an object in 2D/3D space\n * @param {Float|Array} scaleValue - either an array or simple number to scale object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to scale\n * @returns {CSG} new CSG object , scaled by the given amount\n *\n * @example\n * let scaledSphere = scale([0.2,15,1], sphere())\n */\nexport function scale(scaleValue: any, ...objects: any[]) {         // v, obj or array\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  return object.scale(scaleValue);\n}\n","/**\n * Rotate an object in 2D/3D space\n * @param {Float|Array} rotation - either an array or simple number to rotate object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to rotate\n * @returns {CSG} new CSG object , rotated by the given amount\n *\n * @example\n * let rotatedSphere = rotate([0.2,15,1], sphere())\n */\nexport function rotate() {\n  let o;\n  let i;\n  let v;\n  let r = 1;\n  let a = arguments;\n  if (!a[0].length) {        // rotate(r,[x,y,z],o)\n    r = a[0];\n    v = a[1];\n    i = 2;\n    if (a[2].length) {\n      a = a[2];\n      i = 0;\n    }\n  } else {                   // rotate([x,y,z],o)\n    v = a[0];\n    i = 1;\n    if (a[1].length) {\n      a = a[1];\n      i = 0;\n    }\n  }\n  for (o = a[i++]; i < a.length; i++) {\n    o = o.union(a[i]);\n  }\n  if (r !== 1) {\n    return o.rotate([0, 0, 0], v, r);\n  } else {\n    return o.rotateX(v[0]).rotateY(v[1]).rotateZ(v[2]);\n  }\n}\n","import {Matrix4x4} from '@core/math';\n\n/**\n * Apply the given matrix transform to the given objects\n * @param {Array} matrix - the 4x4 matrix to apply, as a simple 1d array of 16 elements\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to transform\n * @returns {CSG} new CSG object , transformed\n *\n * @example\n * const angle = 45\n * let transformedShape = transform([\n * cos(angle), -sin(angle), 0, 10,\n * sin(angle),  cos(angle), 0, 20,\n * 0         ,           0, 1, 30,\n * 0,           0, 0,  1\n * ], sphere())\n */\nexport function transform(matrix: number[], ...objects: any) { // v, obj or array\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n\n  let transformationMatrix;\n  if (!Array.isArray(matrix)) {\n    throw new Error('Matrix needs to be an array');\n  }\n\n  matrix.forEach(element => {\n    if (!Number.isFinite(element)) {\n      throw new Error('you can only use a flat array of valid, finite numbers (float and integers)');\n    }\n  });\n\n  transformationMatrix = new Matrix4x4(matrix);\n  return object.transform(transformationMatrix);\n}\n","/**\n * Center the given object(s) about the given axes\n * @param {Array|Boolean} axes=[true,true,true]|true  - an array of boolean values that indicate the axes (X,Y,Z) to center upon. A single boolean is also allowed.\n * @param {...Object} object one or more objects to center, i.e. objects are CSG or CAG\n * @returns {CSG} new CSG object , translated by the given amount\n *\n * @example\n * let csg = center([true,false,false], sphere()) // center about the X axis\n */\nexport function center(axes: any, ...objects: any[]) {\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  if (!Array.isArray(axes)) {\n    axes = [axes, axes, axes];\n  }\n  return object.center(axes);\n}\n","import {Plane, Vector3} from '@core/math';\n\n/**\n * Mirror an object in 2D/3D space\n * @param {Array} vector - the axes to mirror the object(s) by\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to mirror\n * @returns {CSG} new CSG object , mirrored\n *\n * @example\n * let rotatedSphere = mirror([0.2,15,1], sphere())\n */\nexport function mirror(vector: any, ...objects: any[]) {\n  const _objects = (objects.length >= 1 && objects[0].length) ? objects[0] : objects;\n  let object = _objects[0];\n\n  if (_objects.length > 1) {\n    for (let i = 1; i < _objects.length; i++) { // FIXME/ why is union really needed ??\n      object = object.union(_objects[i]);\n    }\n  }\n  const plane = new Plane(new Vector3(vector[0], vector[1], vector[2]).unit(), 0);\n  return object.mirrored(plane);\n}\n","/**\n * Expand an object in 2D/3D space\n * @param {float} radius - the radius to expand by\n * @param {Object} object a CSG/CAG objects to expand\n * @returns {CSG/CAG} new CSG/CAG object , expanded\n *\n * @example\n * let expanededShape = expand([0.2,15,1], sphere())\n */\nexport function expand(radius: number, n: any, object: any) {\n  return object.expand(radius, n);\n}\n","/**\n * Contract an object(s) in 2D/3D space\n * @param {float} radius - the radius to contract by\n * @param {Object} object a CSG/CAG objects to contract\n * @returns {CSG/CAG} new CSG/CAG object , contracted\n *\n * @example\n * let contractedShape = contract([0.2,15,1], sphere())\n */\nexport function contract(radius: number, n: any, object: any) {\n  return object.contract(radius, n);\n}\n","/**\n * create a minkowski sum of the given shapes\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to create a hull around\n * @returns {CSG} new CSG object , mirrored\n *\n * @example\n * let hulled = hull(rect(), circle())\n */\nexport function minkowski() {\n  // tslint:disable-next-line:no-console\n  console.log('minkowski() not yet implemented');\n}\n","import {ConvexHullPoint} from './ConvexHullPoint';\n\n/**\n * Convex Hull\n * from http://www.psychedelicdevelopment.com/grahamscan/\n * see also at https://github.com/bkiers/GrahamScan/blob/master/src/main/cg/GrahamScan.java\n * @class ConvexHull\n */\nexport class ConvexHull {\n  points: any[] = null!;\n  indices: number[] = null!;\n\n  /**\n   * Get Indices\n   */\n  getIndices() {\n    return this.indices;\n  };\n\n  /**\n   * Clear\n   */\n  clear() {\n    this.indices = null!;\n    this.points = null!;\n  }\n\n  /**\n   * CCW\n   * @param p1\n   * @param p2\n   * @param p3\n   */\n  ccw(p1: number, p2: number, p3: number) {\n    const ccw = (this.points[p2].x - this.points[p1].x) * (this.points[p3].y - this.points[p1].y) -\n      (this.points[p2].y - this.points[p1].y) * (this.points[p3].x - this.points[p1].x);\n    // we need this, otherwise sorting never ends, see https://github.com/Spiritdude/OpenJSCAD.org/issues/18\n    if (ccw < 1e-5) {\n      return 0;\n    }\n    return ccw;\n  }\n\n  /**\n   * Angle\n   * @param o\n   * @param a\n   */\n  angle(o: number, a: number) {\n    // return Math.atan((this.points[a].y-this.points[o].y) / (this.points[a].x - this.points[o].x));\n    return Math.atan2((this.points[a].y - this.points[o].y), (this.points[a].x - this.points[o].x));\n  }\n\n  /**\n   * Distance\n   * @param a\n   * @param b\n   */\n  distance(a: number, b: number) {\n    return ((this.points[b].x - this.points[a].x) * (this.points[b].x - this.points[a].x) +\n      (this.points[b].y - this.points[a].y) * (this.points[b].y - this.points[a].y));\n  };\n\n  /**\n   * Compute\n   * @param _points\n   */\n  compute(_points: any[]) {\n    this.indices = null!;\n    if (_points.length < 3) {\n      return;\n    }\n    this.points = _points;\n\n    // Find the lowest point\n    let min = 0;\n    for (let i = 1; i < this.points.length; i++) {\n      if (this.points[i].y === this.points[min].y) {\n        if (this.points[i].x < this.points[min].x) {\n          min = i;\n        }\n      } else if (this.points[i].y < this.points[min].y) {\n        min = i;\n      }\n    }\n\n    // Calculate angle and distance from base\n    const al: ConvexHullPoint[] = [];\n    let ang = 0.0;\n    let dist = 0.0;\n    for (let i = 0; i < this.points.length; i++) {\n      if (i === min) {\n        continue;\n      }\n      ang = this.angle(min, i);\n      if (ang < 0) {\n        ang += Math.PI;\n      }\n      dist = this.distance(min, i);\n      al.push(new ConvexHullPoint(i, ang, dist));\n    }\n\n    al.sort((a, b) => {\n      return a.compare(b);\n    });\n\n    // Create stack\n    const stack = new Array(this.points.length + 1);\n    let j = 2;\n    for (let i = 0; i < this.points.length; i++) {\n      if (i === min) {\n        continue;\n      }\n      stack[j] = al[j - 2].index;\n      j++;\n    }\n    stack[0] = stack[this.points.length];\n    stack[1] = min;\n\n    let tmp;\n    let M = 2;\n    for (let i = 3; i <= this.points.length; i++) {\n      while (this.ccw(stack[M - 1], stack[M], stack[i]) <= 0) {\n        M--;\n      }\n      M++;\n      tmp = stack[i];\n      stack[i] = stack[M];\n      stack[M] = tmp;\n    }\n\n    this.indices = new Array(M);\n    for (let i = 0; i < M; i++) {\n      this.indices[i] = stack[i + 1];\n    }\n  };\n}\n","/**\n * Convex Hull Point\n * @class ConvexHullPoint\n */\nexport class ConvexHullPoint {\n  /**\n   * ConvexHullPoint Constructor\n   * @param index\n   * @param angle\n   * @param distance\n   */\n  constructor(public index: number, public angle: number, public distance: number) {\n  }\n\n  /**\n   * Compare ConvexHullPoints\n   * @param p\n   */\n  compare(p: ConvexHullPoint): number {\n    if (this.angle < p.angle) {\n      return -1;\n    } else if (this.angle > p.angle) {\n      return 1;\n    } else {\n      if (this.distance < p.distance) {\n        return -1;\n      } else if (this.distance > p.distance) {\n        return 1;\n      }\n    }\n    return 0;\n  };\n}\n","import {union} from '../booleans';\nimport {hull} from './hull';\n\n/**\n * Create a chain hull of the given shapes\n * Originally \"Whosa whatsis\" suggested \"Chain Hull\" ,\n * as described at https://plus.google.com/u/0/105535247347788377245/posts/aZGXKFX1ACN\n * essentially hull A+B, B+C, C+D and then union those\n * @param {Object(s)|Array} objects either a single or multiple CSG/CAG objects to create a chain hull around\n * @returns {CSG} new CSG object ,which a chain hull of the inputs\n *\n * @example\n * let hulled = chain_hull(rect(), circle())\n */\nexport function chain_hull(params: any, objects: any) {\n  /*\n  const defaults = {\n    closed: false\n  }\n  const closed = Object.assign({}, defaults, params) */\n  let a = arguments;\n  let closed = false;\n  let j = 0;\n\n  if (a[j].closed !== undefined) {\n    closed = a[j++].closed;\n  }\n\n  if (a[j].length) {\n    a = a[j];\n  }\n\n  const hulls = [];\n  const hullsAmount = a.length - (closed ? 0 : 1);\n  for (let i = 0; i < hullsAmount; i++) {\n    hulls.push(hull(a[i], a[(i + 1) % a.length]));\n  }\n  return union(hulls);\n}\n","import {geodesicSphere} from './geodesicSphere';\nimport {translate} from '@modifiers/transforms';\nimport {sphere as CSGSphere} from './csg/primitives3d';\n\n/**\n * Sphere Type Enum\n * @readonly\n * @enum {string}\n */\nexport const enum SPHERE_TYPE {\n  NORMAL = 'normal',\n  GEODESIC = 'geodesic',\n}\n\nexport interface ISphereOptions {\n  r: number;\n  fn: number;\n  center: boolean | [boolean, boolean, boolean];\n  type: SPHERE_TYPE;\n}\n\nconst defaults: Partial<ISphereOptions> = {\n  r: 1,\n  fn: 32,\n  type: SPHERE_TYPE.NORMAL,\n};\n\n/**\n * Construct a sphere\n * @param {ISphereOptions} [options] - options for construction\n * @param {number} options.r - radius of the sphere\n * @param {number} options.fn - segments of the sphere (ie quality/resolution)\n * @param {SPHERE_TYPE} options.type - type of sphere : either 'normal' or 'geodesic'\n * @returns {CSG} new sphere\n *\n * @example\n * let sphere1 = sphere({\n *   r: 10,\n *   fn: 20\n * })\n */\nexport function sphere(options?: Partial<ISphereOptions> | number) {\n  const {r, fn, center, type} = {...defaults, ...(typeof options === 'number' ? {r: options} : options)} as ISphereOptions;\n\n  // preparing individual x,y,z center\n  // center: false (default)\n  const offset = Array.isArray(center) ? [+!!!center[0] * r, +!!!center[1] * r, +!!!center[2] * r] : (typeof center === 'boolean' && !center ? [r, r, r] : [0, 0, 0]);\n\n  const mesh = type === SPHERE_TYPE.GEODESIC ? geodesicSphere({r, fn}) : CSGSphere({radius: r, resolution: fn});\n\n  return (offset[0] || offset[1] || offset[2]) ? translate(offset, mesh) : mesh;\n}\n","import {translate} from '@modifiers/transforms';\nimport {roundedCylinder as CSGroundedCylinder, cylinder as CSGcylinder} from './csg/primitives3d';\n\n/**\n * Construct a cylinder\n * @param {Object} [options] - options for construction\n * @param {Float} [options.r=1] - radius of the cylinder\n * @param {Float} [options.r1=1] - radius of the top of the cylinder\n * @param {Float} [options.r2=1] - radius of the bottom of the cylinder\n * @param {Float} [options.d=1] - diameter of the cylinder\n * @param {Float} [options.d1=1] - diameter of the top of the cylinder\n * @param {Float} [options.d2=1] - diameter of the bottom of the cylinder\n * @param {Integer} [options.fn=32] - number of sides of the cylinder (ie quality/resolution)\n * @returns {CSG} new cylinder\n *\n * @example\n * let cylinder = cylinder({\n *   d: 10,\n *   fn: 20\n * })\n */\nexport function cylinder(params?: any) {\n  const defaults = {\n    r: 1,\n    r1: 1,\n    r2: 1,\n    h: 1,\n    fn: 32,\n    round: false,\n  };\n\n  // tslint:disable-next-line:prefer-const\n  let {r1, r2, h, fn, round} = Object.assign({}, defaults, params);\n  let offset = [0, 0, 0];\n  let a = arguments;\n  if (params && params.d) {\n    r1 = r2 = params.d / 2;\n  }\n  if (params && params.r) {\n    r1 = params.r;\n    r2 = params.r;\n  }\n  if (params && params.h) {\n    h = params.h;\n  }\n  if (params && (params.r1 || params.r2)) {\n    r1 = params.r1;\n    r2 = params.r2;\n    if (params.h) h = params.h;\n  }\n  if (params && (params.d1 || params.d2)) {\n    r1 = params.d1 / 2;\n    r2 = params.d2 / 2;\n  }\n\n  if (a && a[0] && a[0].length) {\n    a = a[0];\n    r1 = a[0];\n    r2 = a[1];\n    h = a[2];\n    if (a.length === 4) fn = a[3];\n  }\n\n  let object;\n  if (params && (params.start && params.end)) {\n    object = round\n      ? CSGroundedCylinder({start: params.start, end: params.end, radiusStart: r1, radiusEnd: r2, resolution: fn})\n      : CSGcylinder({start: params.start, end: params.end, radiusStart: r1, radiusEnd: r2, resolution: fn});\n  } else {\n    object = round\n      ? CSGroundedCylinder({start: [0, 0, 0], end: [0, 0, h], radiusStart: r1, radiusEnd: r2, resolution: fn})\n      : CSGcylinder({start: [0, 0, 0], end: [0, 0, h], radiusStart: r1, radiusEnd: r2, resolution: fn});\n    const r = r1 > r2 ? r1 : r2;\n    if (params && params.center && params.center.length) { // preparing individual x,y,z center\n      offset = [params.center[0] ? 0 : r, params.center[1] ? 0 : r, params.center[2] ? -h / 2 : 0];\n    } else if (params && params.center === true) {\n      offset = [0, 0, -h / 2];\n    } else if (params && params.center === false) {\n      offset = [0, 0, 0];\n    }\n    object = (offset[0] || offset[1] || offset[2]) ? translate(offset, object) : object;\n  }\n  return object;\n}\n","import {CSG} from '@core/CSG';\nimport {circle} from './';\nimport {rotate_extrude} from '@modifiers/extrusions';\nimport {translate} from '@modifiers/transforms';\n\nconst MIN_FNI = 3;\nconst MIN_FNO = 3;\n\nexport interface ITorusOptions {\n  ri: number;\n  ro: number;\n  fni: number;\n  fno: number;\n  roti: number;\n}\n\nconst defaults: ITorusOptions = {\n  ri: 1,\n  ro: 4,\n  fni: 16,\n  fno: 32,\n  roti: 0,\n};\n\n/**\n * Construct a Torus\n * @param {ITorusOptions} [options] - options for construction\n * @param {number} options.ri - radius of base circle\n * @param {number} options.ro - radius offset\n * @param {number} options.fni - segments of base circle (ie quality)\n * @param {number} options.fno - segments of extrusion (ie quality)\n * @param {number} options.roti - rotation angle of base circle\n * @returns {CSG} new torus\n *\n * @example\n * let torus1 = torus({\n *   ri: 10\n * })\n */\nexport function torus(options?: Partial<ITorusOptions>) {\n  const {ri, ro, fni, fno, roti} = {...defaults, ...options};\n\n  let baseCircle = circle({r: ri, fn: Math.max(MIN_FNI, fni), center: true});\n  if (roti) baseCircle = baseCircle.rotateZ(roti);\n\n  return rotate_extrude({fn: Math.max(MIN_FNO, fno)}, translate([ro, 0, 0], baseCircle));\n}\n","export * from './color';\nexport * from './css2rgb';\nexport * from './rgb2hsl';\nexport * from './rgb2html';\nexport * from './rgb2hsv';\nexport * from './html2rgb';\nexport * from './hsv2rgb';\nexport * from './hue2rgb';\nexport * from './hsl2rgb';\n","import {css2rgb} from './css2rgb';\n\n// color( (array[r,g,b] | css-string) [,alpha] (,array[objects] | list of objects) )\n\n/**\n * Apply the given color to the input object(s)\n * @param {Object} colorValue - either an array or a hex string of color values\n * @param {Object|Array} objects either a single or multiple CSG/CAG objects to color\n * @returns {CSG} new CSG object , with the given color\n *\n * @example\n * let redSphere = color([1,0,0,1], sphere())\n */\nexport const color = (colorValue: string | number[], ...objects: any[]) => {\n  let object;\n  let i = 0;\n  let a = objects;\n\n  // assume first argument is RGB array\n  // but check if first argument is CSS string\n  if (typeof colorValue === 'string') {\n    colorValue = css2rgb(colorValue);\n  }\n\n  // check if second argument is alpha\n  if (Number.isFinite(a[i])) {\n    colorValue = colorValue.concat(a[i]);\n    i++;\n  }\n\n  // check if next argument is an an array\n  if (Array.isArray(a[i])) {\n    a = a[i];\n    i = 0;\n  } // use this as the list of objects\n\n  for (object = a[i++]; i < a.length; i++) {\n    object = object.union(a[i]);\n  }\n\n  return object.setColor(colorValue);\n};\n","export type TCssColorNames = keyof typeof cssColors3ub;\n\n// color table from http://www.w3.org/TR/css3-color/\nexport const cssColors3ub = {\n// basic color keywords\n  'black': [0, 0, 0],\n  'silver': [192, 192, 192],\n  'gray': [128, 128, 128],\n  'white': [255, 255, 255],\n  'maroon': [128, 0, 0],\n  'red': [255, 0, 0],\n  'purple': [128, 0, 128],\n  'fuchsia': [255, 0, 255],\n  'green': [0, 128, 0],\n  'lime': [0, 255, 0],\n  'olive': [128, 128, 0],\n  'yellow': [255, 255, 0],\n  'navy': [0, 0, 128],\n  'blue': [0, 0, 255],\n  'teal': [0, 128, 128],\n  'aqua': [0, 255, 255],\n  // extended color keywords\n  'aliceblue': [240, 248, 255],\n  'antiquewhite': [250, 235, 215],\n  // 'aqua': [ 0, 255, 255 ],\n  'aquamarine': [127, 255, 212],\n  'azure': [240, 255, 255],\n  'beige': [245, 245, 220],\n  'bisque': [255, 228, 196],\n  // 'black': [ 0, 0, 0 ],\n  'blanchedalmond': [255, 235, 205],\n  // 'blue': [ 0, 0, 255 ],\n  'blueviolet': [138, 43, 226],\n  'brown': [165, 42, 42],\n  'burlywood': [222, 184, 135],\n  'cadetblue': [95, 158, 160],\n  'chartreuse': [127, 255, 0],\n  'chocolate': [210, 105, 30],\n  'coral': [255, 127, 80],\n  'cornflowerblue': [100, 149, 237],\n  'cornsilk': [255, 248, 220],\n  'crimson': [220, 20, 60],\n  'cyan': [0, 255, 255],\n  'darkblue': [0, 0, 139],\n  'darkcyan': [0, 139, 139],\n  'darkgoldenrod': [184, 134, 11],\n  'darkgray': [169, 169, 169],\n  'darkgreen': [0, 100, 0],\n  'darkgrey': [169, 169, 169],\n  'darkkhaki': [189, 183, 107],\n  'darkmagenta': [139, 0, 139],\n  'darkolivegreen': [85, 107, 47],\n  'darkorange': [255, 140, 0],\n  'darkorchid': [153, 50, 204],\n  'darkred': [139, 0, 0],\n  'darksalmon': [233, 150, 122],\n  'darkseagreen': [143, 188, 143],\n  'darkslateblue': [72, 61, 139],\n  'darkslategray': [47, 79, 79],\n  'darkslategrey': [47, 79, 79],\n  'darkturquoise': [0, 206, 209],\n  'darkviolet': [148, 0, 211],\n  'deeppink': [255, 20, 147],\n  'deepskyblue': [0, 191, 255],\n  'dimgray': [105, 105, 105],\n  'dimgrey': [105, 105, 105],\n  'dodgerblue': [30, 144, 255],\n  'firebrick': [178, 34, 34],\n  'floralwhite': [255, 250, 240],\n  'forestgreen': [34, 139, 34],\n  // 'fuchsia': [ 255, 0, 255 ],\n  'gainsboro': [220, 220, 220],\n  'ghostwhite': [248, 248, 255],\n  'gold': [255, 215, 0],\n  'goldenrod': [218, 165, 32],\n  // 'gray': [ 128, 128, 128 ],\n  // 'green': [ 0, 128, 0 ],\n  'greenyellow': [173, 255, 47],\n  'grey': [128, 128, 128],\n  'honeydew': [240, 255, 240],\n  'hotpink': [255, 105, 180],\n  'indianred': [205, 92, 92],\n  'indigo': [75, 0, 130],\n  'ivory': [255, 255, 240],\n  'khaki': [240, 230, 140],\n  'lavender': [230, 230, 250],\n  'lavenderblush': [255, 240, 245],\n  'lawngreen': [124, 252, 0],\n  'lemonchiffon': [255, 250, 205],\n  'lightblue': [173, 216, 230],\n  'lightcoral': [240, 128, 128],\n  'lightcyan': [224, 255, 255],\n  'lightgoldenrodyellow': [250, 250, 210],\n  'lightgray': [211, 211, 211],\n  'lightgreen': [144, 238, 144],\n  'lightgrey': [211, 211, 211],\n  'lightpink': [255, 182, 193],\n  'lightsalmon': [255, 160, 122],\n  'lightseagreen': [32, 178, 170],\n  'lightskyblue': [135, 206, 250],\n  'lightslategray': [119, 136, 153],\n  'lightslategrey': [119, 136, 153],\n  'lightsteelblue': [176, 196, 222],\n  'lightyellow': [255, 255, 224],\n  // 'lime': [ 0, 255, 0 ],\n  'limegreen': [50, 205, 50],\n  'linen': [250, 240, 230],\n  'magenta': [255, 0, 255],\n  // 'maroon': [ 128, 0, 0 ],\n  'mediumaquamarine': [102, 205, 170],\n  'mediumblue': [0, 0, 205],\n  'mediumorchid': [186, 85, 211],\n  'mediumpurple': [147, 112, 219],\n  'mediumseagreen': [60, 179, 113],\n  'mediumslateblue': [123, 104, 238],\n  'mediumspringgreen': [0, 250, 154],\n  'mediumturquoise': [72, 209, 204],\n  'mediumvioletred': [199, 21, 133],\n  'midnightblue': [25, 25, 112],\n  'mintcream': [245, 255, 250],\n  'mistyrose': [255, 228, 225],\n  'moccasin': [255, 228, 181],\n  'navajowhite': [255, 222, 173],\n  // 'navy': [ 0, 0, 128 ],\n  'oldlace': [253, 245, 230],\n  // 'olive': [ 128, 128, 0 ],\n  'olivedrab': [107, 142, 35],\n  'orange': [255, 165, 0],\n  'orangered': [255, 69, 0],\n  'orchid': [218, 112, 214],\n  'palegoldenrod': [238, 232, 170],\n  'palegreen': [152, 251, 152],\n  'paleturquoise': [175, 238, 238],\n  'palevioletred': [219, 112, 147],\n  'papayawhip': [255, 239, 213],\n  'peachpuff': [255, 218, 185],\n  'peru': [205, 133, 63],\n  'pink': [255, 192, 203],\n  'plum': [221, 160, 221],\n  'powderblue': [176, 224, 230],\n  // 'purple': [ 128, 0, 128 ],\n  // 'red': [ 255, 0, 0 ],\n  'rosybrown': [188, 143, 143],\n  'royalblue': [65, 105, 225],\n  'saddlebrown': [139, 69, 19],\n  'salmon': [250, 128, 114],\n  'sandybrown': [244, 164, 96],\n  'seagreen': [46, 139, 87],\n  'seashell': [255, 245, 238],\n  'sienna': [160, 82, 45],\n  // 'silver': [ 192, 192, 192 ],\n  'skyblue': [135, 206, 235],\n  'slateblue': [106, 90, 205],\n  'slategray': [112, 128, 144],\n  'slategrey': [112, 128, 144],\n  'snow': [255, 250, 250],\n  'springgreen': [0, 255, 127],\n  'steelblue': [70, 130, 180],\n  'tan': [210, 180, 140],\n  // 'teal': [ 0, 128, 128 ],\n  'thistle': [216, 191, 216],\n  'tomato': [255, 99, 71],\n  'turquoise': [64, 224, 208],\n  'violet': [238, 130, 238],\n  'wheat': [245, 222, 179],\n  // 'white': [ 255, 255, 255 ],\n  'whitesmoke': [245, 245, 245],\n  // 'yellow': [ 255, 255, 0 ],\n  'yellowgreen': [154, 205, 50],\n};\n","// from http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c\n/**\n * Converts an RGB color value to HSL. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n * Assumes r, g, and b are contained in the set [0, 1] and\n * returns h, s, and l in the set [0, 1].\n *\n * @param   {number}  r       The red color value\n * @param   {number}  g       The green color value\n * @param   {number}  b       The blue color value\n * @return  Array           The HSL representation\n */\nexport function rgb2hsl(r: number | number[], g: number, b: number) {\n\n  if (Array.isArray(r)) {\n    b = r[2];\n    g = r[1];\n    r = r[0];\n  }\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  let h = 0;\n  let s;\n  const l = (max + min) / 2;\n\n  if (max === min) {\n    h = s = 0; // achromatic\n  } else {\n    const d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n\n  return [h, s, l];\n}\n","/**\n * Converts RGB color value to HTML5 color value (string)\n * Conversion forumla:\n * - convert R, G, B into HEX strings\n * - return HTML formatted string \"#RRGGBB\"\n */\nexport function rgb2html(r: number | number[], g: number, b: number) {\n  if (Array.isArray(r)) {\n    b = r[2];\n    g = r[1];\n    r = r[0];\n  }\n\n  const s = '#' +\n    Number(0x1000000 + r * 255 * 0x10000 + g * 255 * 0x100 + b * 255).toString(16).substring(1, 7);\n  return s;\n}\n","/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 1] and\n * returns h, s, and v in the set [0, 1].\n *\n * @param   {number}  r       The red color value\n * @param   {number}  g       The green color value\n * @param   {number}  b       The blue color value\n * @return  Array           The HSV representation\n */\nexport function rgb2hsv(r: number | number[], g: number, b: number) {\n  if (Array.isArray(r)) {\n    b = r[2];\n    g = r[1];\n    r = r[0];\n  }\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  let h = 0;\n  let s;\n  const v = max;\n\n  const d = max - min;\n  s = max === 0 ? 0 : d / max;\n\n  if (max === min) {\n    h = 0; // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n\n  return [h, s, v];\n}\n","/**\n * Converts a HTML5 color value (string) to RGB values\n * See the color input type of HTML5 forms\n * Conversion formula:\n * - split the string; \"#RRGGBB\" into RGB components\n * - convert the HEX value into RGB values\n */\nexport function html2rgb(s: string) {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  if (s.length === 7) {\n    r = parseInt('0x' + s.slice(1, 3), 16) / 255;\n    g = parseInt('0x' + s.slice(3, 5), 16) / 255;\n    b = parseInt('0x' + s.slice(5, 7), 16) / 255;\n  }\n  return [r, g, b];\n}\n","/**\n * Converts an HSV color value to RGB. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes h, s, and v are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 1].\n *\n * @param   {number}  h       The hue\n * @param   {number}  s       The saturation\n * @param   {number}  v       The value\n * @return  Array           The RGB representation\n */\nexport function hsv2rgb(h: number | number[], s: number, v: number) {\n  if (Array.isArray(h)) {\n    v = h[2];\n    s = h[1];\n    h = h[0];\n  }\n\n  let r;\n  let g;\n  let b;\n\n  const i = Math.floor(h * 6);\n  const f = h * 6 - i;\n  const p = v * (1 - s);\n  const q = v * (1 - f * s);\n  const t = v * (1 - (1 - f) * s);\n\n  switch (i % 6) {\n    case 0:\n      r = v, g = t, b = p;\n      break;\n    case 1:\n      r = q, g = v, b = p;\n      break;\n    case 2:\n      r = p, g = v, b = t;\n      break;\n    case 3:\n      r = p, g = q, b = v;\n      break;\n    case 4:\n      r = t, g = p, b = v;\n      break;\n    case 5:\n      r = v, g = p, b = q;\n      break;\n  }\n\n  return [r, g, b];\n}\n","import {hue2rgb} from './hue2rgb';\n\n/**\n * Converts an HSL color value to RGB. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n * Assumes h, s, and l are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 1].\n *\n * @param  {Number}  h       The hue\n * @param  {Number}  s       The saturation\n * @param  {Number}  l       The lightness\n * @return  Array           The RGB representation\n */\nexport function hsl2rgb(h: number | number[], s: number, l: number) {\n  if (Array.isArray(h)) {\n    l = h[2];\n    s = h[1];\n    h = h[0];\n  }\n  let r;\n  let g;\n  let b;\n\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n\n  return [r, g, b];\n}\n","const TWO_PI = Math.PI * 2;\n\n// -- Math functions (360 deg based vs 2pi)\n\nexport function sin(a: number) {\n  return Math.sin(a / 360 * TWO_PI);\n}\n\nexport function cos(a: number) {\n  return Math.cos(a / 360 * TWO_PI);\n}\n\nexport function asin(a: number) {\n  return Math.asin(a) / 360 * TWO_PI;\n}\n\nexport function acos(a: number) {\n  return Math.acos(a) / 360 * TWO_PI;\n}\n\nexport function tan(a: number) {\n  return Math.tan(a / 360 * TWO_PI);\n}\n\nexport function atan(a: number) {\n  return Math.atan(a) / 360 * TWO_PI;\n}\n\nexport function atan2(a: number, b: number) {\n  return Math.atan2(a, b) / 360 * TWO_PI;\n}\n\nexport function ceil(a: number) {\n  return Math.ceil(a);\n}\n\nexport function floor(a: number) {\n  return Math.floor(a);\n}\n\nexport function abs(a: number) {\n  return Math.abs(a);\n}\n\nexport function min(a: number, b: number) {\n  return a < b ? a : b;\n}\n\nexport function max(a: number, b: number) {\n  return a > b ? a : b;\n}\n\nexport function rands(minValue: number, maxValue: number, vn: number, seed: number) {\n  // -- seed is ignored for now, FIX IT (requires reimplementation of random())\n  //    see http://stackoverflow.com/questions/424292/how-to-create-my-own-javascript-random-number-generator-that-i-can-also-set-the\n  const v = new Array(vn);\n  for (let i = 0; i < vn; i++) {\n    v[i] = Math.random() * (maxValue - minValue) + minValue;\n  }\n}\n\nexport function log(a: number) {\n  return Math.log(a);\n}\n\nexport function lookup(ix: number, v: number[][]) {\n  let r = 0;\n  for (let i = 0; i < v.length; i++) {\n    let a0 = v[i];\n    if (a0[0] >= ix) {\n      i--;\n      a0 = v[i];\n      const a1 = v[i + 1];\n      let m = 0;\n      if (a0[0] !== a1[0]) {\n        m = abs((ix - a0[0]) / (a1[0] - a0[0]));\n      }\n      // echo(\">>\",i,ix,a0[0],a1[0],\";\",m,a0[1],a1[1])\n      if (m > 0) {\n        r = a0[1] * (1 - m) + a1[1] * m;\n      } else {\n        r = a0[1];\n      }\n      return r;\n    }\n  }\n  return r;\n}\n\nexport function pow(a: number, b: number) {\n  return Math.pow(a, b);\n}\n\nexport function sign(a: number) {\n  return a < 0 ? -1 : (a > 1 ? 1 : 0);\n}\n\nexport function sqrt(a: number) {\n  return Math.sqrt(a);\n}\n\nexport function round(a: number) {\n  return floor(a + 0.5);\n}\n","export * from './translateLine';\nexport * from './vector_char';\nexport * from './vectorChar';\nexport * from './vectorParams';\nexport * from './vector_text';\nexport * from './vectorText';\n","import {vectorChar} from './vectorChar';\n\n/**\n * Construct a {@link VectorCharObject} from a ascii character whose code is between 31 and 127,\n * if the character is not supported it is replaced by a question mark.\n * @param {number} x - x offset\n * @param {number} y - y offset\n * @param {String} char - ascii character\n * @returns {VectorCharObject}\n * @deprecated >= v2\n * @example\n * let vectorCharObject = vector_char(36, 0, 'B')\n */\nexport function vector_char(x: number, y: number, char: string) {\n  return vectorChar({xOffset: x, yOffset: y}, char);\n}\n","import {IVectorFont} from '@root/text/types/VectorTextTypes';\n\n// -- data source from from http://paulbourke.net/dataformats/hershey/\n// -- reduced to save some bytes...\n// { [ascii code]: [width, x, y, ...] } - undefined value as path separator\n\nexport const hersheyFont: IVectorFont = {\n  height: 14,\n  32: [16],\n  33: [10, 5, 21, 5, 7, , 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],\n  34: [16, 4, 21, 4, 14, , 12, 21, 12, 14],\n  35: [21, 11, 25, 4, -7, , 17, 25, 10, -7, , 4, 12, 18, 12, , 3, 6, 17, 6],\n  36: [20, 8, 25, 8, -4, , 12, 25, 12, -4, , 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3],\n  37: [24, 21, 21, 3, 0, , 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, , 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7],\n  38: [26, 23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2],\n  39: [10, 5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15],\n  40: [14, 11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7],\n  41: [14, 3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7],\n  42: [16, 8, 21, 8, 9, , 3, 18, 13, 12, , 13, 18, 3, 12],\n  43: [26, 13, 18, 13, 0, , 4, 9, 22, 9],\n  44: [10, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4],\n  45: [26, 4, 9, 22, 9],\n  46: [10, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],\n  47: [22, 20, 25, 2, -7],\n  48: [20, 9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21],\n  49: [20, 6, 17, 8, 18, 11, 21, 11, 0],\n  50: [20, 4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0],\n  51: [20, 5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4],\n  52: [20, 13, 21, 3, 7, 18, 7, , 13, 21, 13, 0],\n  53: [20, 15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4],\n  54: [20, 16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7],\n  55: [20, 17, 21, 7, 0, , 3, 21, 17, 21],\n  56: [20, 8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21],\n  57: [20, 16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3],\n  58: [10, 5, 14, 4, 13, 5, 12, 6, 13, 5, 14, , 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],\n  59: [10, 5, 14, 4, 13, 5, 12, 6, 13, 5, 14, , 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4],\n  60: [24, 20, 18, 4, 9, 20, 0],\n  61: [26, 4, 12, 22, 12, , 4, 6, 22, 6],\n  62: [24, 4, 18, 20, 9, 4, 0],\n  63: [18, 3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, , 9, 2, 8, 1, 9, 0, 10, 1, 9, 2],\n  64: [27, 18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, , 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, , 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, , 19, 16, 18, 8, 18, 6, 19, 5],\n  65: [18, 9, 21, 1, 0, , 9, 21, 17, 0, , 4, 7, 14, 7],\n  66: [21, 4, 21, 4, 0, , 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, , 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0],\n  67: [21, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5],\n  68: [21, 4, 21, 4, 0, , 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0],\n  69: [19, 4, 21, 4, 0, , 4, 21, 17, 21, , 4, 11, 12, 11, , 4, 0, 17, 0],\n  70: [18, 4, 21, 4, 0, , 4, 21, 17, 21, , 4, 11, 12, 11],\n  71: [21, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, , 13, 8, 18, 8],\n  72: [22, 4, 21, 4, 0, , 18, 21, 18, 0, , 4, 11, 18, 11],\n  73: [8, 4, 21, 4, 0],\n  74: [16, 12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7],\n  75: [21, 4, 21, 4, 0, , 18, 21, 4, 7, , 9, 12, 18, 0],\n  76: [17, 4, 21, 4, 0, , 4, 0, 16, 0],\n  77: [24, 4, 21, 4, 0, , 4, 21, 12, 0, , 20, 21, 12, 0, , 20, 21, 20, 0],\n  78: [22, 4, 21, 4, 0, , 4, 21, 18, 0, , 18, 21, 18, 0],\n  79: [22, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21],\n  80: [21, 4, 21, 4, 0, , 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10],\n  81: [22, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, , 12, 4, 18, -2],\n  82: [21, 4, 21, 4, 0, , 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, , 11, 11, 18, 0],\n  83: [20, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3],\n  84: [16, 8, 21, 8, 0, , 1, 21, 15, 21],\n  85: [22, 4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21],\n  86: [18, 1, 21, 9, 0, , 17, 21, 9, 0],\n  87: [24, 2, 21, 7, 0, , 12, 21, 7, 0, , 12, 21, 17, 0, , 22, 21, 17, 0],\n  88: [20, 3, 21, 17, 0, , 17, 21, 3, 0],\n  89: [18, 1, 21, 9, 11, 9, 0, , 17, 21, 9, 11],\n  90: [20, 17, 21, 3, 0, , 3, 21, 17, 21, , 3, 0, 17, 0],\n  91: [14, 4, 25, 4, -7, , 5, 25, 5, -7, , 4, 25, 11, 25, , 4, -7, 11, -7],\n  92: [14, 0, 21, 14, -3],\n  93: [14, 9, 25, 9, -7, , 10, 25, 10, -7, , 3, 25, 10, 25, , 3, -7, 10, -7],\n  94: [16, 6, 15, 8, 18, 10, 15, , 3, 12, 8, 17, 13, 12, , 8, 17, 8, 0],\n  95: [16, 0, -2, 16, -2],\n  96: [10, 6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17],\n  97: [19, 15, 14, 15, 0, , 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  98: [19, 4, 21, 4, 0, , 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3],\n  99: [18, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  100: [19, 15, 21, 15, 0, , 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  101: [18, 3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  102: [12, 10, 21, 8, 21, 6, 20, 5, 17, 5, 0, , 2, 14, 9, 14],\n  103: [19, 15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, , 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  104: [19, 4, 21, 4, 0, , 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0],\n  105: [8, 3, 21, 4, 20, 5, 21, 4, 22, 3, 21, , 4, 14, 4, 0],\n  106: [10, 5, 21, 6, 20, 7, 21, 6, 22, 5, 21, , 6, 14, 6, -3, 5, -6, 3, -7, 1, -7],\n  107: [17, 4, 21, 4, 0, , 14, 14, 4, 4, , 8, 8, 15, 0],\n  108: [8, 4, 21, 4, 0],\n  109: [30, 4, 14, 4, 0, , 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, , 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0],\n  110: [19, 4, 14, 4, 0, , 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0],\n  111: [19, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14],\n  112: [19, 4, 14, 4, -7, , 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3],\n  113: [19, 15, 14, 15, -7, , 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],\n  114: [13, 4, 14, 4, 0, , 4, 8, 5, 11, 7, 13, 9, 14, 12, 14],\n  115: [17, 14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3],\n  116: [12, 5, 21, 5, 4, 6, 1, 8, 0, 10, 0, , 2, 14, 9, 14],\n  117: [19, 4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, , 15, 14, 15, 0],\n  118: [16, 2, 14, 8, 0, , 14, 14, 8, 0],\n  119: [22, 3, 14, 7, 0, , 11, 14, 7, 0, , 11, 14, 15, 0, , 19, 14, 15, 0],\n  120: [17, 3, 14, 14, 0, , 14, 14, 3, 0],\n  121: [16, 2, 14, 8, 0, , 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7],\n  122: [17, 14, 14, 3, 0, , 3, 14, 14, 14, , 3, 0, 14, 0],\n  123: [14, 9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, , 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, , 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7],\n  124: [8, 4, 25, 4, -7],\n  125: [14, 5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, , 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, , 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7],\n  126: [24, 3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, , 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12],\n};\n","import {vectorText} from './vectorText';\n\n/**\n * Construct an array of character segments from a ascii string whose characters code is between 31 and 127,\n * if one character is not supported it is replaced by a question mark.\n * @param {number} x - x offset\n * @param {number} y - y offset\n * @param {string} text - ascii string\n * @returns {Array} characters segments [[[x, y], ...], ...]\n * @deprecated >= v2\n *\n * @example\n * let textSegments = vector_text(0, -20, 'OpenJSCAD')\n */\nexport function vector_text(x: number, y: number, text: string) {\n  return vectorText({xOffset: x, yOffset: y}, text);\n}\n"],"sourceRoot":""}